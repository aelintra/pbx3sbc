#!opensips
#
# OpenSIPS SIP Edge Router Configuration Template
# This configuration provides SIP edge routing functionality for Asterisk PBX backends
#
# Based on requirements in REQUIREMENTS-FOR-OPENSIPS.md
# Troubleshooting notes in TROUBLESHOOTING-OPTIONS-ROUTING.md
#

####### Global Parameters #########

# The default log_level is usually enough for most things but you can increase
# it here for lower levels of visibility 
#log_level=4

# OpenSIPS parameter configuration
# Debug level can be set via command line: opensips -D 3
# Or via modparam for specific modules

# Module path (Ubuntu/Debian package location)
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules"

# Listen on all interfaces (socket replaces deprecated listen)
socket=udp:0.0.0.0:5060

# Set advertised address (replace with your OpenSIPS server's IP address)
# This fixes the Via header showing 0.0.0.0
# For cloud deployments, this MUST be your public IP address
# Use --advertised-ip parameter during installation, or manually edit after installation
# The install.sh script will replace CHANGE_ME with the provided IP address
advertised_address="CHANGE_ME"

####### Modules ########

# Core modules
# Note: is_method(), has_totag() are built into OpenSIPS core
# Note: siputils and sanity modules don't exist in OpenSIPS - functions are built-in
# Note: pv (pseudo-variables) and xlog are built into OpenSIPS core
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
# Transport protocol - required for socket binding
loadmodule "proto_udp.so"
loadmodule "db_mysql.so"
# SQL operations module for database queries
loadmodule "sqlops.so"
loadmodule "dispatcher.so"
loadmodule "sipmsgops.so"
# NAT traversal module for fixing Contact headers and SDP
loadmodule "nathelper.so"
# Dialog module for CDR (Call Detail Records) - must be loaded before acc module
loadmodule "dialog.so"
# Accounting module for CDR (Call Detail Records)
loadmodule "acc.so"
# User location module for endpoint registration tracking (usrloc migration)
loadmodule "usrloc.so"
# Signaling module (required dependency for registrar module)
loadmodule "signaling.so"
# Registrar module provides save() and lookup() functions (uses usrloc as backend)
loadmodule "registrar.so"
# Domain module for domain management (used with usrloc for multi-tenant support)
loadmodule "domain.so"
# HTTP server module (required for Prometheus module)
loadmodule "httpd.so"
# Prometheus module for metrics export (requires opensips-prometheus-module package)
loadmodule "prometheus.so"

####### Module Parameters ########

# --- NAT Environment Detection ---
# Auto-detected by install script based on advertised_address
# Install script checks if advertised_address is public IP (not RFC 1918)
# If public IP: NAT_ENVIRONMENT_AUTO_DETECT will be set to "1" (NAT fixes enabled)
# If private IP or CHANGE_ME: NAT_ENVIRONMENT_AUTO_DETECT will be set to "0" (NAT fixes disabled)
# Install script replaces NAT_ENVIRONMENT_AUTO_DETECT placeholder with detected value
#NAT_ENVIRONMENT_AUTO_DETECT=0

# --- MySQL routing database ---
# SQL operations module connection for sql_query() function
modparam("sqlops", "db_url", "mysql://opensips:your-password@localhost/opensips")

# --- Dispatcher (health checks via SIP OPTIONS) ---
modparam("dispatcher", "db_url", "mysql://opensips:your-password@localhost/opensips")

modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_threshold", 2)
# Note: ds_inactive_threshold doesn't exist in OpenSIPS dispatcher module
# Note: ds_ping_reply_codes is called options_reply_codes in OpenSIPS
modparam("dispatcher", "options_reply_codes", "200")

# --- Dialog module (required for CDR mode) ---
modparam("dialog", "db_url", "mysql://opensips:your-password@localhost/opensips")
modparam("dialog", "db_mode", 2)
# db_mode: 0 = no DB, 1 = DB only, 2 = cached DB (we use 2 for cached DB - better for CDR correlation)
# db_update_period: How often to flush cached dialogs to DB (seconds, default 60)
# Set to lower value for more frequent writes (useful for monitoring)
modparam("dialog", "db_update_period", 10)

# --- Accounting (CDR) ---
modparam("acc", "db_url", "mysql://opensips:your-password@localhost/opensips")
modparam("acc", "early_media", 0)
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 1)
# Extra fields for billing: capture From and To SIP URIs
# Format: backend:tag->column_name;tag->column_name
# $fu = From URI, $tu = To URI
# This modparam tells the acc module which extra columns exist in the database
modparam("acc", "extra_fields", "db:from_uri->from_uri;to_uri->to_uri")
# Note: from_uri and to_uri columns are added to acc table via init-database.sh
# These are populated via $acc_extra() in the script (see INVITE handling)

# --- User location module (usrloc migration) ---
modparam("usrloc", "db_url", "mysql://opensips:your-password@localhost/opensips")
# db_mode: 0 = memory only, 1 = DB only (write-through), 2 = cached DB
# Using db_mode=1 (write-through) ensures save() writes to DB immediately, allowing SQL UPDATE to work right away
# This solves the issue where SQL UPDATE fails with db_mode=2 because record is still in memory
# Trade-off: Slower performance under high load (every operation hits DB)
modparam("usrloc", "db_mode", 1)
# use_domain: 1 = domain-aware (REQUIRED for multi-tenant - allows same username across domains)
modparam("usrloc", "use_domain", 1)
# nat_bflag: Flag name for NAT detection (used with nathelper module)
modparam("usrloc", "nat_bflag", "NAT")
# timer_interval: How often to flush cached contacts to DB (seconds, default 60)
# Note: With db_mode=1, this parameter is not used (writes go directly to DB)
# Keeping it for compatibility, but it has no effect in write-through mode
modparam("usrloc", "timer_interval", 10)
# regen_broken_contactid: Regenerate invalid/broken contact_id values on startup
# This fixes contact_id values that are out of range or invalid (e.g., from schema migration)
modparam("usrloc", "regen_broken_contactid", 1)

# --- Registrar module (provides save() and lookup() functions) ---
# mcontact_avp: AVP name where registrar module stores modified Contact from main registrar's 200 OK reply
# When the main registrar modifies the Contact header in its 200 OK reply, registrar module stores it here
# This allows save() in onreply_route to use the modified Contact (if reply Contact is modified)
# NOTE: If reply Contact is <null> or missing, save() cannot extract contact info and will fail
modparam("registrar", "mcontact_avp", "$avp(mcontact)")

# --- Domain module (multi-tenant support) ---
modparam("domain", "db_url", "mysql://opensips:your-password@localhost/opensips")
# db_mode: 0 = no DB, 1 = DB only, 2 = cached DB (we use 2 for cached DB)
modparam("domain", "db_mode", 2)
# domain_table: Name of the domain table (default: "domain")
modparam("domain", "domain_table", "domain")
# domain_col: Column name for domain (default: "domain")
modparam("domain", "domain_col", "domain")

# --- HTTP Server (Required for Prometheus module) ---
# Configure HTTP server for Prometheus metrics endpoint
# Listen on all interfaces, port 8888
modparam("httpd", "ip", "0.0.0.0")
modparam("httpd", "port", 8888)
# Note: For localhost-only access, use: modparam("httpd", "ip", "127.0.0.1")

# --- Prometheus Module (Metrics Export) ---
# Metrics endpoint path (default: /metrics)
# Access at: http://localhost:8888/metrics (or http://<server-ip>:8888/metrics)
modparam("prometheus", "root", "metrics")
# Metric prefix (default: opensips) - prepended to all metric names
modparam("prometheus", "prefix", "opensips")
# Group mode: 1 = include group in metric name (e.g., opensips_core_rcv_requests)
# Group mode: 0 = exclude group (e.g., opensips_rcv_requests)
modparam("prometheus", "group_mode", 1)
# Export statistics (can be defined multiple times)
# Syntax: "group:" exports all stats in that group, or specific stat names like "active_dialogs"
# You can mix groups and specific stat names in the same modparam call
#
# Example: modparam("prometheus", "statistics", "active_dialogs load: stats:")
#   - Exports specific stat "active_dialogs"
#   - Exports all stats in "load" group
#   - Exports all stats in "stats" group
#
# Current configuration uses group-based exports (recommended for comprehensive monitoring):
# Core statistics (all core stats)
modparam("prometheus", "statistics", "core:")
# Transaction statistics (all transaction stats)
modparam("prometheus", "statistics", "tm:")
# Dialog statistics (all dialog stats)
modparam("prometheus", "statistics", "dialog:")
# Dispatcher statistics (all dispatcher stats)
modparam("prometheus", "statistics", "dispatcher:")
# User location statistics (all usrloc stats)
modparam("prometheus", "statistics", "usrloc:")
# Accounting statistics (all accounting stats)
modparam("prometheus", "statistics", "acc:")

# Alternative: Export specific statistics only (uncomment to use instead of groups above)
# This approach exports only selected metrics (useful for reducing metric volume)
# Uncomment the lines below and comment out the group-based exports above if needed:
# modparam("prometheus", "statistics", "core:rcv_requests core:rcv_replies core:drop_requests")
# modparam("prometheus", "statistics", "tm:active_transactions tm:transactions")
# modparam("prometheus", "statistics", "dialog:active_dialogs dialog:early_dialogs")
# modparam("prometheus", "statistics", "dispatcher:active_destinations dispatcher:inactive_destinations")
# modparam("prometheus", "statistics", "usrloc:registered_users")
# modparam("prometheus", "statistics", "acc:acc_requests")

# Or export ALL statistics (uncomment to enable - exports everything)
# modparam("prometheus", "statistics", "all")
# Note: If "all" is specified, other statistics parameters are ignored

# --- Transaction timers ---
# Note: fr_timer is not a modparam in OpenSIPS - transaction timeouts are handled differently
# restart_fr_on_each_reply: reset final response timer on each provisional response
modparam("tm", "restart_fr_on_each_reply", 1)
# T1_timer: initial retransmission period (2 seconds = 2000ms)
# Note: OpenSIPS uses T1_timer instead of retr_timer1
modparam("tm", "T1_timer", 2000)
# T2_timer: maximum retransmission period (8 seconds = 8000ms)
# Note: OpenSIPS uses T2_timer instead of retr_timer2
modparam("tm", "T2_timer", 8000)

# --- Response handling ---
# OpenSIPS handles responses differently - ensure proper forwarding

####### Routing Logic ########

route {
    # ---- Log ALL requests at the very start for debugging ----
    xlog("REQUEST: $rm from $si:$sp to $ru (Call-ID: $hdr(Call-ID))\n");
    
    # Log SDP details for INVITE requests to diagnose audio issues
    if (is_method("INVITE") && $hdr(Content-Type) =~ "application/sdp") {
        $var(from_user) = $(fu{uri.user});
        $var(to_user) = $(tu{uri.user});
        xlog("INVITE with SDP: From=$var(from_user)@$si, To=$var(to_user)@$rd\n");
    }

    # ---- Basic hygiene ----
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    # Note: sanity_check() module not available in OpenSIPS
    # Basic validation is handled by core parsing

    # ---- Drop known scanners ----
    if ($ua =~ "sipvicious|friendly-scanner|sipcli|nmap") {
        exit;
    }

    # ---- In-dialog requests ----
    # Check if To tag exists (in-dialog request)
    # OpenSIPS uses $to_tag pseudo-variable for To header tag
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    # ---- Allowed methods only ----
    if (!is_method("REGISTER|INVITE|ACK|BYE|CANCEL|OPTIONS|NOTIFY|SUBSCRIBE|PRACK")) {
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }

    # ---- Handle CANCEL early (before domain check) ----
    # CANCEL needs to match existing INVITE transaction
    if (is_method("CANCEL")) {
        xlog("CANCEL received from $si:$sp for Call-ID: $hdr(Call-ID), CSeq=$hdr(CSeq), From=$fu, To=$tu\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("CANCEL matches existing transaction, forwarding to cancel INVITE\n");
        } else {
            xlog("L_WARN", "CANCEL received but no matching transaction found\n");
            sl_send_reply(481, "Call/Transaction Does Not Exist");
            exit;
        }
        # Forward CANCEL to cancel the INVITE transaction
        route(RELAY);
        exit;
    }

    # ---- Handle OPTIONS and NOTIFY from Asterisk backends (to endpoints) ----
    # Asterisk sends OPTIONS to registered endpoints for health checks and NAT keepalive
    # Asterisk sends NOTIFY for event notifications (e.g., message waiting indicators)
    # These need to be routed back to the actual endpoint IP
    if (is_method("OPTIONS|NOTIFY")) {
        # Check if this is coming from a known dispatcher destination (Asterisk backend)
        # Query database to see if source IP matches any dispatcher destination
        $var(source_ip) = $si;
        xlog("OPTIONS/NOTIFY received from $si, checking if from dispatcher\n");
        
        # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
        # If so, try endpoint lookup regardless of dispatcher check
        # Request-URI format: sip:401@192.168.1.138:56931 or sip:401@192.168.1.138
        $var(should_try_endpoint) = 0;
        
        # Check if Request-URI has a username
        if ($rU != "") {
            # Check if Request-URI domain is an IP address (contains digits and dots, not a domain name)
            # Simple heuristic: if domain contains only digits, dots, and colons, it's likely an IP
            if ($rd =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                $var(should_try_endpoint) = 1;
                xlog("OPTIONS/NOTIFY Request-URI looks like endpoint: $rU@$rd\n");
            }
        }
        
        # Also check if source IP is from a known dispatcher destination
        # For now, we'll try endpoint lookup if Request-URI looks like an endpoint
        # or if we want to check dispatcher destinations, we can add that logic here
        
        if ($var(should_try_endpoint) > 0) {
            
                    # Extract endpoint identifier
                    # Try To header first (may have domain), fallback to Request-URI username
                    $var(endpoint_user) = $tU;
                    if ($var(endpoint_user) == "") {
                        $var(endpoint_user) = $rU;
                    }
                    
                    # Try to get domain from To header
                    $var(to_domain) = $(tu{uri.domain});
                    $var(lookup_uri) = "";
                    
                    # Check if To header domain is an IP address (not a domain name)
                    if ($var(to_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # To header has IP, not domain - determine domain from Asterisk source IP
                        # This is CRITICAL for multi-tenant deployments (same extension numbers across customers)
                        route(GET_DOMAIN_FROM_SOURCE_IP);
                        if ($var(domain_detection_success) == 1) {
                            # Domain found from source IP - use domain-specific lookup (CORRECT for multi-tenant)
                            $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@" + $var(domain_from_source);
                            xlog("OPTIONS/NOTIFY: To header has IP ($var(to_domain)), determined domain from source IP: $var(domain_from_source), using domain-specific lookup: $var(lookup_uri)\n");
                        } else {
                            # Domain not found - use SQL wildcard lookup as fallback (with warning)
                            $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@*";
                            xlog("L_WARN", "OPTIONS/NOTIFY: To header has IP ($var(to_domain)), but could not determine domain from source IP $si, using wildcard lookup (may route to wrong customer in multi-tenant)\n");
                        }
                    } else if ($var(to_domain) != "") {
                        # To header has domain - use domain-specific lookup (CORRECT for multi-tenant)
                        $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@" + $var(to_domain);
                        xlog("OPTIONS/NOTIFY: Using domain-specific lookup: $var(lookup_uri)\n");
                    } else {
                        # No domain in To header - try to determine from source IP
                        route(GET_DOMAIN_FROM_SOURCE_IP);
                        if ($var(domain_detection_success) == 1) {
                            # Domain found from source IP - use domain-specific lookup (CORRECT for multi-tenant)
                            $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@" + $var(domain_from_source);
                            xlog("OPTIONS/NOTIFY: No domain in To header, determined domain from source IP: $var(domain_from_source), using domain-specific lookup: $var(lookup_uri)\n");
                        } else {
                            # Domain not found - use SQL wildcard lookup as fallback (with warning)
                            $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@*";
                            xlog("L_WARN", "OPTIONS/NOTIFY: No domain in To header and could not determine domain from source IP $si, using wildcard lookup (may route to wrong customer in multi-tenant)\n");
                        }
                    }
                    
                    xlog("OPTIONS/NOTIFY from Asterisk $si, looking up endpoint: $var(lookup_uri) (user: $var(endpoint_user))\n");
                    
                    # Use OpenSIPS lookup() function to find endpoint in location table
                    # lookup() uses Request-URI to find contacts, so we need to set it first
                    # Save original Request-URI (to restore if lookup fails)
                    $var(original_ru) = $ru;
                    
                    # Check if we have a wildcard lookup (contains @*)
                    if ($var(lookup_uri) =~ "@\\*") {
                        # Wildcard lookup - need to use SQL query for now
                        # TODO: Improve this to determine domain from dispatcher setid
                        xlog("OPTIONS/NOTIFY: Wildcard lookup detected, using SQL fallback\n");
                        $var(query) = "SELECT contact FROM location WHERE username='" + $var(endpoint_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                        if (sql_query($var(query), "$avp(contact_uri)") && $(avp(contact_uri)[0]) != "") {
                            $du = $(avp(contact_uri)[0]);
                            $ru = $du;
                            xlog("OPTIONS/NOTIFY: SQL lookup found contact: $du\n");
                            route(RELAY);
                            exit;
                        } else {
                            $ru = $var(original_ru);
                            xlog("OPTIONS/NOTIFY: SQL lookup returned no results\n");
                        }
                    } else {
                        # Domain-specific lookup - set Request-URI and use lookup()
                        # CRITICAL: Set $ru to lookup_uri BEFORE calling lookup()
                        # lookup() will update $ru with the contact if found
                        $ru = $var(lookup_uri);
                        # Save what we set $ru to, so we can detect if lookup() changed it
                        $var(ru_before_lookup) = $ru;
                        
                        # lookup() sets $du automatically if contact found
                        # NOTE: In OpenSIPS 3.6, if lookup() returns TRUE but $du is null,
                        # it means $ru was updated with the registered contact (local contact, no outbound proxy)
                        $var(lookup_success) = 0;
                        $var(du_is_valid) = 0;
                        $var(ru_is_valid) = 0;
                        
                        if (lookup("location")) {
                            # Contact found - $du is set automatically by lookup(), OR $ru is updated with contact
                            xlog("OPTIONS/NOTIFY: lookup() returned TRUE - contact found\n");
                            xlog("OPTIONS/NOTIFY: After lookup() - $du=$du, $ru=$ru, ru_before_lookup=$var(ru_before_lookup)\n");
                            $var(lookup_success) = 1;
                            
                            # Check if $du is set (outbound proxy case)
                            if ($du != "" && $du != "<null>" && $du != "0" && $du =~ "^sip:") {
                                $var(du_is_valid) = 1;
                                xlog("OPTIONS/NOTIFY: $du is valid - using outbound proxy destination\n");
                            } else {
                                # $du is null - check if $ru was updated with contact (local contact case)
                                xlog("OPTIONS/NOTIFY: $du is null - checking if $ru was updated by lookup()\n");
                                xlog("OPTIONS/NOTIFY: $ru changed from $var(ru_before_lookup) to $ru\n");
                                
                                # Check if $ru was changed by lookup() (contains contact, not the lookup URI)
                                if ($ru != "" && $ru != $var(ru_before_lookup) && $ru =~ "^sip:") {
                                    # Extract domain/IP from $ru to validate
                                    $var(ru_domain) = $(ru{uri.domain});
                                    if ($var(ru_domain) != "" && ($var(ru_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" || $var(ru_domain) !~ "^[0-9]")) {
                                        $var(ru_is_valid) = 1;
                                        # Set $du = $ru for routing (local contact, no outbound proxy)
                                        $du = $ru;
                                        xlog("OPTIONS/NOTIFY: $ru is valid contact - using $ru as destination (local contact, no outbound proxy)\n");
                                    } else {
                                        xlog("OPTIONS/NOTIFY: $ru domain is invalid: $var(ru_domain)\n");
                                    }
                                } else {
                                    xlog("OPTIONS/NOTIFY: $ru was not updated by lookup() (still $var(ru_before_lookup)) - will use SQL fallback\n");
                                }
                            }
                        } else {
                            # Restore original Request-URI
                            $ru = $var(original_ru);
                            xlog("OPTIONS/NOTIFY: lookup() returned FALSE - no contact found for $var(lookup_uri)\n");
                        }
                        
                        # If lookup() succeeded and either $du or $ru is valid, route immediately
                        if ($var(lookup_success) == 1 && ($var(du_is_valid) == 1 || $var(ru_is_valid) == 1)) {
                            # Request-URI is already set to destination by lookup()
                            xlog("OPTIONS/NOTIFY: Routing $rm from Asterisk $si to endpoint $du, Request-URI=$ru, Call-ID=$hdr(Call-ID)\n");
                            route(RELAY);
                            exit;
                        }
                        
                        # If we get here, either lookup() returned FALSE or $du was empty/invalid
                        # RACE CONDITION FIX: Try SQL fallback to check database directly (handles timing issues)
                        # Extract domain from lookup_uri (format: sip:user@domain)
                        # Use domain_from_source if available (from earlier detection), otherwise extract from lookup_uri
                        $var(fallback_domain) = "";
                        if ($var(domain_from_source) != "") {
                            $var(fallback_domain) = $var(domain_from_source);
                        } else if ($var(to_domain) != "" && $var(to_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                            $var(fallback_domain) = $var(to_domain);
                        } else if ($var(lookup_uri) =~ "@([^:>]+)") {
                            $var(fallback_domain) = $re;
                        }
                        
                        if ($var(fallback_domain) != "") {
                                # Try SQL query as fallback - check DB directly (bypasses memory cache)
                                xlog("OPTIONS/NOTIFY: Trying SQL fallback for domain-specific lookup (race condition handling)\n");
                                xlog("OPTIONS/NOTIFY: SQL fallback query for user=$var(endpoint_user), domain=$var(fallback_domain)\n");
                                # Use received field if available (NAT traversal), otherwise use contact field
                                $var(query) = "SELECT COALESCE(received, contact) FROM location WHERE username='" + $var(endpoint_user) + "' AND domain='" + $var(fallback_domain) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                                if (sql_query($var(query), "$avp(fallback_contact)")) {
                                    xlog("OPTIONS/NOTIFY: SQL fallback query executed, checking result\n");
                                    if ($(avp(fallback_contact)[0]) != "" && $(avp(fallback_contact)[0]) != "<null>") {
                                        # Extract IP:port from received or contact field using SQL (regex $re doesn't work)
                                        $var(contact_value) = $(avp(fallback_contact)[0]);
                                        xlog("OPTIONS/NOTIFY: SQL fallback found contact value: [$var(contact_value)]\n");
                                        $var(extracted_ip) = "";
                                        $var(extracted_port) = "";
                                        
                                        # Check if it's received field format (IP:port) or contact field format (sip:user@IP:port)
                                        # received field format: 74.83.23.44:5060
                                        if ($var(contact_value) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:") {
                                            # received field - extract IP and port using SQL
                                            $var(query_ip) = "SELECT SUBSTRING_INDEX('" + $var(contact_value) + "', ':', 1)";
                                            if (sql_query($var(query_ip), "$avp(fallback_ip)")) {
                                                $var(extracted_ip) = $(avp(fallback_ip)[0]);
                                            }
                                            $var(query_port) = "SELECT SUBSTRING_INDEX('" + $var(contact_value) + "', ':', -1)";
                                            if (sql_query($var(query_port), "$avp(fallback_port)")) {
                                                $var(extracted_port) = $(avp(fallback_port)[0]);
                                            }
                                        } else if ($var(contact_value) =~ "^sip:") {
                                            # contact field format: sip:user@IP:port or sip:user@IP
                                            # Extract everything after @ and before : (or end of string)
                                            $var(query_at) = "SELECT SUBSTRING_INDEX('" + $var(contact_value) + "', '@', -1)";
                                            if (sql_query($var(query_at), "$avp(fallback_at_part)")) {
                                                $var(at_part) = $(avp(fallback_at_part)[0]);
                                                # Extract IP (before colon if present)
                                                $var(query_ip) = "SELECT SUBSTRING_INDEX('" + $var(at_part) + "', ':', 1)";
                                                if (sql_query($var(query_ip), "$avp(fallback_ip)")) {
                                                    $var(extracted_ip) = $(avp(fallback_ip)[0]);
                                                }
                                                # Extract port (after colon if present)
                                                if ($var(at_part) =~ ":") {
                                                    $var(query_port) = "SELECT SUBSTRING_INDEX('" + $var(at_part) + "', ':', -1)";
                                                    if (sql_query($var(query_port), "$avp(fallback_port)")) {
                                                        $var(extracted_port) = $(avp(fallback_port)[0]);
                                                    }
                                                } else {
                                                    $var(extracted_port) = "5060";
                                                }
                                            }
                                        }
                                        
                                        # Validate and construct destination URI
                                        if ($var(extracted_ip) != "" && $var(extracted_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                                            # Construct destination URI
                                            if ($var(extracted_port) != "" && $var(extracted_port) != "<null>") {
                                                $du = "sip:" + $var(endpoint_user) + "@" + $var(extracted_ip) + ":" + $var(extracted_port);
                                            } else {
                                                $du = "sip:" + $var(endpoint_user) + "@" + $var(extracted_ip) + ":5060";
                                            }
                                            $ru = $du;
                                            xlog("OPTIONS/NOTIFY: SQL fallback found contact: $du (race condition resolved)\n");
                                            route(RELAY);
                                            exit;
                                        } else {
                                            xlog("L_WARN", "OPTIONS/NOTIFY: SQL fallback found contact value but extraction failed: [$var(contact_value)], extracted_ip=[$var(extracted_ip)], extracted_port=[$var(extracted_port)]\n");
                                        }
                                    } else {
                                        xlog("L_WARN", "OPTIONS/NOTIFY: SQL fallback query returned empty or null result for user=$var(endpoint_user), domain=$var(fallback_domain)\n");
                                    }
                                } else {
                                    xlog("L_WARN", "OPTIONS/NOTIFY: SQL fallback query failed for user=$var(endpoint_user), domain=$var(fallback_domain)\n");
                                }
                            }
                    }
                    
                    # Endpoint lookup failed - handle fallback
                    xlog("L_WARN", "$rm from Asterisk $si to $var(endpoint_aor) - endpoint location not found in database\n");
                    if (is_method("OPTIONS")) {
                        sl_send_reply(200, "OK");
                    } else {
                        # For NOTIFY, try to route based on Contact header if available
                        # Extract IP and port from Contact header using regex
                        $var(notify_ip) = "";
                        $var(notify_port) = "";
                        if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                            $var(notify_ip) = $re;
                            if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                                $var(notify_port) = $re;
                            }
                        }
                        
                        if ($var(notify_ip) != "" && $var(notify_ip) != $si) {
                            $du = "sip:" + $tU + "@" + $var(notify_ip);
                            if ($var(notify_port) != "") {
                                $du = $du + ":" + $var(notify_port);
                            } else {
                                $du = $du + ":5060";
                            }
                            xlog("Routing $rm to $du (fallback from Contact header)\n");
                            route(RELAY);
                        } else {
                            sl_send_reply(404, "Not Found");
                        }
                    }
                    exit;
        }
        
        # If we get here, Request-URI doesn't look like an endpoint, continue normal routing
        xlog("OPTIONS/NOTIFY from $si - Request-URI doesn't look like endpoint, continuing normal routing\n");
    }
    
    # ---- Handle REGISTER to track endpoint locations (usrloc migration) ----
    if (is_method("REGISTER")) {
        if ($hdr(Contact) != "") {
            # Detect NAT using nat_uac_test() - checks Contact (1), Via (4), port mismatch (16)
            # Flag 19 = 1 (Contact) + 2 (received mismatch) + 16 (port mismatch)
            # This is more comprehensive than manual IP checking
            if (nat_uac_test("19")) {
                xlog("REGISTER: NAT detected via nat_uac_test() - endpoint is behind NAT\n");
            }
            
            # Fix NAT in REGISTER request (needed for proper Contact header handling)
            # This updates Contact header with public IP if behind NAT
            fix_nated_register();
            
            # Store original Contact header (with NAT fixes) in AVP for diagnostic purposes
            # NOTE: save() extracts Contact from the REPLY, not the request
            # If reply Contact is <null>, save() cannot work (this is a limitation of proxy-registrar mode)
            # We store request Contact here only for logging/diagnostics
            $avp(reg_contact) = $hdr(Contact);
            
            # CRITICAL: Capture original request source IP:port for NAT traversal
            # In onreply_route, $si:$sp will be the response source (Asterisk), not the original request source
            # We need to preserve the endpoint's public NAT IP:port to populate the 'received' field
            # Use transaction-scoped AVP (tu) to ensure it persists across transaction boundaries
            $avp(tu:reg_received) = $si + ":" + $sp;
            # Also set regular AVP as fallback
            $avp(reg_received) = $si + ":" + $sp;
            xlog("REGISTER: Captured original request source for received field: $avp(reg_received) (endpoint public NAT IP:port)\n");
            
            # Arm reply handler to save location only on successful registration (2xx)
            # This follows OpenSIPS proxy-registrar pattern: save AFTER successful reply
            # The save() function will use contact information from the 200 OK reply
            # (including any modifications from the main registrar) via mcontact_avp
            # If reply Contact is <null>, it will use $avp(mcontact) from the request
            t_on_reply("handle_reply_reg");
            
            xlog("REGISTER: Request from $si:$sp, To=$tU@$(tu{uri.domain}), Contact=$hdr(Contact), will save location on 2xx reply\n");
        }
    }

    route(DOMAIN_CHECK);
}

####### Domain validation / door-knocker protection ########

route[DOMAIN_CHECK] {

    # OpenSIPS: Request-URI domain is $rd (lowercase), not $rD
    $var(domain) = $rd;

    if ($var(domain) == "") {
        exit;
    }

    # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
    # This handles INVITE from Asterisk to endpoints (e.g., sip:402@192.168.1.232:5060)
    # Note: $rd might include port (e.g., 192.168.1.138:56931), so we check just the IP part
    # Extract just the IP address part (before any colon)
    $var(request_domain) = $rd;
    if ($var(request_domain) =~ "^([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
        $var(request_ip) = $re;
        xlog("INVITE Request-URI looks like endpoint: $rU@$var(request_domain), attempting endpoint lookup\n");
        
        # Extract username from Request-URI
        $var(endpoint_user) = $rU;
        
        # Determine domain from Asterisk source IP (CRITICAL for multi-tenant support)
        # This ensures we route to the correct customer when same extension numbers exist across domains
        route(GET_DOMAIN_FROM_SOURCE_IP);
        $var(original_ru) = $ru;
        
        if ($var(domain_detection_success) == 1) {
            # Domain found from source IP - use domain-specific lookup (CORRECT for multi-tenant)
            $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@" + $var(domain_from_source);
            xlog("INVITE: Determined domain from source IP $si: $var(domain_from_source), using domain-specific lookup: $var(lookup_uri)\n");
            
            # Set Request-URI and use lookup() function
            # CRITICAL: Set $ru to lookup_uri BEFORE calling lookup()
            # lookup() will update $ru with the contact if found
            $ru = $var(lookup_uri);
            # Save what we set $ru to, so we can detect if lookup() changed it
            $var(ru_before_lookup) = $ru;
            
            # lookup() sets $du automatically if contact found
            # NOTE: In OpenSIPS 3.6, if lookup() returns TRUE but $du is null,
            # it means $ru was updated with the registered contact (local contact, no outbound proxy)
            $var(lookup_success) = 0;
            $var(du_is_valid) = 0;
            $var(ru_is_valid) = 0;
            
            if (lookup("location")) {
                # Contact found - $du is set automatically by lookup(), OR $ru is updated with contact
                xlog("INVITE: lookup() returned TRUE - contact found\n");
                xlog("INVITE: After lookup() - $du=$du, $ru=$ru, ru_before_lookup=$var(ru_before_lookup)\n");
                $var(lookup_success) = 1;
                
                # Check if $du is set (outbound proxy case)
                if ($du != "" && $du != "<null>" && $du != "0" && $du =~ "^sip:") {
                    $var(du_is_valid) = 1;
                    xlog("INVITE: $du is valid - using outbound proxy destination\n");
                } else {
                    # $du is null - check if $ru was updated with contact (local contact case)
                    xlog("INVITE: $du is null - checking if $ru was updated by lookup()\n");
                    xlog("INVITE: $ru changed from $var(ru_before_lookup) to $ru\n");
                    
                    # Check if $ru was changed by lookup() (contains contact, not the lookup URI)
                    if ($ru != "" && $ru != $var(ru_before_lookup) && $ru =~ "^sip:") {
                        # Extract domain/IP from $ru to validate
                        $var(ru_domain) = $(ru{uri.domain});
                        if ($var(ru_domain) != "" && ($var(ru_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" || $var(ru_domain) !~ "^[0-9]")) {
                            $var(ru_is_valid) = 1;
                            # Set $du = $ru for routing (local contact, no outbound proxy)
                            $du = $ru;
                            xlog("INVITE: $ru is valid contact - using $ru as destination (local contact, no outbound proxy)\n");
                        } else {
                            xlog("INVITE: $ru domain is invalid: $var(ru_domain)\n");
                        }
                    } else {
                        xlog("INVITE: $ru was not updated by lookup() (still $var(ru_before_lookup)) - will use SQL fallback\n");
                    }
                }
            } else {
                # Restore original Request-URI
                $ru = $var(original_ru);
                xlog("INVITE: lookup() returned FALSE - no contact found for $var(lookup_uri)\n");
            }
            
            # If lookup() succeeded and either $du or $ru is valid, check for NAT traversal
            if ($var(lookup_success) == 1 && ($var(du_is_valid) == 1 || $var(ru_is_valid) == 1)) {
                # Check if destination contains private IP - if so, use received field for NAT traversal
                # Determine which URI to check (prefer $du if valid, otherwise $ru)
                if ($var(du_is_valid) == 1) {
                    $var(dest_domain) = $(du{uri.domain});
                } else {
                    $var(dest_domain) = $(ru{uri.domain});
                }
                
                # Check if destination domain is a private IP
                if ($var(dest_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                    $var(check_ip) = $var(dest_domain);
                    route(CHECK_PRIVATE_IP);
                    if ($var(is_private) == 1) {
                        # Destination is private IP - query for received field (NAT IP)
                        xlog("INVITE: Destination contains private IP $var(dest_domain), checking received field for NAT traversal\n");
                        $var(query) = "SELECT received FROM location WHERE username='" + $var(endpoint_user) + "' AND domain='" + $var(domain_from_source) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                        if (sql_query($var(query), "$avp(invite_received)") && $(avp(invite_received)[0]) != "" && $(avp(invite_received)[0]) != "<null>") {
                            # Extract IP:port from received field using SQL
                            $var(received_value) = $(avp(invite_received)[0]);
                            $var(nat_ip) = "";
                            $var(nat_port) = "";
                            
                            # Extract IP and port using SUBSTRING_INDEX
                            $var(query_ip) = "SELECT SUBSTRING_INDEX('" + $var(received_value) + "', ':', 1)";
                            if (sql_query($var(query_ip), "$avp(invite_nat_ip)")) {
                                $var(nat_ip) = $(avp(invite_nat_ip)[0]);
                            }
                            $var(query_port) = "SELECT SUBSTRING_INDEX('" + $var(received_value) + "', ':', -1)";
                            if (sql_query($var(query_port), "$avp(invite_nat_port)")) {
                                $var(nat_port) = $(avp(invite_nat_port)[0]);
                            }
                            
                            # Validate and update destination
                            if ($var(nat_ip) != "" && $var(nat_ip) != "<null>" && $var(nat_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" && $var(nat_port) != "" && $var(nat_port) != "<null>") {
                                $du = "sip:" + $var(endpoint_user) + "@" + $var(nat_ip) + ":" + $var(nat_port);
                                $ru = $du;
                                xlog("INVITE: Updated destination to NAT IP from received field: $du (was $var(dest_uri))\n");
                            } else {
                                xlog("L_WARN", "INVITE: Failed to extract valid IP:port from received field: [$var(received_value)]\n");
                            }
                        } else {
                            xlog("L_WARN", "INVITE: No received field found for NAT traversal, using original destination: $var(dest_uri)\n");
                        }
                    }
                }
                
                # Request-URI is already set to destination by lookup()
                xlog("Routing INVITE from $si to endpoint: dest=$du, Request-URI=$ru\n");
                route(RELAY);
                exit;
            }
            
            # If we get here, either lookup() returned FALSE or $du was empty/invalid
            # RACE CONDITION FIX: Try SQL fallback to check database directly (handles timing issues)
            xlog("INVITE: Trying SQL fallback for domain-specific lookup (race condition handling)\n");
            xlog("INVITE: SQL fallback query for user=$var(endpoint_user), domain=$var(domain_from_source)\n");
            # Use received field if available (NAT traversal), otherwise use contact field
            $var(query) = "SELECT COALESCE(received, contact) FROM location WHERE username='" + $var(endpoint_user) + "' AND domain='" + $var(domain_from_source) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
            if (sql_query($var(query), "$avp(invite_contact)")) {
                xlog("INVITE: SQL fallback query executed, result count check\n");
                if ($(avp(invite_contact)[0]) != "" && $(avp(invite_contact)[0]) != "<null>") {
                    # Extract IP:port from received or contact field using SQL (regex $re doesn't work)
                    $var(contact_value) = $(avp(invite_contact)[0]);
                    $var(extracted_ip) = "";
                    $var(extracted_port) = "";
                    
                    # Check if it's received field format (IP:port) or contact field format (sip:user@IP:port)
                    # received field format: 74.83.23.44:5060
                    if ($var(contact_value) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:") {
                        # received field - extract IP and port using SQL
                        $var(query_ip) = "SELECT SUBSTRING_INDEX('" + $var(contact_value) + "', ':', 1)";
                        if (sql_query($var(query_ip), "$avp(invite_ip)")) {
                            $var(extracted_ip) = $(avp(invite_ip)[0]);
                        }
                        $var(query_port) = "SELECT SUBSTRING_INDEX('" + $var(contact_value) + "', ':', -1)";
                        if (sql_query($var(query_port), "$avp(invite_port)")) {
                            $var(extracted_port) = $(avp(invite_port)[0]);
                        }
                    } else if ($var(contact_value) =~ "^sip:") {
                        # contact field format: sip:user@IP:port or sip:user@IP
                        # Extract everything after @ and before : (or end of string)
                        $var(query_at) = "SELECT SUBSTRING_INDEX('" + $var(contact_value) + "', '@', -1)";
                        if (sql_query($var(query_at), "$avp(invite_at_part)")) {
                            $var(at_part) = $(avp(invite_at_part)[0]);
                            # Extract IP (before colon if present)
                            $var(query_ip) = "SELECT SUBSTRING_INDEX('" + $var(at_part) + "', ':', 1)";
                            if (sql_query($var(query_ip), "$avp(invite_ip)")) {
                                $var(extracted_ip) = $(avp(invite_ip)[0]);
                            }
                            # Extract port (after colon if present)
                            if ($var(at_part) =~ ":") {
                                $var(query_port) = "SELECT SUBSTRING_INDEX('" + $var(at_part) + "', ':', -1)";
                                if (sql_query($var(query_port), "$avp(invite_port)")) {
                                    $var(extracted_port) = $(avp(invite_port)[0]);
                                }
                            } else {
                                $var(extracted_port) = "5060";
                            }
                        }
                    }
                    
                    # Validate and construct destination URI
                    if ($var(extracted_ip) != "" && $var(extracted_ip) != "<null>" && $var(extracted_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # Construct destination URI
                        if ($var(extracted_port) != "" && $var(extracted_port) != "<null>") {
                            $du = "sip:" + $var(endpoint_user) + "@" + $var(extracted_ip) + ":" + $var(extracted_port);
                        } else {
                            $du = "sip:" + $var(endpoint_user) + "@" + $var(extracted_ip) + ":5060";
                        }
                        $ru = $du;
                        xlog("INVITE: SQL fallback found contact: $du (race condition resolved)\n");
                        route(RELAY);
                        exit;
                    } else {
                        xlog("L_WARN", "INVITE: SQL fallback found contact value but extraction failed: [$var(contact_value)], extracted_ip=[$var(extracted_ip)], extracted_port=[$var(extracted_port)]\n");
                    }
                } else {
                    xlog("L_WARN", "INVITE: SQL fallback query returned no results for user=$var(endpoint_user), domain=$var(domain_from_source)\n");
                }
            } else {
                xlog("L_WARN", "INVITE: SQL fallback query failed for user=$var(endpoint_user), domain=$var(domain_from_source)\n");
            }
            
            # Domain-specific lookup failed
            $ru = $var(original_ru);
            xlog("L_WARN", "INVITE: Domain-specific lookup failed for $var(endpoint_user)@$var(domain_from_source) (source IP $si)\n");
        } else {
            # Domain not found - use SQL wildcard lookup as fallback (with warning)
            xlog("L_WARN", "INVITE: Could not determine domain from source IP $si, using wildcard lookup (may route to wrong customer in multi-tenant)\n");
            $var(query) = "SELECT contact FROM location WHERE username='" + $var(endpoint_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
            if (sql_query($var(query), "$avp(contact_uri)") && $(avp(contact_uri)[0]) != "") {
                $du = $(avp(contact_uri)[0]);
                $ru = $du;
                xlog("INVITE: SQL wildcard lookup found contact: $du for user $var(endpoint_user)\n");
                xlog("Routing INVITE from $si to endpoint: dest=$du, Request-URI=$ru\n");
                route(RELAY);
                exit;
            }
        }
        
        # If endpoint lookup failed, log and send 404
        $ru = $var(original_ru);
        xlog("L_WARN", "Endpoint lookup failed for $var(endpoint_user)@$rd - no matching endpoint found in location table\n");
        sl_send_reply(404, "Endpoint Not Found");
        exit;
    }

    # Optional extra hardening: domain consistency
    # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
    if ($rd != $(tu{uri.domain})) {
        xlog("L_WARN", "R-URI / To mismatch domain=$rd src=$si\n");
        exit;
    }

    # Lookup dispatcher set for this domain
    # Use domain.setid as the dispatcher setid (explicit mapping)
    $var(query) = "SELECT setid FROM domain WHERE domain='" + $var(domain) + "'";
    if (!sql_query($var(query), "$avp(domain_setid)")) {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (query failed)\n");
        exit;
    }
    
    # Check if domain was found
    if ($(avp(domain_setid)[0]) == "") {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (not found)\n");
        exit;
    }
    
    # Get the dispatcher_setid from query result (first row, first column)
    $var(setid) = $(avp(domain_setid)[0]);

    route(TO_DISPATCHER);
}

####### Health-aware routing ########

route[TO_DISPATCHER] {

    # Select a healthy Asterisk from the dispatcher set
    if (!ds_select_dst($var(setid), 4)) {
        xlog("L_ERR", "No healthy Asterisk nodes for domain=$rd setid=$var(setid)\n");
        sl_send_reply(503, "Service Unavailable");
        exit;
    }

    xlog("Routing to $du for domain=$rd setid=$var(setid) method=$rm Request-URI=$ru\n");

    record_route();

    # Arm failure route to handle transaction failures
    t_on_failure("1");

    # For initial INVITE requests (no To-tag), create dialog BEFORE t_relay()
    # This is required for proper dialog tracking and database persistence
    if (is_method("INVITE") && !has_totag()) {
        xlog("Initial INVITE detected, creating dialog for Call-ID=$hdr(Call-ID)\n");
        # Create dialog for database persistence (required for Prometheus/Grafana monitoring)
        # With db_mode=2, dialog will be cached in memory and written to database periodically
        # Must be called before t_relay() for proper dialog tracking
        if (!create_dialog()) {
            xlog("L_WARN", "create_dialog() failed for INVITE Call-ID=$hdr(Call-ID)\n");
        } else {
            xlog("Dialog created successfully for Call-ID=$hdr(Call-ID)\n");
        }
        # Set extra fields for billing: From and To SIP URIs
        # These will be stored in from_uri and to_uri columns in acc table
        $acc_extra(from_uri) = $fu;
        $acc_extra(to_uri) = $tu;
    }

    # OpenSIPS transaction handling for reliable INVITE transaction management
    if (!t_relay()) {
        xlog("L_ERR", "t_relay() failed for $du method=$rm Request-URI=$ru\n");
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
        exit;
    }

    xlog("t_relay() succeeded for $du method=$rm, transaction created\n");
    # For INVITE, enable CDR accounting after t_relay() succeeds
    if (is_method("INVITE") && !has_totag()) {
        # Enable CDR accounting for INVITE transactions (database backend)
        # do_accounting("db", "cdr") enables CDR mode which:
        # - Uses dialog tracking (requires dialog module loaded and create_dialog() called)
        # - Tracks dialog from INVITE to BYE
        # - Calculates duration automatically
        # - Populates created timestamp
        # - Correlates INVITE and BYE into single CDR
        # - Includes extra fields (from_uri, to_uri) for billing
        do_accounting("db", "cdr");
    }
    exit;
}

####### In-dialog handling ########

route[WITHINDLG] {
    xlog("In-dialog request: $rm from $si to $ru (Call-ID: $hdr(Call-ID), To-tag=$tt)\n");

    # Check for Record-Route header and follow it
    if (loose_route()) {
        xlog("loose_route() succeeded for $rm, following Record-Route, $du=$du, $ru=$ru\n");
        
        # For ACK and PRACK requests, validate destination URI after loose_route()
        # loose_route() may not set $du correctly, causing ACKs to not be forwarded
        if (is_method("ACK|PRACK")) {
            # If $du is empty or invalid, use Request-URI
            # ACK/PRACK should use Request-URI as fallback since they're in-dialog requests
            if ($du == "" || $du == "0") {
                $du = $ru;
                xlog("ACK/PRACK: loose_route() set empty destination, using Request-URI: $du\n");
            } else {
                # Validate $du is a valid SIP URI format
                if ($du !~ "^sip:") {
                    xlog("L_WARN", "ACK/PRACK: loose_route() set invalid destination format: $du, using Request-URI: $ru\n");
                    $du = $ru;
                } else {
                    xlog("ACK/PRACK: loose_route() set destination to: $du\n");
                }
            }
        }
        
        # For BYE requests, validate destination URI after loose_route()
        # loose_route() may set $du to a domain that can't be resolved, causing 476 errors
        if (is_method("BYE")) {
            # If $du is empty or appears invalid, try to extract from Request-URI
            if ($du == "" || $du == "0") {
                xlog("L_WARN", "BYE: loose_route() set empty destination, using Request-URI: $ru\n");
                $du = $ru;
            } else {
                # Log what loose_route() set as destination for debugging
                xlog("BYE: loose_route() set destination to: $du\n");
                
                # If $du contains a domain name (not IP), it might fail DNS resolution
                # Extract domain from $du to check if it's an IP address
                $var(dest_domain) = $(du{uri.domain});
                if ($var(dest_domain) != "" && $var(dest_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                    # Destination is a domain name, not an IP - might fail DNS
                    # For BYE, prefer using Request-URI if it has an IP address
                    $var(ru_domain) = $rd;
                    if ($var(ru_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        xlog("L_WARN", "BYE: loose_route() set domain destination ($du), but Request-URI has IP ($ru), using Request-URI\n");
                        $du = $ru;
                    } else {
                        # Both are domains - try to extract Contact header as fallback
                        if ($hdr(Contact) != "") {
                            # Extract Contact URI - might have IP address
                            $var(contact_uri) = $hdr(Contact);
                            # Remove angle brackets if present
                            if ($var(contact_uri) =~ "^<(.+)>$") {
                                $var(contact_uri) = $re;
                            }
                            # Extract domain from Contact
                            if ($var(contact_uri) =~ "@([^:;>]+)") {
                                $var(contact_domain) = $re;
                                if ($var(contact_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                                    # Contact has IP - construct destination from Contact
                                    $var(contact_user) = $rU;
                                    if ($var(contact_user) == "") {
                                        $var(contact_user) = $tU;
                                    }
                                    # Extract port from Contact if present
                                    $var(contact_port) = "";
                                    if ($var(contact_uri) =~ ":([0-9]+)[;>]") {
                                        $var(contact_port) = $re;
                                    }
                                    if ($var(contact_port) != "") {
                                        $du = "sip:" + $var(contact_user) + "@" + $var(contact_domain) + ":" + $var(contact_port);
                                    } else {
                                        $du = "sip:" + $var(contact_user) + "@" + $var(contact_domain) + ":5060";
                                    }
                                    xlog("BYE: Using Contact header IP for destination: $du\n");
                                }
                            }
                        }
                    }
                }
            }
        }
        
        route(RELAY);
        exit;
    }

    # If loose_route() fails, try to route based on transaction state
    # ACK, PRACK, and BYE need special handling - they're part of existing transactions
    if (is_method("ACK|PRACK|BYE")) {
        xlog("$rm request - loose_route() failed, checking transaction state\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("$rm matches existing transaction, relaying\n");
            # For ACKs and PRACKs, try t_relay() first (uses transaction state), fallback to RELAY route
            if (is_method("ACK|PRACK")) {
                if (!t_relay()) {
                    xlog("L_ERR", "t_relay() failed for $rm, trying stateless forward\n");
                    route(RELAY);
                }
            } else {
                # For BYE, use RELAY route directly
                route(RELAY);
            }
            exit;
        } else {
            xlog("L_WARN", "$rm received but no matching transaction found, trying to relay anyway\n");
            # Must be forwarded even without transaction match (stateless forwarding)
            # This ensures message reaches the destination even if transaction expired
            route(RELAY);
            exit;
        }
    }

    xlog("L_WARN", "In-dialog request $rm - loose_route() failed and no transaction match\n");
    sl_send_reply(404, "Not Here");
    exit;
}

####### Helper Routes ########

# Domain detection helper route (multi-tenant support)
# Determines domain from Asterisk source IP for proper multi-tenant routing
# 
# Input variables:
#   $si - Source IP (automatically available, no need to set)
#
# Output variables:
#   $var(domain_from_source) - Domain name if found (empty if not found)
#   $var(domain_detection_success) - 1 if domain found, 0 if not found
#
# Usage:
#   route(GET_DOMAIN_FROM_SOURCE_IP);
#   if ($var(domain_detection_success) == 1) {
#       # Use $var(domain_from_source) for domain-specific lookup
#   }
#
# Logic:
#   1. Query dispatcher table to find setid for source IP
#   2. Query domain table to find domain for that setid
#   3. Returns domain if found, empty if not found
route[GET_DOMAIN_FROM_SOURCE_IP] {
    $var(domain_from_source) = "";
    $var(domain_detection_success) = 0;
    
    # Step 1: Find dispatcher setid for this source IP
    # Dispatcher destinations are stored as "sip:IP:port" (e.g., "sip:10.0.1.10:5060")
    # We match the IP part using LIKE with proper delimiters to avoid substring matches
    # Match pattern: sip:IP: or sip:IP followed by end of string
    # This ensures we match the exact IP, not a substring (e.g., 10.0.1.10 vs 10.0.1.100)
    $var(query) = "SELECT setid FROM dispatcher WHERE destination LIKE 'sip:" + $si + ":%' OR destination LIKE 'sip:" + $si + "' LIMIT 1";
    if (!sql_query($var(query), "$avp(source_setid)")) {
        xlog("GET_DOMAIN_FROM_SOURCE_IP: Query failed for source IP $si\n");
        return;
    }
    
    $var(setid) = $(avp(source_setid)[0]);
    if ($var(setid) == "" || $var(setid) == "0") {
        xlog("GET_DOMAIN_FROM_SOURCE_IP: No dispatcher setid found for source IP $si\n");
        return;
    }
    
    # Step 2: Find domain for this setid
    $var(query) = "SELECT domain FROM domain WHERE setid='" + $var(setid) + "' LIMIT 1";
    if (!sql_query($var(query), "$avp(source_domain)")) {
        xlog("GET_DOMAIN_FROM_SOURCE_IP: Domain query failed for setid $var(setid)\n");
        return;
    }
    
    $var(domain_from_source) = $(avp(source_domain)[0]);
    if ($var(domain_from_source) != "") {
        $var(domain_detection_success) = 1;
        xlog("GET_DOMAIN_FROM_SOURCE_IP: Found domain $var(domain_from_source) for source IP $si (setid $var(setid))\n");
    } else {
        xlog("GET_DOMAIN_FROM_SOURCE_IP: No domain found for setid $var(setid) (source IP $si)\n");
    }
    
    return;
}

# Check if NAT fixes should be enabled
# Auto-detected by install script based on advertised_address
# If advertised_address is public IP, install script enables NAT fixes
# Output: $var(enable_nat_fixes) - 1 if NAT fixes should be enabled, 0 if not
route[CHECK_NAT_ENVIRONMENT] {
    $var(enable_nat_fixes) = 0;
    
    # Runtime detection: Check if endpoints are sending private IPs (indicates NAT environment)
    # This works for both LAN and NAT environments
    # If we receive requests with private IPs from endpoints (not Asterisk), enable NAT fixes
    route(CHECK_IS_FROM_ASTERISK);
    if ($var(is_from_asterisk) == 0) {
        # Use nat_uac_test() for comprehensive NAT detection
        # Flag 19 = 1 (Contact) + 2 (received mismatch) + 16 (port mismatch)
        # This detects NAT more reliably than just checking source IP
        if (nat_uac_test("19")) {
            # Endpoint is behind NAT - enable NAT fixes for this request
            $var(enable_nat_fixes) = 1;
            xlog("NAT environment detected via nat_uac_test(): endpoint is behind NAT, enabling NAT fixes\n");
        } else {
            # Fallback: Check source IP manually (for cases where nat_uac_test() doesn't detect it)
            $var(check_ip) = $si;
            route(CHECK_PRIVATE_IP);
            if ($var(is_private) == 1) {
                $var(enable_nat_fixes) = 1;
                xlog("NAT environment detected via source IP check: endpoint $si is behind NAT, enabling NAT fixes\n");
            }
        }
    }
    
    return;
}

# Check if source IP is from Asterisk (dispatcher destination)
# Input: $si - Source IP (automatically available)
# Output: $var(is_from_asterisk) - 1 if from Asterisk, 0 if not
# Uses dispatcher table to determine if source IP matches any dispatcher destination
route[CHECK_IS_FROM_ASTERISK] {
    $var(is_from_asterisk) = 0;
    $var(query) = "SELECT COUNT(*) FROM dispatcher WHERE destination LIKE 'sip:" + $si + ":%' OR destination LIKE 'sip:" + $si + "' LIMIT 1";
    if (sql_query($var(query), "$avp(dispatcher_match)")) {
        if ($(avp(dispatcher_match)[0]) != "" && $(avp(dispatcher_match)[0]) != "0") {
            $var(is_from_asterisk) = 1;
        }
    }
    return;
}

# Check if IP address is private (RFC 1918)
# Input: $var(check_ip) - IP address to check
# Output: $var(is_private) - 1 if private, 0 if public
# Covers all RFC 1918 private IP ranges:
#   Class A: 10.0.0.0 - 10.255.255.255
#   Class B: 172.16.0.0 - 172.31.255.255
#   Class C: 192.168.0.0 - 192.168.255.255
route[CHECK_PRIVATE_IP] {
    $var(is_private) = 0;
    # Class C: 192.168.0.0 - 192.168.255.255
    if ($var(check_ip) =~ "^192\\.168\\.") {
        $var(is_private) = 1;
    # Class A: 10.0.0.0 - 10.255.255.255
    } else if ($var(check_ip) =~ "^10\\.") {
        $var(is_private) = 1;
    # Class B: 172.16.0.0 - 172.31.255.255
    # 172.16-19
    } else if ($var(check_ip) =~ "^172\\.1[6-9]\\.") {
        $var(is_private) = 1;
    # 172.20-29
    } else if ($var(check_ip) =~ "^172\\.2[0-9]\\.") {
        $var(is_private) = 1;
    # 172.30-31
    } else if ($var(check_ip) =~ "^172\\.3[01]\\.") {
        $var(is_private) = 1;
    }
    return;
}

route[RELAY] {
    # Add Record-Route for INVITE requests so ACKs can follow the same path
    # This is critical for ACK handling when routing from Asterisk to endpoints
    if (is_method("INVITE")) {
        record_route();
        xlog("RELAY: Added Record-Route for INVITE to $du, Call-ID=$hdr(Call-ID)\n");
        
        # Fix NAT in SDP for INVITE requests from endpoints behind NAT
        # This is CRITICAL for RTP to work - fixes private IPs in SDP to public NAT IPs
        # Must be done BEFORE forwarding to Asterisk so Asterisk receives correct IP for RTP
        # Auto-detected: NAT fixes enabled automatically if endpoints are behind NAT
        if ($hdr(Content-Type) =~ "application/sdp") {
            route(CHECK_NAT_ENVIRONMENT);
            if ($var(enable_nat_fixes) == 1) {
                fix_nated_sdp("rewrite-media-ip");
                xlog("RELAY: Fixed NAT in SDP for INVITE from $si to $du, Call-ID=$hdr(Call-ID)\n");
            }
        }
        
        # For initial INVITE requests (no To-tag), create dialog BEFORE t_relay()
        # This is required for proper dialog tracking and database persistence
        if (!has_totag()) {
            xlog("RELAY: Initial INVITE detected, creating dialog for Call-ID=$hdr(Call-ID)\n");
            # Create dialog for database persistence (required for Prometheus/Grafana monitoring)
            # With db_mode=2, dialog will be cached in memory and written to database periodically
            # Must be called before t_relay() for proper dialog tracking
            if (!create_dialog()) {
                xlog("L_WARN", "RELAY: create_dialog() failed for INVITE Call-ID=$hdr(Call-ID)\n");
            } else {
                xlog("RELAY: Dialog created successfully for Call-ID=$hdr(Call-ID)\n");
            }
            # Set extra fields for billing: From and To SIP URIs
            # These will be stored in from_uri and to_uri columns in acc table
            $acc_extra(from_uri) = $fu;
            $acc_extra(to_uri) = $tu;
        }
    }
    
    # For ACKs, PRACKs, BYEs, NOTIFYs, and OPTIONS, fix destination URI to use NAT IP from endpoint database
    # Only applies if Request-URI contains private IP (endpoint behind NAT)
    # ACK/PRACK: Only if Request-URI has username (ACKs to Asterisk have no username)
    # BYE/NOTIFY/OPTIONS: Always check if private IP
    if (is_method("ACK|PRACK|BYE|NOTIFY|OPTIONS")) {
        # Note: With CDR mode enabled on INVITE, we don't need do_accounting() for BYE
        # The acc module with dialog module will automatically:
        # - Track dialog state for ACK, BYE, etc.
        # - Correlate BYE with the INVITE and update the CDR
        # - Calculate duration and termination information
        
        $var(needs_nat_fix) = 0;
        
        # For ACK/PRACK, require username in Request-URI (ACKs to Asterisk have no username)
        # Check if Request-URI contains private IP - if so, apply NAT traversal regardless of source
        # This is needed because ACKs from Asterisk may use Contact header from 200 OK which has private IP
        if (is_method("ACK|PRACK")) {
            # Check if Request-URI has username and contains private IP
            if ($ru =~ "^sip:[^@]+@") {
                $var(check_ip) = $rd;
                route(CHECK_PRIVATE_IP);
                # Apply NAT traversal if Request-URI contains private IP (regardless of source)
                if ($var(is_private) == 1) {
                    $var(needs_nat_fix) = 1;
                    xlog("RELAY: $rm - Request-URI contains private IP $rd, applying NAT traversal\n");
                } else {
                    # Request-URI has public IP - no NAT traversal needed
                    $var(needs_nat_fix) = 0;
                }
            } else {
                # No username in Request-URI (ACK to Asterisk) - no NAT traversal needed
                $var(needs_nat_fix) = 0;
            }
        } else {
            # BYE/NOTIFY/OPTIONS: always check
            $var(needs_nat_fix) = 1;
        }
        
        if ($var(needs_nat_fix) == 1) {
            $var(check_ip) = $rd;
            route(CHECK_PRIVATE_IP);
            
            if ($var(is_private) == 1 && $rU != "") {
                # Use location table for NAT handling (migrated from endpoint_locations)
                # Extract username and domain from Request-URI
                $var(nat_lookup_user) = $rU;
                $var(nat_lookup_domain) = $rd;
                
                # Check if domain is an IP address (not a domain name)
                if ($var(nat_lookup_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                    # Domain is IP - try to determine domain from source IP
                    route(GET_DOMAIN_FROM_SOURCE_IP);
                    if ($var(domain_detection_success) == 1) {
                        $var(nat_lookup_domain) = $var(domain_from_source);
                    }
                }
                
                # Query location table for contact information
                # First try received field (NAT traversal), then fallback to contact field
                $var(nat_contact_found) = 0;
                
                if ($var(nat_lookup_domain) != "" && $var(nat_lookup_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                    # Domain-specific lookup (preferred for multi-tenant)
                    $var(query) = "SELECT received FROM location WHERE username='" + $var(nat_lookup_user) + "' AND domain='" + $var(nat_lookup_domain) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                } else {
                    # Fallback: username-only lookup (wildcard)
                    $var(query) = "SELECT received FROM location WHERE username='" + $var(nat_lookup_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                }
                
                # Try received field first (NAT traversal)
                if (sql_query($var(query), "$avp(nat_received)") && $(avp(nat_received)[0]) != "") {
                    # received field contains IP:port from NAT traversal (e.g., 74.83.23.44:5060)
                    # Extract IP and port using regex - OpenSIPS requires separate matches for IP and port
                    $var(nat_ip) = "";
                    $var(nat_port) = "";
                    $var(received_value) = $(avp(nat_received)[0]);
                    xlog("RELAY: $rm - DEBUG - Extracting from received field: [$var(received_value)]\n");
                    
                    # Use SQL SUBSTRING_INDEX directly (POSIX regex $re doesn't populate capturing groups reliably)
                    # Format is always IP:port (e.g., 74.83.23.44:5060)
                    # SUBSTRING_INDEX(string, delimiter, count):
                    #   count > 0: returns substring before the Nth occurrence of delimiter
                    #   count < 0: returns substring after the Nth occurrence from the end
                    $var(nat_ip) = "";
                    $var(nat_port) = "";
                    
                    # Extract IP part (everything before first colon)
                    $var(query_ip) = "SELECT SUBSTRING_INDEX('" + $var(received_value) + "', ':', 1)";
                    if (sql_query($var(query_ip), "$avp(nat_ip_extracted)")) {
                        $var(nat_ip) = $(avp(nat_ip_extracted)[0]);
                        xlog("RELAY: $rm - DEBUG - SQL extracted IP: [$var(nat_ip)]\n");
                    } else {
                        xlog("L_WARN", "RELAY: $rm - DEBUG - SQL IP extraction query failed for: [$var(received_value)]\n");
                    }
                    
                    # Extract port part (everything after last colon)
                    $var(query_port) = "SELECT SUBSTRING_INDEX('" + $var(received_value) + "', ':', -1)";
                    if (sql_query($var(query_port), "$avp(nat_port_extracted)")) {
                        $var(nat_port) = $(avp(nat_port_extracted)[0]);
                        xlog("RELAY: $rm - DEBUG - SQL extracted port: [$var(nat_port)]\n");
                    } else {
                        xlog("L_WARN", "RELAY: $rm - DEBUG - SQL port extraction query failed for: [$var(received_value)]\n");
                    }
                    
                    xlog("RELAY: $rm - DEBUG - Final extraction result: IP=[$var(nat_ip)], Port=[$var(nat_port)]\n");
                    
                    # Only set $du if we successfully extracted both IP and port
                    if ($var(nat_ip) != "" && $var(nat_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" && $var(nat_port) != "" && $var(nat_port) =~ "^[0-9]+$") {
                        $du = "sip:" + $rU + "@" + $var(nat_ip) + ":" + $var(nat_port);
                        xlog("RELAY: $rm - Updated destination to NAT IP from received field: $du (was $ru)\n");
                        $var(nat_contact_found) = 1;
                    } else {
                        xlog("L_WARN", "RELAY: $rm - Failed to extract valid IP:port from received field: [$var(received_value)], nat_ip=[$var(nat_ip)], nat_port=[$var(nat_port)]\n");
                    }
                }
                
                # Fallback to contact field if received not available
                if ($var(nat_contact_found) == 0) {
                    if ($var(nat_lookup_domain) != "" && $var(nat_lookup_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        $var(query) = "SELECT contact FROM location WHERE username='" + $var(nat_lookup_user) + "' AND domain='" + $var(nat_lookup_domain) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                    } else {
                        $var(query) = "SELECT contact FROM location WHERE username='" + $var(nat_lookup_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                    }
                    
                    if (sql_query($var(query), "$avp(nat_contact)") && $(avp(nat_contact)[0]) != "") {
                        # Extract IP:port from contact field
                        $var(contact_uri) = $(avp(nat_contact)[0]);
                        # Contact format: sip:user@ip:port or <sip:user@ip:port>
                        $var(nat_ip) = "";
                        $var(nat_port) = "";
                        
                        # Try pattern with port first: sip:user@ip:port
                        if ($var(contact_uri) =~ "@([^:>]+):([0-9]+)") {
                            $var(nat_ip) = $re;
                            # Extract port separately (OpenSIPS regex limitation)
                            if ($var(contact_uri) =~ "@[^:>]+:([0-9]+)") {
                                $var(nat_port) = $re;
                            }
                        }
                        # Fallback to pattern without port: sip:user@ip
                        if ($var(nat_ip) == "" && $var(contact_uri) =~ "@([^:>]+)") {
                            $var(nat_ip) = $re;
                        }
                        
                        # Validate extracted IP and set destination URI
                        if ($var(nat_ip) != "" && $var(nat_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                            if ($var(nat_port) != "") {
                                $du = "sip:" + $rU + "@" + $var(nat_ip) + ":" + $var(nat_port);
                                xlog("RELAY: $rm - Updated destination to NAT IP from contact: $du (was $ru)\n");
                            } else {
                                $du = "sip:" + $rU + "@" + $var(nat_ip) + ":5060";
                                xlog("RELAY: $rm - Updated destination to NAT IP from contact (default port): $du (was $ru)\n");
                            }
                            $var(nat_contact_found) = 1;
                        } else {
                            xlog("L_WARN", "RELAY: $rm - Invalid IP extracted from contact: $var(nat_ip), keeping original $du\n");
                        }
                    }
                }
            }
        }
    }
    
    # Arm failure route to handle transaction failures
    t_on_failure("1");
    
    # For non-INVITE requests (like NOTIFY), ensure transaction is created properly
    if (is_method("NOTIFY|OPTIONS")) {
        xlog("RELAY: Creating transaction for $rm to $du, Call-ID=$hdr(Call-ID)\n");
    }
    
    # For ACK and PRACK requests, ensure proper transaction-based routing
    # ACK/PRACK should use transaction state when available, but need fallback if transaction expired
    # This prevents retransmission loops where ACKs aren't properly forwarded
    if (is_method("ACK|PRACK")) {
        # PRACKs can contain SDP for early media - preserve SDP as-is, do NOT modify
        # ACKs typically don't have SDP, but if they do, preserve it as-is
        if ($hdr(Content-Type) =~ "application/sdp") {
            xlog("RELAY: $rm with SDP from $si to $du - preserving SDP as-is (no modification)\n");
            # Do NOT call fix_nated_sdp() - SDP in ACK/PRACK should be preserved exactly as received
        }
        
        # Validate destination URI (WITHINDLG already validated, but double-check for safety)
        if ($du == "" || $du == "0" || $du !~ "^sip:") {
            $du = $ru;
            xlog("RELAY: $rm - Set destination URI from Request-URI: $du (was empty/invalid)\n");
        }
        
        xlog("RELAY: $rm - Attempting to relay to $du (Request-URI=$ru, Route=$hdr(Route), From=$si)\n");
        
        # For ACKs from Asterisk, we MUST forward them even if transaction doesn't match
        # ACKs from Asterisk may not match the original INVITE transaction (created from endpoint)
        # So we use stateless forward() which doesn't require transaction matching
        # This is critical to prevent retransmission loops where Yealink never receives ACK
        route(CHECK_IS_FROM_ASTERISK);
        if ($var(is_from_asterisk) == 1) {
            # ACK is from Asterisk - use stateless forward to ensure it reaches endpoint
            xlog("RELAY: $rm from Asterisk - using stateless forward to ensure delivery to $du\n");
            if (!forward()) {
                xlog("L_ERR", "RELAY: $rm from Asterisk - forward() failed for destination $du\n");
                exit;
            } else {
                xlog("RELAY: $rm from Asterisk - stateless forward succeeded to $du\n");
            }
        } else {
            # ACK is from endpoint - try transaction-based relay first
            # Try t_relay() first - it will use transaction state if available
            # ACK/PRACK should work with transaction state since they're part of the INVITE transaction
            if (!t_relay()) {
                # t_relay() failed - transaction might not exist or expired
                # For ACK/PRACK, this is unusual but can happen if transaction expired
                xlog("L_WARN", "RELAY: $rm - t_relay() failed for destination $du (transaction not found?), trying stateless forward\n");
                
                # Try stateless forward as fallback
                # This ensures ACK/PRACK reaches destination even if transaction expired
                if (!forward()) {
                    xlog("L_ERR", "RELAY: $rm - forward() also failed for destination $du\n");
                    # For ACK, we can't send an error response (ACK has no response)
                    # For PRACK, we could send an error, but it's better to just log and exit
                    exit;
                } else {
                    xlog("RELAY: $rm - Stateless forward succeeded to $du\n");
                }
            } else {
                xlog("RELAY: $rm - t_relay() succeeded (transaction found)\n");
            }
        }
        # CRITICAL: Exit after ACK/PRACK handling to prevent further processing
        # ACK/PRACK must be forwarded immediately and not processed further
        exit;
    } else if (is_method("BYE")) {
        # Validate destination URI - prefer Request-URI if $du is invalid or domain (not IP)
        if ($du == "" || $du == "0" || $du !~ "^sip:") {
            $du = $ru;
        } else {
            $var(dest_domain) = $(du{uri.domain});
            if ($var(dest_domain) != "" && $var(dest_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" && $rd =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                $du = $ru;  # Prefer Request-URI IP over domain to avoid DNS issues
            }
        }
        
        # Try t_relay() first, fallback to stateless forward if transaction expired
        if (!t_relay() && !forward()) {
            sl_send_reply(500, "Internal Server Error");
            exit;
        }
    } else {
        # For other methods (including INVITE), use standard t_relay()
        if (!t_relay()) {
            # Use sl_send_reply() since we're in request route, not reply route
            sl_send_reply(500, "Internal Server Error");
        } else {
            if (is_method("NOTIFY|OPTIONS")) {
                xlog("RELAY: Transaction created successfully for $rm, Call-ID=$hdr(Call-ID)\n");
            }
            # For initial INVITE, enable CDR accounting after t_relay() succeeds
            if (is_method("INVITE") && !has_totag()) {
                # Enable CDR accounting for INVITE transactions (database backend)
                # do_accounting("db", "cdr") enables CDR mode which:
                # - Uses dialog tracking (requires dialog module loaded and create_dialog() called)
                # - Tracks dialog from INVITE to BYE
                # - Calculates duration automatically
                # - Populates created timestamp
                # - Correlates INVITE and BYE into single CDR
                # - Includes extra fields (from_uri, to_uri) for billing
                do_accounting("db", "cdr");
            }
        }
    }
    exit;
}
    
####### Response handling (for debugging) ########

onreply_route {
    xlog("Response received: $rs $rr from $si (method=$rm, CSeq=$hdr(CSeq), To-tag=$tt, Contact=$hdr(Contact), Call-ID=$hdr(Call-ID))\n");
    
    # Check if response is from Asterisk (dispatcher destination) vs endpoint
    # We should only fix NAT in responses FROM endpoints, not FROM Asterisk
    # Asterisk's SDP is correct as-is and should not be modified
    route(CHECK_IS_FROM_ASTERISK);
    if ($var(is_from_asterisk) == 1) {
        xlog("Response from Asterisk (dispatcher destination) at $si - skipping NAT fixes\n");
    }
    
    # Fix NAT in Contact headers and SDP for responses from endpoints behind NAT
    # This is critical for RTP to work correctly - fixes private IPs to public NAT IPs
    # fix_nated_contact() fixes Contact headers in responses
    # fix_nated_sdp() with "rewrite-media-ip" flag rewrites the media IP address (c= line) in SDP
    # This ensures Asterisk receives the public NAT IP instead of private IP for RTP
    # CRITICAL: Do NOT fix Contact header for REGISTER responses - the Contact header contains
    # the endpoint's contact information from Asterisk, and we must preserve it for save() to work
    # CRITICAL: Do NOT fix SDP in responses FROM Asterisk - Asterisk's SDP is correct and should not be modified
    # Auto-detected: NAT fixes enabled automatically if endpoints are behind NAT
    if ($var(is_from_asterisk) == 0) {
        # Response is from endpoint - fix Contact header if it contains private IP
        # This is critical for ACK routing - ACK uses Contact header from 200 OK response
        # Use nat_uac_test() to detect NAT in Contact header (flag 1 = check Contact header)
        if (!is_method("REGISTER") && $hdr(Contact) != "" && nat_uac_test("1")) {
            # NAT detected in Contact header - extract IP for logging
            if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                $var(contact_ip) = $re;
            } else {
                $var(contact_ip) = "unknown";
            }
            
            xlog("Contact header NAT detected via nat_uac_test(): IP=$var(contact_ip), fixing to use NAT IP from location table\n");
            
            # Contact header contains private IP - fix it using received field from location table
            # Extract username from Contact header (format: sip:user@ip:port or <sip:user@ip:port>)
            $var(contact_user) = "";
            if ($hdr(Contact) =~ "sip:([^@]+)@") {
                $var(contact_user) = $re;
            }
            
            if ($var(contact_user) != "") {
                # Query location table for received field (NAT IP)
                $var(query) = "SELECT received FROM location WHERE username='" + $var(contact_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                if (sql_query($var(query), "$avp(contact_received)")) {
                    if ($(avp(contact_received)[0]) != "" && $(avp(contact_received)[0]) != "<null>") {
                        # Extract IP:port from received field
                        $var(received_value) = $(avp(contact_received)[0]);
                        $var(nat_ip) = "";
                        $var(nat_port) = "";
                        
                        # Extract IP and port using SQL SUBSTRING_INDEX
                        $var(query_ip) = "SELECT SUBSTRING_INDEX('" + $var(received_value) + "', ':', 1)";
                        if (sql_query($var(query_ip), "$avp(contact_nat_ip)")) {
                            $var(nat_ip) = $(avp(contact_nat_ip)[0]);
                        }
                        $var(query_port) = "SELECT SUBSTRING_INDEX('" + $var(received_value) + "', ':', -1)";
                        if (sql_query($var(query_port), "$avp(contact_nat_port)")) {
                            $var(nat_port) = $(avp(contact_nat_port)[0]);
                        }
                        
                        # Validate and construct new Contact header
                        if ($var(nat_ip) != "" && $var(nat_ip) != "<null>" && $var(nat_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" && $var(nat_port) != "" && $var(nat_port) != "<null>") {
                            # Reconstruct Contact header with NAT IP:port
                            # Extract any parameters from original Contact header (after semicolon)
                            $var(contact_params) = "";
                            if ($hdr(Contact) =~ ";([^>]+)") {
                                $var(contact_params) = ";" + $re;
                            }
                            
                            # Check for angle brackets in original (format: <sip:user@ip:port> or <sip:user@ip:port;params>)
                            $var(has_brackets) = 0;
                            if ($hdr(Contact) =~ "^<") {
                                $var(has_brackets) = 1;
                            }
                            
                            # Construct new Contact header
                            if ($var(has_brackets) == 1) {
                                $var(new_contact) = "<sip:" + $var(contact_user) + "@" + $var(nat_ip) + ":" + $var(nat_port) + $var(contact_params) + ">";
                            } else {
                                $var(new_contact) = "sip:" + $var(contact_user) + "@" + $var(nat_ip) + ":" + $var(nat_port) + $var(contact_params);
                            }
                            
                            # Update Contact header - remove old and append new
                            # In OpenSIPS, cannot directly assign to $hdr() in onreply_route
                            # Construct full Contact header line with \r\n (required by append_hf)
                            $var(contact_header) = "Contact: " + $var(new_contact) + "\r\n";
                            remove_hf("Contact");
                            append_hf($var(contact_header));
                            xlog("Fixed Contact header in response $rs: replaced private IP $var(contact_ip) with NAT IP $var(nat_ip):$var(nat_port), new Contact=$var(new_contact)\n");
                        }
                    }
                }
            }
        }
            
        # Fix NAT in Contact headers and SDP for responses from endpoints behind NAT
        # This is critical for RTP to work correctly - fixes private IPs to public NAT IPs
        route(CHECK_NAT_ENVIRONMENT);
        if ($var(enable_nat_fixes) == 1) {
            if (!is_method("REGISTER")) {
                # fix_nated_contact() may not work correctly, so we manually fixed it above
                # But call it anyway as a fallback
                fix_nated_contact();
            }
            if ($hdr(Content-Type) =~ "application/sdp") {
                fix_nated_sdp("rewrite-media-ip");
                xlog("Fixed NAT in SDP for response $rs from endpoint $si\n");
            }
        } else {
            xlog("Response from endpoint $si - NAT fixes not needed (LAN-only deployment)\n");
        }
    } else {
        # Response is from Asterisk - do NOT fix SDP, just log
        if ($hdr(Content-Type) =~ "application/sdp") {
            xlog("Response with SDP from Asterisk $si - preserving SDP as-is (no NAT fix)\n");
        }
    }
    
    # Log OPTIONS/NOTIFY responses specifically
    if (is_method("OPTIONS|NOTIFY")) {
        xlog("OPTIONS/NOTIFY response: $rs $rr from $si, Call-ID=$hdr(Call-ID), Via=$hdr(Via), forwarding to Asterisk\n");
        # In onreply_route, transaction should already exist if we're here
        # If we get a 476 error, it means the response didn't match any transaction
        # This could be due to Via branch mismatch or transaction timeout
    }
    
    # Detailed SDP logging for 200 OK responses
    # This helps diagnose why one direction works and the other doesn't
    if ($rs == 200 && $hdr(Content-Type) =~ "application/sdp") {
        # Extract username from To header to identify the callee
        $var(to_user) = $(tu{uri.user});
        $var(from_user) = $(fu{uri.user});
        
        xlog("200 OK with SDP: From=$var(from_user), To=$var(to_user), Source=$si\n");
        
        # Diagnostic logging: Check endpoint IPs for SDP troubleshooting
        # This helps diagnose RTP issues regardless of whether call is from Asterisk or endpoint
        # Updated to use location table (migrated from endpoint_locations)
        if ($var(to_user) != "") {
            # Look up endpoint contact from location table for the callee (To header)
            # Use received field if available (NAT), otherwise extract from contact field
            $var(query) = "SELECT received FROM location WHERE username='" + $var(to_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
            if (sql_query($var(query), "$avp(endpoint_received)")) {
                if ($(avp(endpoint_received)[0]) != "") {
                    # received field contains IP:port
                    if ($(avp(endpoint_received)[0]) =~ "^([^:]+)") {
                        $var(endpoint_ip) = $re;
                        xlog("Callee endpoint IP from location table (received): $var(endpoint_ip) (user=$var(to_user))\n");
                    }
                } else {
                    # Fallback to contact field
                    $var(query) = "SELECT contact FROM location WHERE username='" + $var(to_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                    if (sql_query($var(query), "$avp(endpoint_contact)")) {
                        if ($(avp(endpoint_contact)[0]) != "") {
                            $var(contact_uri) = $(avp(endpoint_contact)[0]);
                            # Extract IP from contact: sip:user@ip:port
                            if ($var(contact_uri) =~ "@([^:>]+)") {
                                $var(endpoint_ip) = $re;
                                xlog("Callee endpoint IP from location table (contact): $var(endpoint_ip) (user=$var(to_user))\n");
                            }
                        }
                    }
                }
            }
        }
        
        # Also check the caller's endpoint IP
        if ($var(from_user) != "") {
            $var(query) = "SELECT received FROM location WHERE username='" + $var(from_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
            if (sql_query($var(query), "$avp(caller_received)")) {
                if ($(avp(caller_received)[0]) != "") {
                    # received field contains IP:port
                    if ($(avp(caller_received)[0]) =~ "^([^:]+)") {
                        $var(caller_ip) = $re;
                        xlog("Caller endpoint IP from location table (received): $var(caller_ip) (user=$var(from_user))\n");
                    }
                } else {
                    # Fallback to contact field
                    $var(query) = "SELECT contact FROM location WHERE username='" + $var(from_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                    if (sql_query($var(query), "$avp(caller_contact)")) {
                        if ($(avp(caller_contact)[0]) != "") {
                            $var(contact_uri) = $(avp(caller_contact)[0]);
                            # Extract IP from contact: sip:user@ip:port
                            if ($var(contact_uri) =~ "@([^:>]+)") {
                                $var(caller_ip) = $re;
                                xlog("Caller endpoint IP from location table (contact): $var(caller_ip) (user=$var(from_user))\n");
                            }
                        }
                    }
                }
            }
        }
    }
    
    # Log transaction state for debugging
    if ($rs >= 100 && $rs < 200) {
        xlog("Provisional response $rs received, transaction should remain active\n");
        # For provisional responses, explicitly exit to let transaction module handle forwarding
        # The transaction module will automatically forward and keep transaction alive
        exit;
    } else if ($rs >= 200 && $rs < 300) {
        xlog("Final success response $rs received\n");
        exit;
    } else if ($rs >= 300) {
        xlog("Final error response $rs received\n");
        exit;
    }
    # If we get here, exit to let transaction module handle it
    exit;
}

# --- REGISTER reply handler (usrloc migration) ---
# This handler saves endpoint locations only on successful registration (2xx)
# Follows OpenSIPS proxy-registrar pattern: save AFTER successful reply, not before
# The save() function uses contact information from the 200 OK reply (via mcontact_avp)
# which includes any modifications made by the main registrar (e.g., expiration changes)
onreply_route[handle_reply_reg] {
    if (is_method("REGISTER")) {
        # Only save location on successful registration (2xx response)
        if (t_check_status("2[0-9][0-9]")) {
            # DIAGNOSTIC: Log all relevant values before calling save()
            xlog("REGISTER: === DIAGNOSTIC INFO BEFORE save() ===\n");
            xlog("REGISTER: Response: $rs $rr\n");
            xlog("REGISTER: To URI: $tu\n");
            xlog("REGISTER: To User: $tU\n");
            xlog("REGISTER: To Domain: $(tu{uri.domain})\n");
            xlog("REGISTER: Reply Contact header: [$hdr(Contact)]\n");
            xlog("REGISTER: Reply Expires header: [$hdr(Expires)]\n");
            xlog("REGISTER: Request Contact (stored for diagnostics): [$avp(reg_contact)]\n");
            xlog("REGISTER: Modified Contact AVP (from registrar module): [$avp(mcontact)]\n");
            xlog("REGISTER: Source IP:Port: $si:$sp\n");
            xlog("REGISTER: Call-ID: $hdr(Call-ID)\n");
            
            # Check if Contact is actually null/empty
            # CRITICAL: save() extracts contact from the REPLY, not the request
            # If reply Contact is <null>, save() cannot work - this is a limitation of proxy-registrar mode
            if ($hdr(Contact) == "") {
                xlog("REGISTER: ERROR: Reply Contact header is empty/null - save() cannot extract contact info!\n");
                xlog("REGISTER: save() requires Contact header in the 200 OK reply to work\n");
                xlog("REGISTER: This registration will NOT be saved to location table\n");
                # Don't call save() if reply Contact is missing - it will fail silently
                exit;
            }
            
            # save("location") saves contact to location table using usrloc module
            # For proxy-registrar mode, save() extracts contact details from the 200 OK REPLY (not the request)
            # Since we're in onreply_route, save() won't generate a reply (transaction already handling it)
            # - Contact header from the 200 OK reply (must be present - if <null>, save() cannot work)
            # - AOR from $tu (To URI) - automatically extracted
            # - Expiration from Expires header or Contact expires parameter in reply
            # - Source IP/port from original request (preserved by transaction)
            # - Domain separation (username@domain as key) - from $tu
            # Returns true on success, false on failure
            # NOTE: If reply Contact is <null>, save() cannot extract contact info and will fail silently
            
            # CRITICAL: Ensure save() can populate 'received' field correctly
            # save() should automatically populate 'received' from the transaction's original request source
            # However, in proxy-registrar mode, the transaction source in onreply_route might be the response source
            # We extract the original request source from Via header to verify it's available
            # The registrar module's save() function should use this automatically if the transaction preserves it
            $var(original_source) = "";
            if ($(hdr(Via)[1]{via.received}) != "" && $(hdr(Via)[1]{via.received}) != "<null>") {
                $var(via_port) = "5060";
                if ($(hdr(Via)[1]{via.rport}) != "" && $(hdr(Via)[1]{via.rport}) != "<null>") {
                    $var(via_port) = $(hdr(Via)[1]{via.rport});
                }
                $var(original_source) = $(hdr(Via)[1]{via.received}) + ":" + $var(via_port);
                xlog("REGISTER: DEBUG - Original request source from Via: $var(original_source)\n");
                xlog("REGISTER: Note: save() should use transaction's original request source to populate 'received' field\n");
            }
            
            xlog("REGISTER: Calling save(\"location\")...\n");
            
            if (save("location")) {
                $var(endpoint_aor) = $tU + "@" + $(tu{uri.domain});
                xlog("REGISTER: save(\"location\") returned TRUE for $var(endpoint_aor) (response $rs $rr)\n");
                xlog("REGISTER: Note: With db_mode=1 (write-through), save() writes to DB immediately\n");
                
                # CRITICAL FIX: Manually populate 'received' field for NAT traversal
                # save() should populate 'received' automatically, but it doesn't always work in proxy-registrar mode
                # We captured the original request source IP:port in $avp(reg_received) before forwarding
                # However, AVPs don't always persist to onreply_route, so we need a fallback approach
                
                # Try to get the value from AVP first (preferred method)
                # Check transaction-scoped AVP first (tu:), then regular AVP
                # Transaction-scoped AVPs persist across transaction boundaries
                $var(has_received) = 0;
                $var(received_value) = "";
                
                # Method 1: Try transaction-scoped AVP (tu:reg_received)
                if ($avp(tu:reg_received) != "" && $avp(tu:reg_received) != "<null>") {
                    $var(received_value) = $avp(tu:reg_received);
                    xlog("REGISTER: DEBUG - AVP tu:reg_received (transaction-scoped): [$var(received_value)]\n");
                    # Validate it's a valid IP:port format
                    if ($var(received_value) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:[0-9]+$") {
                        $var(has_received) = 1;
                    }
                }
                
                # Method 2: Try regular AVP if transaction-scoped AVP not available
                if ($var(has_received) == 0 && $avp(reg_received) != "" && $avp(reg_received) != "<null>") {
                    $var(received_value) = $avp(reg_received);
                    xlog("REGISTER: DEBUG - AVP reg_received (direct): [$var(received_value)]\n");
                    # Validate it's a valid IP:port format
                    if ($var(received_value) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:[0-9]+$") {
                        $var(has_received) = 1;
                    }
                }
                
                # Method 3: Try array-style access as fallback
                if ($var(has_received) == 0) {
                    if ($(avp(reg_received)[0]) != "" && $(avp(reg_received)[0]) != "<null>") {
                        $var(received_value) = $(avp(reg_received)[0]);
                        xlog("REGISTER: DEBUG - AVP reg_received (array): [$var(received_value)]\n");
                        # Validate it's a valid IP:port format
                        if ($var(received_value) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:[0-9]+$") {
                            $var(has_received) = 1;
                        }
                    } else {
                        xlog("REGISTER: DEBUG - AVP reg_received (all methods) is empty or null\n");
                    }
                }
                
                # If AVP is still empty, try to extract from Via header (fallback method)
                # In responses, there are multiple Via headers (in reverse order):
                #   - First Via [0]: OpenSIPS's own Via (received=3.93.26.82)
                #   - Second Via [1]: Original endpoint's Via (received=74.83.23.44;rport=5060)
                # We use $hdr(Via)[1] to access the second Via header directly with built-in transformations
                if ($var(has_received) == 0) {
                    xlog("REGISTER: AVP reg_received not available, trying Via header extraction\n");
                    xlog("REGISTER: DEBUG - Via[0] (first/OpenSIPS): [$hdr(Via)[0]]\n");
                    xlog("REGISTER: DEBUG - Via[1] (second/endpoint): [$hdr(Via)[1]]\n");
                    
                    $var(via_ip) = "";
                    $var(via_port) = "";
                    
                    # Method 1: Extract from second Via header [1] using built-in transformations
                    # This should be the endpoint's Via header with received=74.83.23.44;rport=5060
                    # In OpenSIPS 3.6, use $(hdr(Via)[1]{via.received}) syntax with $() wrapper
                    if ($(hdr(Via)[1]{via.received}) != "" && $(hdr(Via)[1]{via.received}) != "<null>") {
                        $var(via_ip) = $(hdr(Via)[1]{via.received});
                        xlog("REGISTER: DEBUG - Extracted IP from Via[1]{via.received}: $var(via_ip)\n");
                        
                        # Extract port from rport parameter in the same Via header
                        if ($(hdr(Via)[1]{via.rport}) != "" && $(hdr(Via)[1]{via.rport}) != "<null>") {
                            $var(via_port) = $(hdr(Via)[1]{via.rport});
                            xlog("REGISTER: DEBUG - Extracted port from Via[1]{via.rport}: $var(via_port)\n");
                        } else {
                            # Fallback to port from Via header itself
                            if ($(hdr(Via)[1]{via.port}) != "" && $(hdr(Via)[1]{via.port}) != "<null>") {
                                $var(via_port) = $(hdr(Via)[1]{via.port});
                            } else {
                                $var(via_port) = "5060";  # Default SIP port
                            }
                        }
                    }
                    
                    # Method 2: Fallback - try first Via header if second didn't work
                    # (though this should be OpenSIPS's IP, not the endpoint's)
                    if ($var(via_ip) == "" && $(hdr(Via)[0]{via.received}) != "" && $(hdr(Via)[0]{via.received}) != "<null>") {
                        $var(temp_ip) = $(hdr(Via)[0]{via.received});
                        $var(opensips_ip) = "3.93.26.82";  # OpenSIPS's public IP
                        # Only use if it's not OpenSIPS's IP (unlikely but check anyway)
                        if ($var(temp_ip) != $var(opensips_ip)) {
                            $var(via_ip) = $var(temp_ip);
                            xlog("REGISTER: DEBUG - Extracted IP from Via[0]{via.received}: $var(via_ip)\n");
                            if ($(hdr(Via)[0]{via.rport}) != "" && $(hdr(Via)[0]{via.rport}) != "<null>") {
                                $var(via_port) = $(hdr(Via)[0]{via.rport});
                            } else {
                                $var(via_port) = "5060";
                            }
                        }
                    }
                    
                    # Method 2: Fallback - extract from main Via header IP:port (if received parameter not found)
                    if ($var(via_ip) == "" && $hdr(Via) =~ "SIP/2\\.0/UDP ([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}):([0-9]+)") {
                        $var(via_ip) = $re;
                        # Extract port separately
                        if ($hdr(Via) =~ "SIP/2\\.0/UDP [0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                            $var(via_port) = $re;
                        } else {
                            $var(via_port) = "5060";
                        }
                        xlog("REGISTER: DEBUG - Extracted IP:port from Via header (fallback): $var(via_ip):$var(via_port)\n");
                    }
                    
                    # Method 3: Last fallback - IP without port
                    if ($var(via_ip) == "" && $hdr(Via) =~ "SIP/2\\.0/UDP ([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})[; ]") {
                        $var(via_ip) = $re;
                        $var(via_port) = "5060";  # Default SIP port
                        xlog("REGISTER: DEBUG - Extracted IP from Via header (no port): $var(via_ip)\n");
                    }
                    
                    if ($var(via_ip) != "") {
                        if ($var(via_port) == "") {
                            $var(via_port) = "5060";  # Default if port not found
                        }
                        $var(received_value) = $var(via_ip) + ":" + $var(via_port);
                        xlog("REGISTER: Extracted source IP:port from Via header: $var(received_value)\n");
                        # Validate the extracted value matches IP:port pattern
                        if ($var(received_value) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:[0-9]+$") {
                            $var(has_received) = 1;
                        } else {
                            xlog("L_WARN", "REGISTER: Extracted value doesn't match IP:port pattern: [$var(received_value)]\n");
                        }
                    } else {
                        xlog("L_WARN", "REGISTER: Could not extract IP:port from Via header: [$hdr(Via)]\n");
                    }
                }
                
                # Validate that we have a valid IP:port format before attempting UPDATE
                # Check if received_value matches IP:port pattern (e.g., 74.83.23.44:5060)
                if ($var(has_received) == 0) {
                    xlog("L_WARN", "REGISTER: Cannot determine original request source IP:port for 'received' field\n");
                    xlog("L_WARN", "REGISTER: received_value is: [$var(received_value)] (not a valid IP:port format)\n");
                    xlog("L_WARN", "REGISTER: AVP reg_received and Via header extraction both failed\n");
                    xlog("L_WARN", "REGISTER: This will cause OPTIONS/NOTIFY routing to fail - endpoint behind NAT\n");
                } else {
                    xlog("REGISTER: Updating 'received' field with source IP:port: $var(received_value)\n");
                    
                    # Update the location record's 'received' field using SQL
                    # This ensures lookup() can find the endpoint's public NAT IP:port for routing OPTIONS/NOTIFY
                    # With db_mode=1 (write-through), save() writes to DB immediately, so our UPDATE will work right away
                    # The 'received' field will be available for lookup() immediately after the UPDATE
                    $var(update_query) = "UPDATE location SET received='" + $var(received_value) + "' WHERE username='" + $tU + "' AND domain='" + $(tu{uri.domain}) + "' AND expires > UNIX_TIMESTAMP()";
                    xlog("REGISTER: DEBUG - Executing SQL UPDATE query: $var(update_query)\n");
                    if (sql_query($var(update_query))) {
                        xlog("REGISTER: Successfully updated 'received' field to $var(received_value) for $var(endpoint_aor)\n");
                        xlog("REGISTER: With db_mode=1 (write-through), UPDATE works immediately - 'received' field is now available for lookup()\n");
                    } else {
                        xlog("L_WARN", "REGISTER: SQL UPDATE query failed for 'received' field: $var(received_value) for $var(endpoint_aor)\n");
                        xlog("L_WARN", "REGISTER: Failed query was: $var(update_query)\n");
                        xlog("L_WARN", "REGISTER: Check OpenSIPS error logs for SQL error details\n");
                        # Try to verify the record exists in the database
                        $var(check_query) = "SELECT contact_id FROM location WHERE username='" + $tU + "' AND domain='" + $(tu{uri.domain}) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                        if (sql_query($var(check_query), "$avp(check_contact_id)")) {
                            if ($(avp(check_contact_id)[0]) != "") {
                                xlog("REGISTER: DEBUG - Record exists in DB (contact_id: $(avp(check_contact_id)[0])), but UPDATE still failed\n");
                            } else {
                                xlog("REGISTER: DEBUG - Record not found in DB yet - this might be a timing issue\n");
                            }
                        }
                    }
                }
            } else {
                xlog("L_ERR", "REGISTER: save(\"location\") returned FALSE for $tU@$(tu{uri.domain}) (response $rs $rr)\n");
                xlog("L_ERR", "REGISTER: This means save() failed - check usrloc logs for database errors\n");
            }
        } else {
            # Registration failed (401, 403, etc.) - do NOT save location
            # This fixes the stale registration bug - failed registrations don't create records
            xlog("REGISTER: Failed registration ($rs $rr) for $tU@$(tu{uri.domain}), not saving location\n");
        }
    }
    exit;
}

failure_route[1] {
    xlog("L_ERR", "Transaction failure: method=$rm, Call-ID: $hdr(Call-ID), From=$fu, To=$tu, Response code=$rs, Reason=$rr\n");
    # Log more details about the failure
    if ($rs == 408) {
        xlog("L_ERR", "408 Request Timeout generated - transaction timed out waiting for response\n");
    }
    # t_relay will handle forwarding the failure response automatically
    exit;
}

####### Dispatcher events (visibility) ########

# Note: Event routes for dispatcher module are not currently configured
# Event route syntax varies by OpenSIPS version and may require specific module configuration
# If needed, check OpenSIPS documentation for event route syntax for your version

