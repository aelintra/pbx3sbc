#!opensips
#
# OpenSIPS SIP Edge Router Configuration Template
# This configuration replicates the functionality from Kamailio while
# addressing the INVITE transaction handling issues encountered with Kamailio
#
# Based on requirements in REQUIREMENTS-FOR-OPENSIPS.md
# Troubleshooting notes in TROUBLESHOOTING-OPTIONS-ROUTING.md
#

####### Global Parameters #########

# The default log_level is usually enough for most things but you can increase
# it here for lower levels of visibility 
#log_level=4

# OpenSIPS uses different parameter names than Kamailio
# Debug level can be set via command line: opensips -D 3
# Or via modparam for specific modules

# Module path (Ubuntu/Debian package location)
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules"

# Listen on all interfaces (socket replaces deprecated listen)
socket=udp:0.0.0.0:5060

# Set advertised address (replace with your OpenSIPS server's IP address)
# This fixes the Via header showing 0.0.0.0
# For cloud deployments, this MUST be your public IP address
# Use --advertised-ip parameter during installation, or manually edit after installation
advertised_address="34.205.252.186"

####### Modules ########

# Core modules
# Note: is_method(), has_totag() are built into OpenSIPS core
# Note: siputils and sanity modules don't exist in OpenSIPS - functions are built-in
# Note: pv (pseudo-variables) and xlog are built into OpenSIPS core
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
# Transport protocol - required for socket binding
loadmodule "proto_udp.so"
loadmodule "db_sqlite.so"
# SQL operations module for database queries
loadmodule "sqlops.so"
loadmodule "dispatcher.so"
loadmodule "sipmsgops.so"

####### Module Parameters ########

# --- SQLite routing database ---
# SQL operations module connection for sql_query() function
# Use 3 slashes to match dispatcher module format (both use same database)
modparam("sqlops", "db_url",
    "sqlite:///var/lib/opensips/routing.db")

# --- Dispatcher (health checks via SIP OPTIONS) ---
modparam("dispatcher", "db_url",
    "sqlite:///var/lib/opensips/routing.db")

modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_threshold", 2)
# Note: ds_inactive_threshold doesn't exist in OpenSIPS dispatcher module
# Note: ds_ping_reply_codes is called options_reply_codes in OpenSIPS
modparam("dispatcher", "options_reply_codes", "200")

# --- Transaction timers ---
# Note: fr_timer is not a modparam in OpenSIPS - transaction timeouts are handled differently
# restart_fr_on_each_reply: reset final response timer on each provisional response
modparam("tm", "restart_fr_on_each_reply", 1)
# T1_timer: initial retransmission period (2 seconds = 2000ms)
# Note: OpenSIPS uses T1_timer instead of retr_timer1
modparam("tm", "T1_timer", 2000)
# T2_timer: maximum retransmission period (8 seconds = 8000ms)
# Note: OpenSIPS uses T2_timer instead of retr_timer2
modparam("tm", "T2_timer", 8000)

# --- Response handling ---
# OpenSIPS handles responses differently - ensure proper forwarding

####### Routing Logic ########

route {
    # ---- Log ALL requests at the very start for debugging ----
    xlog("REQUEST: $rm from $si:$sp to $ru (Call-ID: $hdr(Call-ID))\n");
    
    # Log SDP details for INVITE requests to diagnose audio issues
    if (is_method("INVITE") && $hdr(Content-Type) =~ "application/sdp") {
        $var(from_user) = $(fu{uri.user});
        $var(to_user) = $(tu{uri.user});
        xlog("INVITE with SDP: From=$var(from_user)@$si, To=$var(to_user)@$rd\n");
    }

    # ---- Basic hygiene ----
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    # Note: sanity_check() module not available in OpenSIPS
    # Basic validation is handled by core parsing

    # ---- Drop known scanners ----
    if ($ua =~ "sipvicious|friendly-scanner|sipcli|nmap") {
        exit;
    }

    # ---- In-dialog requests ----
    # Check if To tag exists (in-dialog request)
    # OpenSIPS uses $to_tag pseudo-variable (equivalent to Kamailio's $tt)
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    # ---- Allowed methods only ----
    if (!is_method("REGISTER|INVITE|ACK|BYE|CANCEL|OPTIONS|NOTIFY|SUBSCRIBE")) {
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }

    # ---- Handle CANCEL early (before domain check) ----
    # CANCEL needs to match existing INVITE transaction
    if (is_method("CANCEL")) {
        xlog("CANCEL received from $si:$sp for Call-ID: $hdr(Call-ID), CSeq=$hdr(CSeq), From=$fu, To=$tu\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("CANCEL matches existing transaction, forwarding to cancel INVITE\n");
        } else {
            xlog("L_WARN", "CANCEL received but no matching transaction found\n");
            sl_send_reply(481, "Call/Transaction Does Not Exist");
            exit;
        }
        # Forward CANCEL to cancel the INVITE transaction
        route(RELAY);
        exit;
    }

    # ---- Log INVITE requests for debugging ----
    if (is_method("INVITE")) {
        xlog("INVITE received from $si:$sp to $ru (From: $fu, To: $tu)\n");
    }

    # ---- Handle OPTIONS and NOTIFY from Asterisk backends (to endpoints) ----
    # Asterisk sends OPTIONS to registered endpoints for health checks and NAT keepalive
    # Asterisk sends NOTIFY for event notifications (e.g., message waiting indicators)
    # These need to be routed back to the actual endpoint IP
    if (is_method("OPTIONS|NOTIFY")) {
        # Check if this is coming from a known dispatcher destination (Asterisk backend)
        # Query database to see if source IP matches any dispatcher destination
        $var(source_ip) = $si;
        xlog("OPTIONS/NOTIFY received from $si, checking if from dispatcher\n");
        
        # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
        # If so, try endpoint lookup regardless of dispatcher check
        # Request-URI format: sip:401@192.168.1.138:56931 or sip:401@192.168.1.138
        $var(should_try_endpoint) = 0;
        
        # Check if Request-URI has a username
        if ($rU != "") {
            # Check if Request-URI domain is an IP address (contains digits and dots, not a domain name)
            # Simple heuristic: if domain contains only digits, dots, and colons, it's likely an IP
            if ($rd =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                $var(should_try_endpoint) = 1;
                xlog("OPTIONS/NOTIFY Request-URI looks like endpoint: $rU@$rd\n");
            }
        }
        
        # Also check if source IP is from a known dispatcher destination
        # For now, we'll try endpoint lookup if Request-URI looks like an endpoint
        # or if we want to check dispatcher destinations, we can add that logic here
        
        if ($var(should_try_endpoint) > 0) {
            
                    # Extract endpoint identifier
                    # Try To header first (may have domain), fallback to Request-URI username
                    $var(endpoint_user) = $tU;
                    if ($var(endpoint_user) == "") {
                        $var(endpoint_user) = $rU;
                    }
                    
                    # Try to get domain from To header, but if it's an IP, use username-only lookup
                    $var(to_domain) = $(tu{uri.domain});
                    if ($var(to_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # To header has IP, not domain - will use username-only lookup
                        $var(endpoint_aor) = "";
                    } else if ($var(to_domain) != "") {
                        # To header has domain - use for exact match
                        $var(endpoint_aor) = $var(endpoint_user) + "@" + $var(to_domain);
                    } else {
                        # No domain in To header - will use username-only lookup
                        $var(endpoint_aor) = "";
                    }
                    
                    xlog("OPTIONS/NOTIFY from Asterisk $si, looking up endpoint AoR: $var(endpoint_aor) (user: $var(endpoint_user))\n");
                    
                    # Use helper route to look up endpoint location
                    $var(lookup_user) = $var(endpoint_user);
                    $var(lookup_aor) = $var(endpoint_aor);
                    route(ENDPOINT_LOOKUP);
                    
                    # Check if endpoint was found
                    if ($var(lookup_success) == 1) {
                        # Get username from Request-URI or To header for destination URI
                        $var(target_user) = $tU;
                        if ($var(target_user) == "") {
                            $var(target_user) = $rU;
                        }
                        
                        # For OPTIONS/NOTIFY, use simple URI construction (no domain fallback needed)
                        # Set endpoint_user for BUILD_ENDPOINT_URI
                        $var(endpoint_user) = $var(target_user);
                        # Clear AoR to force simple IP-based Request-URI
                        $var(endpoint_aor) = "";
                        route(BUILD_ENDPOINT_URI);
                        
                        xlog("Routing $rm from Asterisk $si to endpoint $du, Request-URI=$ru\n");
                        route(RELAY);
                        exit;
                    }
                    
                    # Endpoint lookup failed - handle fallback
                    xlog("L_WARN", "$rm from Asterisk $si to $var(endpoint_aor) - endpoint location not found in database\n");
                    if (is_method("OPTIONS")) {
                        sl_send_reply(200, "OK");
                    } else {
                        # For NOTIFY, try to route based on Contact header if available
                        # Extract IP and port from Contact header using regex
                        $var(notify_ip) = "";
                        $var(notify_port) = "";
                        if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                            $var(notify_ip) = $re;
                            if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                                $var(notify_port) = $re;
                            }
                        }
                        
                        if ($var(notify_ip) != "" && $var(notify_ip) != $si) {
                            $du = "sip:" + $tU + "@" + $var(notify_ip);
                            if ($var(notify_port) != "") {
                                $du = $du + ":" + $var(notify_port);
                            } else {
                                $du = $du + ":5060";
                            }
                            xlog("Routing $rm to $du (fallback from Contact header)\n");
                            route(RELAY);
                        } else {
                            sl_send_reply(404, "Not Found");
                        }
                    }
                    exit;
        }
        
        # If we get here, Request-URI doesn't look like an endpoint, continue normal routing
        xlog("OPTIONS/NOTIFY from $si - Request-URI doesn't look like endpoint, continuing normal routing\n");
    }
    
    # ---- Handle REGISTER to track endpoint locations ----
    if (is_method("REGISTER")) {
        xlog("REGISTER received from $si, Contact: $hdr(Contact), To: $hdr(To)\n");
        
        # Extract endpoint location from Contact header and store in database
        # This allows us to route OPTIONS from Asterisk back to endpoints
        # Check if Contact header exists and extract values
        if ($hdr(Contact) != "") {
            # Extract AoR from To header (user@domain)
            # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
            $var(endpoint_aor) = $tU + "@" + $(tu{uri.domain});
            
            # Extract IP and port - always use source IP/port for REGISTER (endpoint sends directly)
            # Contact header extraction is for NAT scenarios, but source is more reliable for REGISTER
            $var(endpoint_ip) = $si;
            $var(endpoint_port) = $sp;
            
            # Ensure port is set (default to 5060 if source port is missing)
            if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                $var(endpoint_port) = "5060";
            }
            
            # Try to extract from Contact header as fallback (for NAT scenarios)
            # Use regex to extract IP:port from Contact header string
            $var(contact_ip) = "";
            $var(contact_port) = "";
            
            # Extract IP address from Contact header (pattern: @IP:port or @IP)
            # Match IPv4 address after @ symbol
            if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                $var(contact_ip) = $re;
                
                # Extract port if present (pattern: :PORT after the IP)
                if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                    $var(contact_port) = $re;
                }
            }
            
            # Use Contact header values if they're valid and different from source (NAT scenario)
            if ($var(contact_ip) != "" && $var(contact_ip) != "0" && $var(contact_ip) != $si) {
                $var(endpoint_ip) = $var(contact_ip);
                xlog("Using Contact header IP ($var(contact_ip)) instead of source IP ($si) - possible NAT scenario\n");
            }
            if ($var(contact_port) != "" && $var(contact_port) != "0" && $var(contact_port) != $sp) {
                $var(endpoint_port) = $var(contact_port);
                xlog("Using Contact header port ($var(contact_port)) instead of source port ($sp)\n");
            }
            
            # Final validation - ensure we have valid values
            if ($var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
                $var(endpoint_ip) = $si;
            }
            if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                $var(endpoint_port) = $sp;
                if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                    $var(endpoint_port) = "5060";
                }
            }
            
            xlog("Contact extraction: source IP=$si, source port=$sp, extracted IP=$var(contact_ip), extracted port=$var(contact_port), final IP=$var(endpoint_ip), Port=$var(endpoint_port), full Contact=$hdr(Contact)\n");
            
            # Validate extracted IP and port before storing
            if ($var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
                xlog("L_ERR", "Failed to extract IP - source IP=$si, Contact: $hdr(Contact), endpoint_ip=$var(endpoint_ip)\n");
            } else if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                xlog("L_ERR", "Failed to extract port - source port=$sp, endpoint_port=$var(endpoint_port)\n");
            } else {
                # Get expires from Expires header or Contact header
                $var(expires) = $hdr(Expires);
                if ($var(expires) == "") {
                    $var(expires) = "3600";  # Default 1 hour
                }
                
                # Ensure expires is a valid integer
                $var(expires_int) = $var(expires);
                if ($var(expires_int) == "" || $var(expires_int) == "0") {
                    $var(expires_int) = "3600";
                }
                
                # Use source IP/port directly - ensure we have valid values
                $var(final_ip) = $si;
                $var(final_port) = $sp;
                if ($var(final_port) == "" || $var(final_port) == "0") {
                    $var(final_port) = "5060";
                }
                
                xlog("Extracted endpoint info: AoR=$var(endpoint_aor), IP=$var(final_ip), Port=$var(final_port), Expires=$var(expires_int)\n");
                
                # Store/update endpoint location in database
                # Calculate expiration time: current time + expires seconds
                # Use SQLite's datetime modifier syntax: datetime('now', '+N seconds')
                # Note: sql_query() returns false for INSERT statements (no rows returned),
                # but the INSERT still succeeds. We execute it and log the attempt.
                $var(query) = "INSERT OR REPLACE INTO endpoint_locations (aor, contact_ip, contact_port, expires) VALUES ('" + $var(endpoint_aor) + "', '" + $var(final_ip) + "', '" + $var(final_port) + "', datetime('now', '+" + $var(expires_int) + " seconds'))";
                xlog("SQL query: $var(query)\n");
                # Execute INSERT - return value is false for INSERT (no rows), but query succeeds
                sql_query($var(query), "$avp(reg_result)");
                xlog("Stored endpoint location: $var(endpoint_aor) -> $var(final_ip):$var(final_port) (expires in $var(expires_int) seconds)\n");
            }
        } else {
            xlog("L_WARN", "REGISTER without Contact header - cannot track endpoint location\n");
        }
        # Continue to DOMAIN_CHECK to forward REGISTER to Asterisk
    }

    route(DOMAIN_CHECK);
}

####### Domain validation / door-knocker protection ########

route[DOMAIN_CHECK] {

    # OpenSIPS: Request-URI domain is $rd (lowercase), not $rD
    $var(domain) = $rd;

    if ($var(domain) == "") {
        exit;
    }

    # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
    # This handles INVITE from Asterisk to endpoints (e.g., sip:402@192.168.1.232:5060)
    # Note: $rd might include port (e.g., 192.168.1.138:56931), so we check just the IP part
    # Extract just the IP address part (before any colon)
    $var(request_domain) = $rd;
    xlog("DEBUG: Checking endpoint detection - rU=$rU, rd=$rd, request_domain=$var(request_domain), full URI=$ru\n");
    if ($var(request_domain) =~ "^([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
        $var(request_ip) = $re;
        xlog("INVITE Request-URI looks like endpoint: $rU@$var(request_domain) (IP=$var(request_ip)), attempting endpoint lookup\n");
        
        # Extract username from Request-URI
        $var(endpoint_user) = $rU;
        xlog("Extracted endpoint username: $var(endpoint_user)\n");
        
        # Use helper route to look up endpoint location (AoR, IP, and port)
        $var(lookup_user) = $var(endpoint_user);
        $var(lookup_aor) = "";  # Start with username-only lookup
        route(ENDPOINT_LOOKUP);
        
        # Check if endpoint was found
        if ($var(lookup_success) == 1) {
            xlog("Endpoint lookup result: AoR=$var(endpoint_aor), IP=$var(endpoint_ip), Port=$var(endpoint_port)\n");
            
            # Build destination URI and Request-URI using helper route
            route(BUILD_ENDPOINT_URI);
            
            xlog("Routing INVITE from $si to endpoint: dest=$du, Request-URI=$ru (endpoint lookup)\n");
            route(RELAY);
            exit;
        }
        
        # If endpoint lookup failed, log and send 404
        xlog("L_WARN", "Endpoint lookup failed for $var(endpoint_user)@$rd - no matching endpoint found in database\n");
        sl_send_reply(404, "Endpoint Not Found");
        exit;
    }

    # Optional extra hardening: domain consistency
    # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
    if ($rd != $(tu{uri.domain})) {
        xlog("L_WARN", "R-URI / To mismatch domain=$rd src=$si\n");
        exit;
    }

    # Lookup dispatcher set for this domain
    # Use string concatenation to interpolate variable into SQL query
    $var(query) = "SELECT dispatcher_setid FROM sip_domains WHERE domain='" + $var(domain) + "' AND enabled=1";
    if (!sql_query($var(query), "$avp(domain_setid)")) {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (query failed)\n");
        exit;
    }
    
    # Check if domain was found
    if ($(avp(domain_setid)[0]) == "") {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (not found)\n");
        exit;
    }
    
    # Get the dispatcher_setid from query result (first row, first column)
    $var(setid) = $(avp(domain_setid)[0]);

    route(TO_DISPATCHER);
}

####### Health-aware routing ########

route[TO_DISPATCHER] {

    # Select a healthy Asterisk from the dispatcher set
    if (!ds_select_dst($var(setid), 4)) {
        xlog("L_ERR", "No healthy Asterisk nodes for domain=$rd setid=$var(setid)\n");
        sl_send_reply(503, "Service Unavailable");
        exit;
    }

    xlog("Routing to $du for domain=$rd setid=$var(setid) method=$rm Request-URI=$ru\n");

    record_route();

    # Arm failure route to handle transaction failures
    t_on_failure("1");

    # OpenSIPS transaction handling - this is where we expect better behavior
    # than Kamailio for INVITE transactions
    if (!t_relay()) {
        xlog("L_ERR", "t_relay() failed for $du method=$rm Request-URI=$ru\n");
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
        exit;
    }

    xlog("t_relay() succeeded for $du method=$rm, transaction created\n");
    # For INVITE, ensure transaction stays active
    # The transaction module should handle this automatically, but log it
    if (is_method("INVITE")) {
        xlog("INVITE transaction created, waiting for response from $du\n");
    }
    exit;
}

####### In-dialog handling ########

route[WITHINDLG] {
    xlog("In-dialog request: $rm from $si to $ru (Call-ID: $hdr(Call-ID), To-tag=$tt)\n");

    # Check for Record-Route header and follow it
    if (loose_route()) {
        xlog("loose_route() succeeded for $rm, following Record-Route\n");
        route(RELAY);
        exit;
    }

    # If loose_route() fails, try to route based on transaction state
    # For BYE, we need to find the original transaction
    if (is_method("BYE")) {
        xlog("BYE request - loose_route() failed, checking transaction state\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("BYE matches existing transaction, relaying\n");
            route(RELAY);
            exit;
        } else {
            xlog("L_WARN", "BYE received but no matching transaction found, trying to relay anyway\n");
            # Try to relay even without transaction match
            route(RELAY);
            exit;
        }
    }

    xlog("L_WARN", "In-dialog request $rm - loose_route() failed and no transaction match\n");
    sl_send_reply(404, "Not Here");
    exit;
}

####### Helper Routes ########

# Endpoint lookup helper route
# Looks up endpoint location from database by username and/or AoR
# 
# Input variables:
#   $var(lookup_user) - Username to look up (required)
#   $var(lookup_aor)  - Optional AoR for exact match (e.g., "user@domain.com")
#
# Output variables:
#   $var(endpoint_ip)   - Endpoint IP address if found
#   $var(endpoint_port) - Endpoint port if found (defaults to 5060)
#   $var(endpoint_aor)  - Full AoR if found (e.g., "user@domain.com")
#   $var(lookup_success) - 1 if endpoint found, 0 if not found
#
# Usage:
#   $var(lookup_user) = "40004";
#   $var(lookup_aor) = "40004@pbx3sbc.vcloudpbx.com";  # Optional
#   route(ENDPOINT_LOOKUP);
#   if ($var(lookup_success) == 1) {
#       # Use $var(endpoint_ip), $var(endpoint_port), $var(endpoint_aor)
#   }
route[ENDPOINT_LOOKUP] {
    xlog("ENDPOINT_LOOKUP: Looking up user=$var(lookup_user), AoR=$var(lookup_aor)\n");
    
    # Initialize output variables
    $var(endpoint_ip) = "";
    $var(endpoint_port) = "";
    $var(endpoint_aor) = "";
    $var(lookup_success) = 0;
    
    # Validate input
    if ($var(lookup_user) == "") {
        xlog("L_ERR", "ENDPOINT_LOOKUP: lookup_user is empty\n");
        exit;
    }
    
    # First try exact AoR match (if AoR provided and not empty)
    if ($var(lookup_aor) != "") {
        xlog("ENDPOINT_LOOKUP: Trying exact AoR match for $var(lookup_aor)\n");
        $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor='" + $var(lookup_aor) + "' AND expires > datetime('now')";
        if (sql_query($var(query), "$avp(endpoint_ip)")) {
            if ($(avp(endpoint_ip)[0]) != "") {
                $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
                # Get the port
                $var(query) = "SELECT contact_port FROM endpoint_locations WHERE aor='" + $var(lookup_aor) + "' AND expires > datetime('now')";
                if (sql_query($var(query), "$avp(endpoint_port)")) {
                    $var(endpoint_port) = $(avp(endpoint_port)[0]);
                }
                $var(endpoint_aor) = $var(lookup_aor);
                xlog("ENDPOINT_LOOKUP: Exact match found - IP=$var(endpoint_ip), Port=$var(endpoint_port), AoR=$var(endpoint_aor)\n");
            }
        }
    }
    
    # Fallback: try username-only lookup (if exact match failed or wasn't attempted)
    if ($var(endpoint_ip) == "") {
        xlog("ENDPOINT_LOOKUP: Trying username-only match for $var(lookup_user)\n");
        $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(lookup_user) + "@%' AND expires > datetime('now') LIMIT 1";
        if (sql_query($var(query), "$avp(endpoint_ip)")) {
            if ($(avp(endpoint_ip)[0]) != "") {
                $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
                # Get the port
                $var(query) = "SELECT contact_port FROM endpoint_locations WHERE aor LIKE '" + $var(lookup_user) + "@%' AND expires > datetime('now') LIMIT 1";
                if (sql_query($var(query), "$avp(endpoint_port)")) {
                    $var(endpoint_port) = $(avp(endpoint_port)[0]);
                }
                # Get the full AoR
                $var(query) = "SELECT aor FROM endpoint_locations WHERE aor LIKE '" + $var(lookup_user) + "@%' AND expires > datetime('now') LIMIT 1";
                if (sql_query($var(query), "$avp(endpoint_aor)")) {
                    $var(endpoint_aor) = $(avp(endpoint_aor)[0]);
                }
                xlog("ENDPOINT_LOOKUP: Username match found - IP=$var(endpoint_ip), Port=$var(endpoint_port), AoR=$var(endpoint_aor)\n");
            }
        }
    }
    
    # Validate and set defaults
    if ($var(endpoint_ip) != "") {
        route(VALIDATE_ENDPOINT);
        $var(lookup_success) = 1;
        xlog("ENDPOINT_LOOKUP: Success - IP=$var(endpoint_ip), Port=$var(endpoint_port), AoR=$var(endpoint_aor)\n");
    } else {
        xlog("ENDPOINT_LOOKUP: Failed - no endpoint found for user=$var(lookup_user)\n");
        $var(lookup_success) = 0;
    }
    
    exit;
}

# Endpoint validation helper route
# Validates endpoint IP and port, sets defaults
# 
# Input variables:
#   $var(endpoint_ip)   - Endpoint IP address (required)
#   $var(endpoint_port) - Endpoint port (optional, defaults to 5060)
#
# Output variables:
#   $var(endpoint_ip)   - Validated IP (unchanged if valid)
#   $var(endpoint_port) - Validated port (defaults to 5060 if empty/invalid)
#
# Usage:
#   $var(endpoint_ip) = "192.168.1.100";
#   $var(endpoint_port) = "";  # Will be set to 5060
#   route(VALIDATE_ENDPOINT);
route[VALIDATE_ENDPOINT] {
    # Validate IP is not empty
    if ($var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
        xlog("L_ERR", "VALIDATE_ENDPOINT: endpoint_ip is empty or invalid\n");
        exit;
    }
    
    # Set default port if empty or invalid
    if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
        $var(endpoint_port) = "5060";
    }
    
    exit;
}

# Build endpoint URI helper route
# Constructs destination URI ($du) and Request-URI ($ru) for routing to endpoints
# Handles domain extraction and fallback logic for Request-URI construction
#
# Input variables:
#   $var(endpoint_user)   - Username for the endpoint (required)
#   $var(endpoint_ip)     - Endpoint IP address (required)
#   $var(endpoint_port)   - Endpoint port (required, should be validated)
#   $var(endpoint_aor)    - Full AoR (user@domain) if available (optional)
#
# Output variables:
#   $du - Destination URI (sip:user@ip:port) for routing
#   $ru - Request-URI (sip:user@domain or sip:user@ip:port) with domain fallbacks
#
# Usage:
#   $var(endpoint_user) = "40004";
#   $var(endpoint_ip) = "192.168.1.100";
#   $var(endpoint_port) = "5060";
#   $var(endpoint_aor) = "40004@pbx3sbc.vcloudpbx.com";  # Optional
#   route(BUILD_ENDPOINT_URI);
route[BUILD_ENDPOINT_URI] {
    # Build destination URI with IP:port for routing (NAT traversal)
    $du = "sip:" + $var(endpoint_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
    
    # Extract domain from AoR if available
    $var(endpoint_domain) = "";
    if ($var(endpoint_aor) != "" && $var(endpoint_aor) =~ "@(.+)") {
        $var(endpoint_domain) = $re;
    }
    
    # If domain extraction failed or domain is an IP, try To header as fallback
    if ($var(endpoint_domain) == "" || $var(endpoint_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
        $var(to_domain) = $(tu{uri.domain});
        if ($var(to_domain) != "" && $var(to_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
            $var(endpoint_domain) = $var(to_domain);
            xlog("BUILD_ENDPOINT_URI: Using domain from To header: $var(endpoint_domain)\n");
        }
    }
    
    # Construct Request-URI with fallback logic
    if ($var(endpoint_aor) != "" && $var(endpoint_aor) =~ "@" && $var(endpoint_aor) !~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
        # AoR has domain (not IP), use it directly
        $ru = "sip:" + $var(endpoint_aor);
        xlog("BUILD_ENDPOINT_URI: Using AoR directly in Request-URI: $ru\n");
    } else if ($var(endpoint_domain) != "" && $var(endpoint_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
        # Fallback: construct from extracted domain
        $ru = "sip:" + $var(endpoint_user) + "@" + $var(endpoint_domain);
        xlog("BUILD_ENDPOINT_URI: Using extracted domain in Request-URI: $ru\n");
    } else {
        # Last resort: use IP if domain not found
        xlog("L_WARN", "BUILD_ENDPOINT_URI: Cannot determine domain, using IP in Request-URI: $du\n");
        $ru = $du;
    }
    
    exit;
}

route[RELAY] {
    # Arm failure route to handle transaction failures
    t_on_failure("1");
    if (!t_relay()) {
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
    }
    exit;
}

####### Response handling (for debugging) ########

onreply_route {
    xlog("Response received: $rs $rr from $si (method=$rm, CSeq=$hdr(CSeq), To-tag=$tt, Contact=$hdr(Contact))\n");
    
    # Detailed SDP logging for 200 OK responses
    # This helps diagnose why one direction works and the other doesn't
    if ($rs == 200 && $hdr(Content-Type) =~ "application/sdp") {
        # Extract username from To header to identify the callee
        $var(to_user) = $(tu{uri.user});
        $var(from_user) = $(fu{uri.user});
        
        xlog("200 OK with SDP: From=$var(from_user), To=$var(to_user), Source=$si\n");
        
        # Diagnostic logging: Check endpoint IPs for SDP troubleshooting
        # This helps diagnose RTP issues regardless of whether call is from Asterisk or endpoint
        if ($var(to_user) != "") {
            # Look up endpoint IP from database for the callee (To header)
            $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(to_user) + "@%' AND expires > datetime('now') LIMIT 1";
            if (sql_query($var(query), "$avp(endpoint_ip)")) {
                if ($(avp(endpoint_ip)[0]) != "") {
                    $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
                    xlog("Callee endpoint IP from database: $var(endpoint_ip) (user=$var(to_user))\n");
                }
            }
            
            # Also check the caller's endpoint IP
            if ($var(from_user) != "") {
                $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(from_user) + "@%' AND expires > datetime('now') LIMIT 1";
                if (sql_query($var(query), "$avp(caller_ip)")) {
                    if ($(avp(caller_ip)[0]) != "") {
                        $var(caller_ip) = $(avp(caller_ip)[0]);
                        xlog("Caller endpoint IP from database: $var(caller_ip) (user=$var(from_user))\n");
                    }
                }
            }
        }
    }
    
    # Log transaction state for debugging
    if ($rs >= 100 && $rs < 200) {
        xlog("Provisional response $rs received, transaction should remain active\n");
        # For provisional responses, explicitly exit to let transaction module handle forwarding
        # The transaction module will automatically forward and keep transaction alive
        exit;
    } else if ($rs >= 200 && $rs < 300) {
        xlog("Final success response $rs received\n");
        exit;
    } else if ($rs >= 300) {
        xlog("Final error response $rs received\n");
        exit;
    }
    # If we get here, exit to let transaction module handle it
    exit;
}

failure_route[1] {
    xlog("L_ERR", "Transaction failure: method=$rm, Call-ID: $hdr(Call-ID), From=$fu, To=$tu, Response code=$rs, Reason=$rr\n");
    # Log more details about the failure
    if ($rs == 408) {
        xlog("L_ERR", "408 Request Timeout generated - transaction timed out waiting for response\n");
    }
    # t_relay will handle forwarding the failure response automatically
    exit;
}

####### Dispatcher events (visibility) ########

# Note: Event routes for dispatcher module are not currently configured
# Event route syntax varies by OpenSIPS version and may require specific module configuration
# If needed, check OpenSIPS documentation for event route syntax for your version

