#!opensips
#
# OpenSIPS SIP Edge Router Configuration Template
# This configuration replicates the functionality from Kamailio while
# addressing the INVITE transaction handling issues encountered with Kamailio
#
# Based on requirements in REQUIREMENTS-FOR-OPENSIPS.md
# Troubleshooting notes in TROUBLESHOOTING-OPTIONS-ROUTING.md
#

####### Global Parameters #########

# The default log_level is usually enough for most things but you can increase
# it here for lower levels of visibility 
#log_level=4

# OpenSIPS uses different parameter names than Kamailio
# Debug level can be set via command line: opensips -D 3
# Or via modparam for specific modules

# Module path (Ubuntu/Debian package location)
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules"

# Listen on all interfaces (socket replaces deprecated listen)
socket=udp:0.0.0.0:5060

# Set advertised address (replace with your OpenSIPS server's IP address)
# This fixes the Via header showing 0.0.0.0
advertised_address="192.168.1.95"

####### Modules ########

# Core modules
# Note: is_method(), has_totag() are built into OpenSIPS core
# Note: siputils and sanity modules don't exist in OpenSIPS - functions are built-in
# Note: pv (pseudo-variables) and xlog are built into OpenSIPS core
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
# Transport protocol - required for socket binding
loadmodule "proto_udp.so"
loadmodule "db_sqlite.so"
# SQL operations module for database queries
loadmodule "sqlops.so"
loadmodule "dispatcher.so"
loadmodule "sipmsgops.so"

####### Module Parameters ########

# --- SQLite routing database ---
# SQL operations module connection for sql_query() function
# Use 3 slashes to match dispatcher module format (both use same database)
modparam("sqlops", "db_url",
    "sqlite:///var/lib/opensips/routing.db")

# --- Dispatcher (health checks via SIP OPTIONS) ---
modparam("dispatcher", "db_url",
    "sqlite:///var/lib/opensips/routing.db")

modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_threshold", 2)
# Note: ds_inactive_threshold doesn't exist in OpenSIPS dispatcher module
# Note: ds_ping_reply_codes is called options_reply_codes in OpenSIPS
modparam("dispatcher", "options_reply_codes", "200")

# --- Transaction timers ---
# Note: fr_timer is not a modparam in OpenSIPS - transaction timeouts are handled differently
# restart_fr_on_each_reply: reset final response timer on each provisional response
modparam("tm", "restart_fr_on_each_reply", 1)
# T1_timer: initial retransmission period (2 seconds = 2000ms)
# Note: OpenSIPS uses T1_timer instead of retr_timer1
modparam("tm", "T1_timer", 2000)
# T2_timer: maximum retransmission period (8 seconds = 8000ms)
# Note: OpenSIPS uses T2_timer instead of retr_timer2
modparam("tm", "T2_timer", 8000)

# --- Response handling ---
# OpenSIPS handles responses differently - ensure proper forwarding
# Note: onreply_avp_mode may not exist in all versions, remove if it causes issues

####### Routing Logic ########

route {
    # ---- Log ALL requests at the very start for debugging ----
    xlog("REQUEST: $rm from $si:$sp to $ru (Call-ID: $hdr(Call-ID))\n");
    
    # Log SDP details for INVITE requests to diagnose audio issues
    if (is_method("INVITE") && $hdr(Content-Type) =~ "application/sdp") {
        $var(from_user) = $(fu{uri.user});
        $var(to_user) = $(tu{uri.user});
        xlog("INVITE with SDP: From=$var(from_user)@$si, To=$var(to_user)@$rd\n");
    }

    # ---- Basic hygiene ----
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    # Note: sanity_check() module not available in OpenSIPS
    # Basic validation is handled by core parsing
    # if (!sanity_check("1511", "7")) {
    #     xlog("L_WARN", "Malformed SIP from $si\n");
    #     exit;
    # }

    # ---- Drop known scanners ----
    if ($ua =~ "sipvicious|friendly-scanner|sipcli|nmap") {
        exit;
    }

    # ---- In-dialog requests ----
    # Check if To tag exists (in-dialog request)
    # OpenSIPS uses $to_tag pseudo-variable (equivalent to Kamailio's $tt)
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    # ---- Allowed methods only ----
    if (!is_method("REGISTER|INVITE|ACK|BYE|CANCEL|OPTIONS|NOTIFY|SUBSCRIBE")) {
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }

    # ---- Handle CANCEL early (before domain check) ----
    # CANCEL needs to match existing INVITE transaction
    if (is_method("CANCEL")) {
        xlog("CANCEL received from $si:$sp for Call-ID: $hdr(Call-ID), CSeq=$hdr(CSeq), From=$fu, To=$tu\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("CANCEL matches existing transaction, forwarding to cancel INVITE\n");
        } else {
            xlog("L_WARN", "CANCEL received but no matching transaction found\n");
            sl_send_reply(481, "Call/Transaction Does Not Exist");
            exit;
        }
        # Forward CANCEL to cancel the INVITE transaction
        route(RELAY);
        exit;
    }

    # ---- Log INVITE requests for debugging ----
    if (is_method("INVITE")) {
        xlog("INVITE received from $si:$sp to $ru (From: $fu, To: $tu)\n");
    }

    # ---- Handle OPTIONS and NOTIFY from Asterisk backends (to endpoints) ----
    # Asterisk sends OPTIONS to registered endpoints for health checks and NAT keepalive
    # Asterisk sends NOTIFY for event notifications (e.g., message waiting indicators)
    # These need to be routed back to the actual endpoint IP
    if (is_method("OPTIONS|NOTIFY")) {
        # Check if this is coming from a known dispatcher destination (Asterisk backend)
        # Query database to see if source IP matches any dispatcher destination
        $var(source_ip) = $si;
        xlog("OPTIONS/NOTIFY received from $si, checking if from dispatcher\n");
        
        # Extract IP from destination field and compare with source IP
        # Destination format can be: just IP (192.168.1.91), sip:IP:PORT, or sip:IP
        # Handle all formats by checking if destination starts with "sip:" or is just an IP
        # TODO: OpenSIPS doesn't have sql_query() - need to use OpenSIPS database module
        # First, let's see what destinations exist (debug only - remove after testing)
        # if (sql_query("cb", "SELECT destination FROM dispatcher LIMIT 5", "debug_dest")) {
        #     if ($dbr(debug_dest=>rows) > 0) {
        #         xlog("Sample dispatcher destinations in DB: $dbr(debug_dest=>[0,0])\n");
        #     }
        #     sql_result_free("debug_dest");
        # }
        
        # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
        # If so, try endpoint lookup regardless of dispatcher check
        # Request-URI format: sip:401@192.168.1.138:56931 or sip:401@192.168.1.138
        $var(should_try_endpoint) = 0;
        
        # Check if Request-URI has a username
        if ($rU != "") {
            # Check if Request-URI domain is an IP address (contains digits and dots, not a domain name)
            # Simple heuristic: if domain contains only digits, dots, and colons, it's likely an IP
            if ($rd =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                $var(should_try_endpoint) = 1;
                xlog("OPTIONS/NOTIFY Request-URI looks like endpoint: $rU@$rd\n");
            }
        }
        
        # Also check if source IP is from a known dispatcher destination
        # For now, we'll try endpoint lookup if Request-URI looks like an endpoint
        # or if we want to check dispatcher destinations, we can add that logic here
        
        if ($var(should_try_endpoint) > 0) {
            
                    # Extract endpoint identifier
                    # Try To header first (may have domain), fallback to Request-URI username
                    $var(endpoint_user) = $tU;
                    if ($var(endpoint_user) == "") {
                        $var(endpoint_user) = $rU;
                    }
                    
                    # Try to get domain from To header, but if it's an IP, use username-only lookup
                    $var(to_domain) = $(tu{uri.domain});
                    if ($var(to_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # To header has IP, not domain - will use username-only lookup
                        $var(endpoint_aor) = "";
                    } else if ($var(to_domain) != "") {
                        # To header has domain - use for exact match
                        $var(endpoint_aor) = $var(endpoint_user) + "@" + $var(to_domain);
                    } else {
                        # No domain in To header - will use username-only lookup
                        $var(endpoint_aor) = "";
                    }
                    
                    xlog("OPTIONS/NOTIFY from Asterisk $si, looking up endpoint AoR: $var(endpoint_aor) (user: $var(endpoint_user))\n");
                    
                    # Look up endpoint location from database
                    $var(found_endpoint) = 0;
                    
                    # First try exact match with domain (if we have a domain, not IP)
                    if ($var(endpoint_aor) != "") {
                        # Use string concatenation to interpolate variables into SQL query
                        $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor='" + $var(endpoint_aor) + "' AND expires > datetime('now')";
                        if (sql_query($var(query), "$avp(endpoint_ip)")) {
                            if ($(avp(endpoint_ip)[0]) != "") {
                                $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
                                # Now get the port
                                $var(query) = "SELECT contact_port FROM endpoint_locations WHERE aor='" + $var(endpoint_aor) + "' AND expires > datetime('now')";
                                if (sql_query($var(query), "$avp(endpoint_port)")) {
                                    $var(endpoint_port) = $(avp(endpoint_port)[0]);
                                }
                                
                                xlog("Database lookup result: IP=$var(endpoint_ip), Port=$var(endpoint_port)\n");
                                
                                # Validate IP and port
                                if ($var(endpoint_ip) != "") {
                                    if ($var(endpoint_port) == "") {
                                        $var(endpoint_port) = "5060";
                                    }
                                    
                                    # Construct destination URI directly using username and endpoint IP:port
                                    # Get username from Request-URI or To header
                                    $var(target_user) = $tU;
                                    if ($var(target_user) == "") {
                                        $var(target_user) = $rU;
                                    }
                                    
                                    # Build destination URI: sip:user@ip:port
                                    $du = "sip:" + $var(target_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
                                    # Construct proper Request-URI for routing
                                    $ru = $du;
                                    xlog("Routing $rm from Asterisk $si to endpoint $du (exact match), Request-URI=$ru\n");
                                    route(RELAY);
                                    exit;
                                }
                            }
                        }
                    }
                    
                    # Fallback: try lookup by username only (in case To header has IP instead of domain, or exact match failed)
                    xlog("Exact match failed or not attempted, trying username-only lookup for $var(endpoint_user)\n");
                    # Use string concatenation to interpolate variables into SQL query
                    $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(endpoint_user) + "@%' AND expires > datetime('now') LIMIT 1";
                    if (sql_query($var(query), "$avp(endpoint_ip)")) {
                        if ($(avp(endpoint_ip)[0]) != "") {
                            $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
                            # Get the port
                            $var(query) = "SELECT contact_port FROM endpoint_locations WHERE aor LIKE '" + $var(endpoint_user) + "@%' AND expires > datetime('now') LIMIT 1";
                            if (sql_query($var(query), "$avp(endpoint_port)")) {
                                $var(endpoint_port) = $(avp(endpoint_port)[0]);
                            }
                            
                            xlog("Database lookup result (username match): IP=$var(endpoint_ip), Port=$var(endpoint_port)\n");
                            
                            # Validate IP and port
                            if ($var(endpoint_ip) == "") {
                                xlog("L_ERR", "Invalid endpoint IP from database lookup (username match)\n");
                            } else {
                                if ($var(endpoint_port) == "") {
                                    $var(endpoint_port) = "5060";
                                }
                                
                                # Construct destination URI directly using username and endpoint IP:port
                                # Get username from To header (more reliable than Request-URI which might be invalid)
                                $var(target_user) = $tU;
                                if ($var(target_user) == "") {
                                    $var(target_user) = $rU;
                                }
                                
                                # Build destination URI: sip:user@ip:port
                                $du = "sip:" + $var(target_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
                                # Construct proper Request-URI for routing
                                $ru = $du;
                                xlog("Routing $rm from Asterisk $si to endpoint $du (username match), Request-URI=$ru\n");
                                route(RELAY);
                                exit;
                            }
                        }
                    }
                    
                    # Fallback: reply statelessly (health check works, but NAT pinhole won't stay open)
                    # For NOTIFY, we should try to route anyway or it will fail
                    xlog("L_WARN", "$rm from Asterisk $si to $var(endpoint_aor) - endpoint location not found in database (tried exact match and username match)\n");
                    if (is_method("OPTIONS")) {
                        sl_send_reply(200, "OK");
                    } else {
                        # For NOTIFY, try to route based on Contact header if available
                        # Extract IP and port from Contact header using regex
                        $var(notify_ip) = "";
                        $var(notify_port) = "";
                        if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                            $var(notify_ip) = $re;
                            if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                                $var(notify_port) = $re;
                            }
                        }
                        
                        if ($var(notify_ip) != "" && $var(notify_ip) != $si) {
                            $du = "sip:" + $tU + "@" + $var(notify_ip);
                            if ($var(notify_port) != "") {
                                $du = $du + ":" + $var(notify_port);
                            } else {
                                $du = $du + ":5060";
                            }
                            xlog("Routing $rm to $du (fallback from Contact header)\n");
                            route(RELAY);
                        } else {
                            sl_send_reply(404, "Not Found");
                        }
                    }
                    exit;
        }
        
        # If we get here, Request-URI doesn't look like an endpoint, continue normal routing
        xlog("OPTIONS/NOTIFY from $si - Request-URI doesn't look like endpoint, continuing normal routing\n");
    }
    
    # ---- Handle REGISTER to track endpoint locations ----
    if (is_method("REGISTER")) {
        xlog("REGISTER received from $si, Contact: $hdr(Contact), To: $hdr(To)\n");
        
        # Extract endpoint location from Contact header and store in database
        # This allows us to route OPTIONS from Asterisk back to endpoints
        # Check if Contact header exists and extract values
        if ($hdr(Contact) != "") {
            # Extract AoR from To header (user@domain)
            # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
            $var(endpoint_aor) = $tU + "@" + $(tu{uri.domain});
            
            # Extract IP and port - always use source IP/port for REGISTER (endpoint sends directly)
            # Contact header extraction is for NAT scenarios, but source is more reliable for REGISTER
            $var(endpoint_ip) = $si;
            $var(endpoint_port) = $sp;
            
            # Ensure port is set (default to 5060 if source port is missing)
            if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                $var(endpoint_port) = "5060";
            }
            
            # Try to extract from Contact header as fallback (for NAT scenarios)
            # Use regex to extract IP:port from Contact header string
            $var(contact_ip) = "";
            $var(contact_port) = "";
            
            # Extract IP address from Contact header (pattern: @IP:port or @IP)
            # Match IPv4 address after @ symbol
            if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                $var(contact_ip) = $re;
                
                # Extract port if present (pattern: :PORT after the IP)
                if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                    $var(contact_port) = $re;
                }
            }
            
            # Use Contact header values if they're valid and different from source (NAT scenario)
            if ($var(contact_ip) != "" && $var(contact_ip) != "0" && $var(contact_ip) != $si) {
                $var(endpoint_ip) = $var(contact_ip);
                xlog("Using Contact header IP ($var(contact_ip)) instead of source IP ($si) - possible NAT scenario\n");
            }
            if ($var(contact_port) != "" && $var(contact_port) != "0" && $var(contact_port) != $sp) {
                $var(endpoint_port) = $var(contact_port);
                xlog("Using Contact header port ($var(contact_port)) instead of source port ($sp)\n");
            }
            
            # Final validation - ensure we have valid values
            if ($var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
                $var(endpoint_ip) = $si;
            }
            if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                $var(endpoint_port) = $sp;
                if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                    $var(endpoint_port) = "5060";
                }
            }
            
            xlog("Contact extraction: source IP=$si, source port=$sp, extracted IP=$var(contact_ip), extracted port=$var(contact_port), final IP=$var(endpoint_ip), Port=$var(endpoint_port), full Contact=$hdr(Contact)\n");
            
            # Validate extracted IP and port before storing
            if ($var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
                xlog("L_ERR", "Failed to extract IP - source IP=$si, Contact: $hdr(Contact), endpoint_ip=$var(endpoint_ip)\n");
            } else if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                xlog("L_ERR", "Failed to extract port - source port=$sp, endpoint_port=$var(endpoint_port)\n");
            } else {
                # Get expires from Expires header or Contact header
                $var(expires) = $hdr(Expires);
                if ($var(expires) == "") {
                    $var(expires) = "3600";  # Default 1 hour
                }
                
                # Ensure expires is a valid integer
                $var(expires_int) = $var(expires);
                if ($var(expires_int) == "" || $var(expires_int) == "0") {
                    $var(expires_int) = "3600";
                }
                
                # Use source IP/port directly - ensure we have valid values
                $var(final_ip) = $si;
                $var(final_port) = $sp;
                if ($var(final_port) == "" || $var(final_port) == "0") {
                    $var(final_port) = "5060";
                }
                
                # Ensure expires is a valid integer
                if ($var(expires_int) == "" || $var(expires_int) == "0") {
                    $var(expires_int) = "3600";
                }
                
                xlog("Extracted endpoint info: AoR=$var(endpoint_aor), IP=$var(final_ip), Port=$var(final_port), Expires=$var(expires_int)\n");
                
                # Store/update endpoint location in database
                # Calculate expiration time: current time + expires seconds
                # Use SQLite's datetime modifier syntax: datetime('now', '+N seconds')
                # Note: sql_query() returns false for INSERT statements (no rows returned),
                # but the INSERT still succeeds. We execute it and log the attempt.
                $var(query) = "INSERT OR REPLACE INTO endpoint_locations (aor, contact_ip, contact_port, expires) VALUES ('" + $var(endpoint_aor) + "', '" + $var(final_ip) + "', '" + $var(final_port) + "', datetime('now', '+" + $var(expires_int) + " seconds'))";
                xlog("SQL query: $var(query)\n");
                # Execute INSERT - return value is false for INSERT (no rows), but query succeeds
                sql_query($var(query), "$avp(reg_result)");
                xlog("Stored endpoint location: $var(endpoint_aor) -> $var(final_ip):$var(final_port) (expires in $var(expires_int) seconds)\n");
            }
        } else {
            xlog("L_WARN", "REGISTER without Contact header - cannot track endpoint location\n");
        }
        # Continue to DOMAIN_CHECK to forward REGISTER to Asterisk
    }

    route(DOMAIN_CHECK);
}

####### Domain validation / door-knocker protection ########

route[DOMAIN_CHECK] {

    # OpenSIPS: Request-URI domain is $rd (lowercase), not $rD
    $var(domain) = $rd;

    if ($var(domain) == "") {
        exit;
    }

    # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
    # This handles INVITE from Asterisk to endpoints (e.g., sip:402@192.168.1.232:5060)
    # Note: $rd might include port (e.g., 192.168.1.138:56931), so we check just the IP part
    # Extract just the IP address part (before any colon)
    $var(request_domain) = $rd;
    xlog("DEBUG: Checking endpoint detection - rU=$rU, rd=$rd, request_domain=$var(request_domain), full URI=$ru\n");
    if ($var(request_domain) =~ "^([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
        $var(request_ip) = $re;
        xlog("INVITE Request-URI looks like endpoint: $rU@$var(request_domain) (IP=$var(request_ip)), attempting endpoint lookup\n");
        
        # Extract username from Request-URI
        $var(endpoint_user) = $rU;
        xlog("Extracted endpoint username: $var(endpoint_user)\n");
        
        # Try username-only lookup in endpoint_locations
        # First get the full AoR to extract the domain
        $var(query) = "SELECT aor FROM endpoint_locations WHERE aor LIKE '" + $var(endpoint_user) + "@%' AND expires > datetime('now') LIMIT 1";
        xlog("Endpoint lookup query: $var(query)\n");
        if (sql_query($var(query), "$avp(endpoint_aor)")) {
            xlog("Endpoint AoR query returned result, checking if found\n");
            if ($(avp(endpoint_aor)[0]) != "") {
                $var(endpoint_aor) = $(avp(endpoint_aor)[0]);
                # The AoR already contains user@domain, so we can use it directly for Request-URI
                # Just need to extract domain for validation
                # Try regex - if it doesn't work, we'll use the AoR directly
                $var(endpoint_domain) = "";
                if ($var(endpoint_aor) =~ "@(.+)") {
                    $var(endpoint_domain) = $re;
                }
                
                # If regex failed, try to get domain from To header as fallback
                if ($var(endpoint_domain) == "" || $var(endpoint_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                    $var(to_domain) = $(tu{uri.domain});
                    if ($var(to_domain) != "" && $var(to_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        $var(endpoint_domain) = $var(to_domain);
                        xlog("Using domain from To header: $var(endpoint_domain)\n");
                    }
                }
                
                xlog("AoR=$var(endpoint_aor), extracted domain=$var(endpoint_domain)\n");
                
                # Now get the IP
                $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor='" + $var(endpoint_aor) + "' AND expires > datetime('now')";
                if (sql_query($var(query), "$avp(endpoint_ip)")) {
                    if ($(avp(endpoint_ip)[0]) != "") {
                        $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
                        # Get the port
                        $var(query) = "SELECT contact_port FROM endpoint_locations WHERE aor='" + $var(endpoint_aor) + "' AND expires > datetime('now')";
                        if (sql_query($var(query), "$avp(endpoint_port)")) {
                            $var(endpoint_port) = $(avp(endpoint_port)[0]);
                        }
                        
                        xlog("Endpoint lookup result: AoR=$var(endpoint_aor), Domain=$var(endpoint_domain), IP=$var(endpoint_ip), Port=$var(endpoint_port)\n");
                        
                        # Validate IP and port
                        if ($var(endpoint_ip) != "") {
                            if ($var(endpoint_port) == "") {
                                $var(endpoint_port) = "5060";
                            }
                            
                            # Build destination URI with IP:port for routing (NAT traversal)
                    $du = "sip:" + $var(endpoint_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
                    # Construct Request-URI using the AoR directly (it already has user@domain format)
                    # This is simpler and more reliable than trying to extract domain
                    if ($var(endpoint_aor) != "" && $var(endpoint_aor) =~ "@" && $var(endpoint_aor) !~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # AoR has domain (not IP), use it directly
                        $ru = "sip:" + $var(endpoint_aor);
                        xlog("Using AoR directly in Request-URI: $ru\n");
                        # Note: To header still contains IP from Asterisk, but Request-URI has domain
                        # Most endpoints check Request-URI for matching, not To header
                        # If endpoint rejects due to To header, we may need to modify it using textops
                    } else if ($var(endpoint_domain) != "" && $var(endpoint_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # Fallback: construct from extracted domain
                        $ru = "sip:" + $var(endpoint_user) + "@" + $var(endpoint_domain);
                        xlog("Using extracted domain in Request-URI: $ru\n");
                    } else {
                        # Last resort: use IP if domain not found
                        xlog("L_WARN", "Cannot determine domain, using IP in Request-URI: $du\n");
                        $ru = $du;
                    }
                            xlog("Routing INVITE from $si to endpoint: dest=$du, Request-URI=$ru (endpoint lookup)\n");
                            route(RELAY);
                            exit;
                        }
                    }
                } else {
                    xlog("L_WARN", "Endpoint AoR query returned empty result for user=$var(endpoint_user)\n");
                }
            } else {
                xlog("L_WARN", "Endpoint AoR query failed or returned no rows for user=$var(endpoint_user)\n");
            }
        } else {
            xlog("L_WARN", "Endpoint AoR query execution failed for user=$var(endpoint_user)\n");
        }
        
        # If endpoint lookup failed, log and send 404
        xlog("L_WARN", "Endpoint lookup failed for $var(endpoint_user)@$rd - no matching endpoint found in database or lookup query failed\n");
        # Send 404 since we can't route to endpoint
        sl_send_reply(404, "Endpoint Not Found");
        exit;
    }

    # Optional extra hardening: domain consistency
    # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
    if ($rd != $(tu{uri.domain})) {
        xlog("L_WARN", "R-URI / To mismatch domain=$rd src=$si\n");
        exit;
    }

    # Lookup dispatcher set for this domain
    # Use string concatenation to interpolate variable into SQL query
    $var(query) = "SELECT dispatcher_setid FROM sip_domains WHERE domain='" + $var(domain) + "' AND enabled=1";
    if (!sql_query($var(query), "$avp(domain_setid)")) {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (query failed)\n");
        exit;
    }
    
    # Check if domain was found
    if ($(avp(domain_setid)[0]) == "") {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (not found)\n");
        exit;
    }
    
    # Get the dispatcher_setid from query result (first row, first column)
    $var(setid) = $(avp(domain_setid)[0]);

    route(TO_DISPATCHER);
}

####### Health-aware routing ########

route[TO_DISPATCHER] {

    # Select a healthy Asterisk from the dispatcher set
    if (!ds_select_dst($var(setid), 4)) {
        xlog("L_ERR", "No healthy Asterisk nodes for domain=$rd setid=$var(setid)\n");
        sl_send_reply(503, "Service Unavailable");
        exit;
    }

    xlog("Routing to $du for domain=$rd setid=$var(setid) method=$rm Request-URI=$ru\n");

    record_route();

    # Arm failure route to handle transaction failures
    t_on_failure("1");

    # OpenSIPS transaction handling - this is where we expect better behavior
    # than Kamailio for INVITE transactions
    if (!t_relay()) {
        xlog("L_ERR", "t_relay() failed for $du method=$rm Request-URI=$ru\n");
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
        exit;
    }

    xlog("t_relay() succeeded for $du method=$rm, transaction created\n");
    # For INVITE, ensure transaction stays active
    # The transaction module should handle this automatically, but log it
    if (is_method("INVITE")) {
        xlog("INVITE transaction created, waiting for response from $du\n");
    }
    exit;
}

####### In-dialog handling ########

route[WITHINDLG] {
    xlog("In-dialog request: $rm from $si to $ru (Call-ID: $hdr(Call-ID), To-tag=$tt)\n");

    # Check for Record-Route header and follow it
    if (loose_route()) {
        xlog("loose_route() succeeded for $rm, following Record-Route\n");
        route(RELAY);
        exit;
    }

    # If loose_route() fails, try to route based on transaction state
    # For BYE, we need to find the original transaction
    if (is_method("BYE")) {
        xlog("BYE request - loose_route() failed, checking transaction state\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("BYE matches existing transaction, relaying\n");
            route(RELAY);
            exit;
        } else {
            xlog("L_WARN", "BYE received but no matching transaction found, trying to relay anyway\n");
            # Try to relay even without transaction match
            route(RELAY);
            exit;
        }
    }

    xlog("L_WARN", "In-dialog request $rm - loose_route() failed and no transaction match\n");
    sl_send_reply(404, "Not Here");
    exit;
}

route[RELAY] {
    # Arm failure route to handle transaction failures
    t_on_failure("1");
    if (!t_relay()) {
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
    }
    exit;
}

####### Response handling (for debugging) ########

onreply_route {
    xlog("Response received: $rs $rr from $si (method=$rm, CSeq=$hdr(CSeq), To-tag=$tt, Contact=$hdr(Contact))\n");
    
    # Detailed SDP logging for 200 OK responses
    # This helps diagnose why one direction works and the other doesn't
    if ($rs == 200 && $hdr(Content-Type) =~ "application/sdp") {
        # Extract username from To header to identify the callee
        $var(to_user) = $(tu{uri.user});
        $var(from_user) = $(fu{uri.user});
        
        xlog("200 OK with SDP: From=$var(from_user), To=$var(to_user), Source=$si\n");
        
        # Check if this is from Asterisk (192.168.1.91)
        if ($si == "192.168.1.91") {
            xlog("200 OK from Asterisk - checking SDP and endpoint info\n");
            
            if ($var(to_user) != "") {
                # Look up endpoint IP from database for the callee (To header)
                $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(to_user) + "@%' AND expires > datetime('now') LIMIT 1";
                if (sql_query($var(query), "$avp(endpoint_ip)")) {
                    if ($(avp(endpoint_ip)[0]) != "") {
                        $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
                        xlog("Callee endpoint IP should be: $var(endpoint_ip) (user=$var(to_user))\n");
                        xlog("L_WARN", "Asterisk likely rewrote SDP to use 192.168.1.91 instead of $var(endpoint_ip)\n");
                        xlog("L_WARN", "SDP modification disabled - this may cause RTP issues if Asterisk doesn't relay media\n");
                    }
                }
                
                # Also check the caller's endpoint IP
                if ($var(from_user) != "") {
                    $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(from_user) + "@%' AND expires > datetime('now') LIMIT 1";
                    if (sql_query($var(query), "$avp(caller_ip)")) {
                        if ($(avp(caller_ip)[0]) != "") {
                            $var(caller_ip) = $(avp(caller_ip)[0]);
                            xlog("Caller endpoint IP: $var(caller_ip) (user=$var(from_user))\n");
                        }
                    }
                }
            }
        } else {
            # This is from an endpoint directly (not through Asterisk)
            xlog("200 OK directly from endpoint $si (user=$var(to_user)) - SDP should be correct\n");
        }
    }
    
    # Log transaction state for debugging
    if ($rs >= 100 && $rs < 200) {
        xlog("Provisional response $rs received, transaction should remain active\n");
        # For provisional responses, explicitly exit to let transaction module handle forwarding
        # The transaction module will automatically forward and keep transaction alive
        exit;
    } else if ($rs >= 200 && $rs < 300) {
        xlog("Final success response $rs received\n");
        exit;
    } else if ($rs >= 300) {
        xlog("Final error response $rs received\n");
        exit;
    }
    # If we get here, exit to let transaction module handle it
    exit;
}

failure_route[1] {
    xlog("L_ERR", "Transaction failure: method=$rm, Call-ID: $hdr(Call-ID), From=$fu, To=$tu, Response code=$rs, Reason=$rr\n");
    # Log more details about the failure
    if ($rs == 408) {
        xlog("L_ERR", "408 Request Timeout generated - transaction timed out waiting for response\n");
    }
    # t_relay will handle forwarding the failure response automatically
    exit;
}

####### Dispatcher events (visibility) ########

# Note: Event route names may vary by OpenSIPS version
# If these don't work, check your OpenSIPS version's event names
# Common alternatives: dispatcher:dst-up, E_DISPATCHER_DST_UP, etc.
# Commented out - event route syntax may need adjustment for your OpenSIPS version
# event_route[dispatcher:dst-up] {
#     xlog("Asterisk UP: $du\n");
# }
# 
# event_route[dispatcher:dst-down] {
#     xlog("L_WARN", "Asterisk DOWN: $du\n");
# }

