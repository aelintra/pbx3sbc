#!opensips
#
# OpenSIPS SIP Edge Router Configuration Template
# This configuration replicates the functionality from Kamailio while
# addressing the INVITE transaction handling issues encountered with Kamailio
#
# Based on requirements in REQUIREMENTS-FOR-OPENSIPS.md
# Troubleshooting notes in TROUBLESHOOTING-OPTIONS-ROUTING.md
#

####### Global Parameters #########

# OpenSIPS uses different parameter names than Kamailio
# Debug level can be set via command line: opensips -D 3
# Or via modparam for specific modules

# Module path (Ubuntu/Debian package location)
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules"

# Listen on all interfaces (socket replaces deprecated listen)
socket=udp:0.0.0.0:5060

# Set advertised address (replace with your OpenSIPS server's IP address)
# This fixes the Via header showing 0.0.0.0
advertised_address="192.168.1.95"

####### Modules ########

# Core modules
# Note: is_method(), has_totag() are built into OpenSIPS core
# Note: siputils and sanity modules don't exist in OpenSIPS - functions are built-in
# Note: pv (pseudo-variables) and xlog are built into OpenSIPS core
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
# Transport protocol - required for socket binding
loadmodule "proto_udp.so"
loadmodule "db_sqlite.so"
loadmodule "dispatcher.so"
loadmodule "sipmsgops.so"

####### Module Parameters ########

# --- Dispatcher (health checks via SIP OPTIONS) ---
# OpenSIPS uses db_sqlite directly for dispatcher
# Note: OpenSIPS doesn't have sql_query() like Kamailio - need alternative approach
modparam("dispatcher", "db_url",
    "sqlite:///var/lib/opensips/routing.db")

modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_threshold", 2)
# Note: ds_inactive_threshold doesn't exist in OpenSIPS dispatcher module
# Note: ds_ping_reply_codes is called options_reply_codes in OpenSIPS
modparam("dispatcher", "options_reply_codes", "200")

# --- Transaction timers ---
# Note: fr_timer is not a modparam in OpenSIPS - transaction timeouts are handled differently
# restart_fr_on_each_reply: reset final response timer on each provisional response
modparam("tm", "restart_fr_on_each_reply", 1)
# T1_timer: initial retransmission period (2 seconds = 2000ms)
# Note: OpenSIPS uses T1_timer instead of retr_timer1
modparam("tm", "T1_timer", 2000)
# T2_timer: maximum retransmission period (8 seconds = 8000ms)
# Note: OpenSIPS uses T2_timer instead of retr_timer2
modparam("tm", "T2_timer", 8000)

# --- Response handling ---
# OpenSIPS handles responses differently - ensure proper forwarding
# Note: onreply_avp_mode may not exist in all versions, remove if it causes issues

####### Routing Logic ########

route {
    # ---- Log ALL requests at the very start for debugging ----
    xlog("REQUEST: $rm from $si:$sp to $ru (Call-ID: $hdr(Call-ID))\n");

    # ---- Basic hygiene ----
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    # Note: sanity_check() module not available in OpenSIPS
    # Basic validation is handled by core parsing
    # if (!sanity_check("1511", "7")) {
    #     xlog("L_WARN", "Malformed SIP from $si\n");
    #     exit;
    # }

    # ---- Drop known scanners ----
    if ($ua =~ "sipvicious|friendly-scanner|sipcli|nmap") {
        exit;
    }

    # ---- In-dialog requests ----
    # Check if To tag exists (in-dialog request)
    # OpenSIPS uses $to_tag pseudo-variable (equivalent to Kamailio's $tt)
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    # ---- Allowed methods only ----
    if (!is_method("REGISTER|INVITE|ACK|BYE|CANCEL|OPTIONS|NOTIFY|SUBSCRIBE")) {
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }

    # ---- Handle CANCEL early (before domain check) ----
    # CANCEL needs to match existing INVITE transaction
    if (is_method("CANCEL")) {
        xlog("CANCEL received from $si:$sp for Call-ID: $hdr(Call-ID), CSeq=$hdr(CSeq), From=$fu, To=$tu\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("CANCEL matches existing transaction, forwarding to cancel INVITE\n");
        } else {
            xlog("L_WARN", "CANCEL received but no matching transaction found\n");
            sl_send_reply(481, "Call/Transaction Does Not Exist");
            exit;
        }
        # Forward CANCEL to cancel the INVITE transaction
        route(RELAY);
        exit;
    }

    # ---- Log INVITE requests for debugging ----
    if (is_method("INVITE")) {
        xlog("INVITE received from $si:$sp to $ru (From: $fu, To: $tu)\n");
    }

    # ---- Handle OPTIONS and NOTIFY from Asterisk backends (to endpoints) ----
    # Asterisk sends OPTIONS to registered endpoints for health checks and NAT keepalive
    # Asterisk sends NOTIFY for event notifications (e.g., message waiting indicators)
    # These need to be routed back to the actual endpoint IP
    if (is_method("OPTIONS|NOTIFY")) {
        # Check if this is coming from a known dispatcher destination (Asterisk backend)
        # Query database to see if source IP matches any dispatcher destination
        $var(source_ip) = $si;
        xlog("OPTIONS/NOTIFY received from $si, checking if from dispatcher\n");
        
        # Extract IP from destination field and compare with source IP
        # Destination format can be: just IP (192.168.1.91), sip:IP:PORT, or sip:IP
        # Handle all formats by checking if destination starts with "sip:" or is just an IP
        # TODO: OpenSIPS doesn't have sql_query() - need to use OpenSIPS database module
        # First, let's see what destinations exist (debug only - remove after testing)
        # if (sql_query("cb", "SELECT destination FROM dispatcher LIMIT 5", "debug_dest")) {
        #     if ($dbr(debug_dest=>rows) > 0) {
        #         xlog("Sample dispatcher destinations in DB: $dbr(debug_dest=>[0,0])\n");
        #     }
        #     sql_result_free("debug_dest");
        # }
        
        # TODO: OpenSIPS doesn't have sql_query() - need to use OpenSIPS database module
        # Now check if source IP matches any dispatcher destination
        # Handle formats: IP (192.168.1.91), IP:PORT (192.168.1.91:5060), sip:IP, sip:IP:PORT
        # Extract IP from destination and compare with source IP
        # For now, skip this check - OPTIONS/NOTIFY from Asterisk will continue to normal routing
        $var(match_count) = 0;
        # if (sql_query("cb", "SELECT COUNT(*) FROM dispatcher WHERE CASE WHEN destination LIKE 'sip:%' THEN CASE WHEN instr(substr(destination, 5), ':') > 0 THEN substr(destination, 5, instr(substr(destination, 5), ':') - 1) ELSE substr(destination, 5) END WHEN instr(destination, ':') > 0 AND destination NOT LIKE 'sip:%' THEN substr(destination, 1, instr(destination, ':') - 1) ELSE destination END = '$var(source_ip)'", "dispatcher_check")) {
        #     if ($dbr(dispatcher_check=>rows) > 0) {
        #         $var(match_count) = $dbr(dispatcher_check=>[0,0]);
        #         xlog("Dispatcher check result: found $var(match_count) matching destinations for IP $var(source_ip)\n");
        #         sql_result_free("dispatcher_check");
        if ($var(match_count) > 0) {
            
                    # Extract endpoint identifier from To header (AoR)
                    # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
                    $var(endpoint_aor) = $tU + "@" + $(tu{uri.domain});
                    $var(endpoint_user) = $tU;
                    
                    xlog("OPTIONS/NOTIFY from Asterisk $si, looking up endpoint AoR: $var(endpoint_aor) (user: $var(endpoint_user))\n");
                    
                    # TODO: OpenSIPS doesn't have sql_query() - need to use OpenSIPS database module
                    # Look up endpoint location from database
                    # First try exact match with domain
                    # For now, skip database lookup - will need to implement with OpenSIPS database module
                    xlog("L_WARN", "Database lookup for endpoint $var(endpoint_aor) disabled - sql_query() not available in OpenSIPS\n");
                    # if (sql_query("cb", "SELECT contact_ip, contact_port FROM endpoint_locations WHERE aor='$var(endpoint_aor)' AND expires > datetime('now')", "endpoint_result")) {
                    #     if ($dbr(endpoint_result=>rows) > 0) {
                    #         $var(endpoint_ip) = $dbr(endpoint_result=>[0,0]);
                    #         $var(endpoint_port) = $dbr(endpoint_result=>[0,1]);
                    #         sql_result_free("endpoint_result");
                    #         
                    #         xlog("Database lookup result: IP=$var(endpoint_ip), Port=$var(endpoint_port)\n");
                    #         
                    #         # Validate IP and port
                    #         if ($var(endpoint_ip) == $null || $var(endpoint_ip) == "") {
                    #             xlog("L_ERR", "Invalid endpoint IP from database lookup\n");
                    #         } else {
                    #             if ($var(endpoint_port) == $null || $var(endpoint_port) == "") {
                    #                 $var(endpoint_port) = "5060";
                    #             }
                    #             
                    #             # Construct destination URI directly using username and endpoint IP:port
                    #             # Get username from Request-URI or To header
                    #             $var(target_user) = $tU;
                    #             if ($var(target_user) == $null || $var(target_user) == "") {
                    #                 $var(target_user) = $rU;
                    #             }
                    #             
                    #             # Build destination URI: sip:user@ip:port
                    #             $du = "sip:" + $var(target_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
                    #             # Construct proper Request-URI for routing
                    #             $ru = $du;
                    #             xlog("Routing $rm from Asterisk $si to endpoint $du (exact match), Request-URI=$ru\n");
                    #             route(RELAY);
                    #             exit;
                    #         }
                    #     }
                    #     sql_result_free("endpoint_result");
                    #     
                    #     # Fallback: try lookup by username only (in case To header has IP instead of domain)
                    #     xlog("Exact match failed, trying username-only lookup for $var(endpoint_user)\n");
                    #     if (sql_query("cb", "SELECT contact_ip, contact_port FROM endpoint_locations WHERE aor LIKE '$var(endpoint_user)@%' AND expires > datetime('now') LIMIT 1", "endpoint_result")) {
                    #         if ($dbr(endpoint_result=>rows) > 0) {
                    #             $var(endpoint_ip) = $dbr(endpoint_result=>[0,0]);
                    #             $var(endpoint_port) = $dbr(endpoint_result=>[0,1]);
                    #             sql_result_free("endpoint_result");
                    #             
                    #             xlog("Database lookup result (username match): IP=$var(endpoint_ip), Port=$var(endpoint_port)\n");
                    #             
                    #             # Validate IP and port
                    #             if ($var(endpoint_ip) == $null || $var(endpoint_ip) == "") {
                    #                 xlog("L_ERR", "Invalid endpoint IP from database lookup (username match)\n");
                    #             } else {
                    #                 if ($var(endpoint_port) == $null || $var(endpoint_port) == "") {
                    #                     $var(endpoint_port) = "5060";
                    #                 }
                    #                 
                    #                 # Construct destination URI directly using username and endpoint IP:port
                    #                 # Get username from To header (more reliable than Request-URI which might be invalid)
                    #                 $var(target_user) = $tU;
                    #                 if ($var(target_user) == $null || $var(target_user) == "") {
                    #                     $var(target_user) = $rU;
                    #                 }
                    #                 
                    #                 # Build destination URI: sip:user@ip:port
                    #                 $du = "sip:" + $var(target_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
                    #                 # Construct proper Request-URI for routing
                    #                 $ru = $du;
                    #                 xlog("Routing $rm from Asterisk $si to endpoint $du (username match), Request-URI=$ru\n");
                    #                 route(RELAY);
                    #                 exit;
                    #             }
                    #         }
                    #         sql_result_free("endpoint_result");
                    #     }
                    # }
                    
                    # Fallback: reply statelessly (health check works, but NAT pinhole won't stay open)
                    # For NOTIFY, we should try to route anyway or it will fail
                    xlog("L_WARN", "$rm from Asterisk $si to $var(endpoint_aor) - endpoint location not found in database (tried exact match and username match)\n");
                    if (is_method("OPTIONS")) {
                        sl_send_reply(200, "OK");
                    } else {
                        # For NOTIFY, try to route based on Contact header if available
                        # Extract IP and port from Contact header using regex
                        $var(notify_ip) = "";
                        $var(notify_port) = "";
                        if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                            $var(notify_ip) = $re;
                            if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                                $var(notify_port) = $re;
                            }
                        }
                        
                        if ($var(notify_ip) != "" && $var(notify_ip) != $si) {
                            $du = "sip:" + $tU + "@" + $var(notify_ip);
                            if ($var(notify_port) != "") {
                                $du = $du + ":" + $var(notify_port);
                            } else {
                                $du = $du + ":5060";
                            }
                            xlog("Routing $rm to $du (fallback from Contact header)\n");
                            route(RELAY);
                        } else {
                            sl_send_reply(404, "Not Found");
                        }
                    }
                    exit;
                } else {
                    xlog("OPTIONS/NOTIFY from $si is not from a known dispatcher destination (match_count=0), continuing normal routing\n");
                }
                # } else {
                #     xlog("L_WARN", "Dispatcher check query returned no rows for IP $si\n");
                #     sql_result_free("dispatcher_check");
                # }
        # } else {
        #     xlog("L_WARN", "Failed to query dispatcher table for source IP $si\n");
        # }
    }
    
    # ---- Handle REGISTER to track endpoint locations ----
    if (is_method("REGISTER")) {
        xlog("REGISTER received from $si, Contact: $hdr(Contact), To: $hdr(To)\n");
        
        # Extract endpoint location from Contact header and store in database
        # This allows us to route OPTIONS from Asterisk back to endpoints
        # Check if Contact header exists and extract values
        if ($hdr(Contact) != "") {
            # Extract AoR from To header (user@domain)
            # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
            $var(endpoint_aor) = $tU + "@" + $(tu{uri.domain});
            
            # Extract IP and port from Contact header
            # Contact format: <sip:user@ip:port;params> or sip:user@ip:port
            # Primary: Use source IP/port since REGISTER comes directly from endpoint
            $var(endpoint_ip) = $si;
            $var(endpoint_port) = $sp;
            
            # Try to extract from Contact header as fallback (for NAT scenarios)
            # Use regex to extract IP:port from Contact header string
            # Handle cases where Contact header has angle brackets or complex parameters
            $var(contact_ip) = "";
            $var(contact_port) = "";
            
            # Extract IP address from Contact header (pattern: @IP:port or @IP)
            # Match IPv4 address after @ symbol
            if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                $var(contact_ip) = $re;
                
                # Extract port if present (pattern: :PORT after the IP)
                if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                    $var(contact_port) = $re;
                }
            }
            
            # Use Contact header values if they're valid and different from source (NAT scenario)
            if ($var(contact_ip) != "" && $var(contact_ip) != "0" && $var(contact_ip) != $si) {
                $var(endpoint_ip) = $var(contact_ip);
                xlog("Using Contact header IP ($var(contact_ip)) instead of source IP ($si) - possible NAT scenario\n");
            }
            if ($var(contact_port) != "" && $var(contact_port) != "0" && $var(contact_port) != $sp) {
                $var(endpoint_port) = $var(contact_port);
                xlog("Using Contact header port ($var(contact_port)) instead of source port ($sp)\n");
            }
            
            xlog("Contact extraction: source IP=$si, source port=$sp, extracted IP=$var(contact_ip), extracted port=$var(contact_port), final IP=$var(endpoint_ip), Port=$var(endpoint_port), full Contact=$hdr(Contact)\n");
            
            # Validate extracted IP
            if ($var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
                xlog("L_ERR", "Failed to extract IP - source IP=$si, Contact: $hdr(Contact)\n");
            } else {
                if ($var(endpoint_port) == "") {
                    $var(endpoint_port) = "5060";
                }
                
                # Get expires from Expires header or Contact header
                $var(expires) = $hdr(Expires);
                if ($var(expires) == "") {
                    $var(expires) = "3600";  # Default 1 hour
                }
                
                xlog("Extracted endpoint info: AoR=$var(endpoint_aor), IP=$var(endpoint_ip), Port=$var(endpoint_port), Expires=$var(expires)\n");
                
                # TODO: OpenSIPS doesn't have sql_query() - need to use OpenSIPS database module
                # Store/update endpoint location in database
                # Use SQLite's datetime functions to calculate expiration (current time + expires seconds)
                xlog("L_WARN", "Endpoint location tracking disabled - sql_query() not available in OpenSIPS\n");
                # if (sql_query("cb", "INSERT OR REPLACE INTO endpoint_locations (aor, contact_ip, contact_port, expires) VALUES ('$var(endpoint_aor)', '$var(endpoint_ip)', '$var(endpoint_port)', datetime(strftime('%s', 'now') + $var(expires), 'unixepoch'))", "reg_result")) {
                #     sql_result_free("reg_result");
                #     xlog("Successfully tracked endpoint location: $var(endpoint_aor) -> $var(endpoint_ip):$var(endpoint_port) (expires in $var(expires) seconds)\n");
                # } else {
                #     xlog("L_ERR", "Failed to store endpoint location: $var(endpoint_aor) -> $var(endpoint_ip):$var(endpoint_port) (SQL query failed)\n");
                # }
            }
        } else {
            xlog("L_WARN", "REGISTER without Contact header - cannot track endpoint location\n");
        }
        # Continue to DOMAIN_CHECK to forward REGISTER to Asterisk
    }

    route(DOMAIN_CHECK);
}

####### Domain validation / door-knocker protection ########

route[DOMAIN_CHECK] {

    # OpenSIPS: Request-URI domain is $rd (lowercase), not $rD
    $var(domain) = $rd;

    if ($var(domain) == "") {
        exit;
    }

    # Optional extra hardening: domain consistency
    # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
    if ($rd != $(tu{uri.domain})) {
        xlog("L_WARN", "R-URI / To mismatch domain=$rd src=$si\n");
        exit;
    }

    # TODO: OpenSIPS doesn't have sql_query() - need to use OpenSIPS database module
    # Lookup dispatcher set for this domain
    # For now, use a default setid - this will need to be replaced with OpenSIPS database module
    xlog("L_WARN", "Domain lookup disabled - sql_query() not available in OpenSIPS, using default setid=1\n");
    $var(setid) = 1;
    # if (!sql_query("cb", "SELECT dispatcher_setid FROM sip_domains WHERE domain='$var(domain)' AND enabled=1", "domain_result")) {
    #     xlog("L_NOTICE",
    #          "Door-knock blocked: domain=$var(domain) src=$si (query failed)\n");
    #     exit;
    # }
    # 
    # # Check if domain was found
    # if ($dbr(domain_result=>rows) == 0) {
    #     sql_result_free("domain_result");
    #     xlog("L_NOTICE",
    #          "Door-knock blocked: domain=$var(domain) src=$si (not found)\n");
    #     exit;
    # }
    # 
    # # Get the dispatcher_setid from query result (first row, first column)
    # $var(setid) = $dbr(domain_result=>[0,0]);
    # sql_result_free("domain_result");

    route(TO_DISPATCHER);
}

####### Health-aware routing ########

route[TO_DISPATCHER] {

    # Select a healthy Asterisk from the dispatcher set
    if (!ds_select_dst($var(setid), 4)) {
        xlog("L_ERR", "No healthy Asterisk nodes for domain=$rd setid=$var(setid)\n");
        sl_send_reply(503, "Service Unavailable");
        exit;
    }

    xlog("Routing to $du for domain=$rd setid=$var(setid) method=$rm Request-URI=$ru\n");

    record_route();

    # Arm failure route to handle transaction failures
    t_on_failure("1");

    # OpenSIPS transaction handling - this is where we expect better behavior
    # than Kamailio for INVITE transactions
    if (!t_relay()) {
        xlog("L_ERR", "t_relay() failed for $du method=$rm Request-URI=$ru\n");
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
        exit;
    }

    xlog("t_relay() succeeded for $du method=$rm, transaction created\n");
    # For INVITE, ensure transaction stays active
    # The transaction module should handle this automatically, but log it
    if (is_method("INVITE")) {
        xlog("INVITE transaction created, waiting for response from $du\n");
    }
    exit;
}

####### In-dialog handling ########

route[WITHINDLG] {
    xlog("In-dialog request: $rm from $si to $ru (Call-ID: $hdr(Call-ID))\n");

    if (loose_route()) {
        route(RELAY);
        exit;
    }

    sl_send_reply(404, "Not Here");
    exit;
}

route[RELAY] {
    # Arm failure route to handle transaction failures
    t_on_failure("1");
    if (!t_relay()) {
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
    }
    exit;
}

####### Response handling (for debugging) ########

onreply_route {
    xlog("Response received: $rs $rr from $si (method=$rm, CSeq=$hdr(CSeq), To-tag=$tt, Contact=$hdr(Contact))\n");
    # Log transaction state for debugging
    if ($rs >= 100 && $rs < 200) {
        xlog("Provisional response $rs received, transaction should remain active\n");
        # For provisional responses, explicitly exit to let transaction module handle forwarding
        # The transaction module will automatically forward and keep transaction alive
        exit;
    } else if ($rs >= 200 && $rs < 300) {
        xlog("Final success response $rs received\n");
        exit;
    } else if ($rs >= 300) {
        xlog("Final error response $rs received\n");
        exit;
    }
    # If we get here, exit to let transaction module handle it
    exit;
}

failure_route[1] {
    xlog("L_ERR", "Transaction failure: method=$rm, Call-ID: $hdr(Call-ID), From=$fu, To=$tu, Response code=$rs, Reason=$rr\n");
    # Log more details about the failure
    if ($rs == 408) {
        xlog("L_ERR", "408 Request Timeout generated - transaction timed out waiting for response\n");
    }
    # t_relay will handle forwarding the failure response automatically
    exit;
}

####### Dispatcher events (visibility) ########

# Note: Event route names may vary by OpenSIPS version
# If these don't work, check your OpenSIPS version's event names
# Common alternatives: dispatcher:dst-up, E_DISPATCHER_DST_UP, etc.
# Commented out - event route syntax may need adjustment for your OpenSIPS version
# event_route[dispatcher:dst-up] {
#     xlog("Asterisk UP: $du\n");
# }
# 
# event_route[dispatcher:dst-down] {
#     xlog("L_WARN", "Asterisk DOWN: $du\n");
# }

