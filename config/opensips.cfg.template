#!opensips
#
# OpenSIPS SIP Edge Router Configuration Template
# This configuration provides SIP edge routing functionality for Asterisk PBX backends
#
# Based on requirements in REQUIREMENTS-FOR-OPENSIPS.md
# Troubleshooting notes in TROUBLESHOOTING-OPTIONS-ROUTING.md
#

####### Global Parameters #########

# The default log_level is usually enough for most things but you can increase
# it here for lower levels of visibility 
#log_level=4

# OpenSIPS parameter configuration
# Debug level can be set via command line: opensips -D 3
# Or via modparam for specific modules

# Module path (Ubuntu/Debian package location)
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules"

# Listen on all interfaces (socket replaces deprecated listen)
socket=udp:0.0.0.0:5060

# Set advertised address (replace with your OpenSIPS server's IP address)
# This fixes the Via header showing 0.0.0.0
# For cloud deployments, this MUST be your public IP address
# Use --advertised-ip parameter during installation, or manually edit after installation
# The install.sh script will replace CHANGE_ME with the provided IP address
advertised_address="CHANGE_ME"

####### Modules ########

# Core modules
# Note: is_method(), has_totag() are built into OpenSIPS core
# Note: siputils and sanity modules don't exist in OpenSIPS - functions are built-in
# Note: pv (pseudo-variables) and xlog are built into OpenSIPS core
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
# Transport protocol - required for socket binding
loadmodule "proto_udp.so"
loadmodule "db_mysql.so"
# SQL operations module for database queries
loadmodule "sqlops.so"
loadmodule "dispatcher.so"
loadmodule "sipmsgops.so"
# NAT traversal module for fixing Contact headers and SDP
loadmodule "nathelper.so"
# HTTP and MI modules (for control panel)
loadmodule "httpd.so"
loadmodule "mi_http.so"
# Domain module (for control panel domain management)
loadmodule "domain.so"

####### Module Parameters ########

# --- MySQL routing database ---
# SQL operations module connection for sql_query() function
modparam("sqlops", "db_url", "mysql://opensips:rigmarole@localhost/opensips")

# --- Dispatcher (health checks via SIP OPTIONS) ---
modparam("dispatcher", "db_url", "mysql://opensips:rigmarole@localhost/opensips")

# --- HTTP server (for MI interface) ---
modparam("httpd", "port", 8888)

# --- Domain module (for control panel) ---
modparam("domain", "db_url", "mysql://opensips:rigmarole@localhost/opensips")
modparam("domain", "domain_table", "domain")
modparam("domain", "domain_col", "domain")
modparam("domain", "db_mode", 1)
   
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_threshold", 2)
# Note: ds_inactive_threshold doesn't exist in OpenSIPS dispatcher module
# Note: ds_ping_reply_codes is called options_reply_codes in OpenSIPS
modparam("dispatcher", "options_reply_codes", "200")

# --- Transaction timers ---
# Note: fr_timer is not a modparam in OpenSIPS - transaction timeouts are handled differently
# restart_fr_on_each_reply: reset final response timer on each provisional response
modparam("tm", "restart_fr_on_each_reply", 1)
# T1_timer: initial retransmission period (2 seconds = 2000ms)
# Note: OpenSIPS uses T1_timer instead of retr_timer1
modparam("tm", "T1_timer", 2000)
# T2_timer: maximum retransmission period (8 seconds = 8000ms)
# Note: OpenSIPS uses T2_timer instead of retr_timer2
modparam("tm", "T2_timer", 8000)

# --- Response handling ---
# OpenSIPS handles responses differently - ensure proper forwarding

####### Routing Logic ########

route {
    # ---- Log ALL requests at the very start for debugging ----
    xlog("REQUEST: $rm from $si:$sp to $ru (Call-ID: $hdr(Call-ID))\n");
    
    # Log SDP details for INVITE requests to diagnose audio issues
    if (is_method("INVITE") && $hdr(Content-Type) =~ "application/sdp") {
        $var(from_user) = $(fu{uri.user});
        $var(to_user) = $(tu{uri.user});
        xlog("INVITE with SDP: From=$var(from_user)@$si, To=$var(to_user)@$rd\n");
    }

    # ---- Basic hygiene ----
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    # Note: sanity_check() module not available in OpenSIPS
    # Basic validation is handled by core parsing

    # ---- Drop known scanners ----
    if ($ua =~ "sipvicious|friendly-scanner|sipcli|nmap") {
        exit;
    }

    # ---- In-dialog requests ----
    # Check if To tag exists (in-dialog request)
    # OpenSIPS uses $to_tag pseudo-variable for To header tag
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    # ---- Allowed methods only ----
    if (!is_method("REGISTER|INVITE|ACK|BYE|CANCEL|OPTIONS|NOTIFY|SUBSCRIBE|PRACK")) {
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }

    # ---- Handle CANCEL early (before domain check) ----
    # CANCEL needs to match existing INVITE transaction
    if (is_method("CANCEL")) {
        xlog("CANCEL received from $si:$sp for Call-ID: $hdr(Call-ID), CSeq=$hdr(CSeq), From=$fu, To=$tu\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("CANCEL matches existing transaction, forwarding to cancel INVITE\n");
        } else {
            xlog("L_WARN", "CANCEL received but no matching transaction found\n");
            sl_send_reply(481, "Call/Transaction Does Not Exist");
            exit;
        }
        # Forward CANCEL to cancel the INVITE transaction
        route(RELAY);
        exit;
    }

    # ---- Handle OPTIONS and NOTIFY from Asterisk backends (to endpoints) ----
    # Asterisk sends OPTIONS to registered endpoints for health checks and NAT keepalive
    # Asterisk sends NOTIFY for event notifications (e.g., message waiting indicators)
    # These need to be routed back to the actual endpoint IP
    if (is_method("OPTIONS|NOTIFY")) {
        # Check if this is coming from a known dispatcher destination (Asterisk backend)
        # Query database to see if source IP matches any dispatcher destination
        $var(source_ip) = $si;
        xlog("OPTIONS/NOTIFY received from $si, checking if from dispatcher\n");
        
        # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
        # If so, try endpoint lookup regardless of dispatcher check
        # Request-URI format: sip:401@192.168.1.138:56931 or sip:401@192.168.1.138
        $var(should_try_endpoint) = 0;
        
        # Check if Request-URI has a username
        if ($rU != "") {
            # Check if Request-URI domain is an IP address (contains digits and dots, not a domain name)
            # Simple heuristic: if domain contains only digits, dots, and colons, it's likely an IP
            if ($rd =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                $var(should_try_endpoint) = 1;
                xlog("OPTIONS/NOTIFY Request-URI looks like endpoint: $rU@$rd\n");
            }
        }
        
        # Also check if source IP is from a known dispatcher destination
        # For now, we'll try endpoint lookup if Request-URI looks like an endpoint
        # or if we want to check dispatcher destinations, we can add that logic here
        
        if ($var(should_try_endpoint) > 0) {
            
                    # Extract endpoint identifier
                    # Try To header first (may have domain), fallback to Request-URI username
                    $var(endpoint_user) = $tU;
                    if ($var(endpoint_user) == "") {
                        $var(endpoint_user) = $rU;
                    }
                    
                    # Try to get domain from To header, but if it's an IP, use username-only lookup
                    $var(to_domain) = $(tu{uri.domain});
                    if ($var(to_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # To header has IP, not domain - will use username-only lookup
                        $var(endpoint_aor) = "";
                    } else if ($var(to_domain) != "") {
                        # To header has domain - use for exact match
                        $var(endpoint_aor) = $var(endpoint_user) + "@" + $var(to_domain);
                    } else {
                        # No domain in To header - will use username-only lookup
                        $var(endpoint_aor) = "";
                    }
                    
                    xlog("OPTIONS/NOTIFY from Asterisk $si, looking up endpoint AoR: $var(endpoint_aor) (user: $var(endpoint_user))\n");
                    
                    # Use helper route to look up endpoint location
                    $var(lookup_user) = $var(endpoint_user);
                    $var(lookup_aor) = $var(endpoint_aor);
                    route(ENDPOINT_LOOKUP);
                    
                    xlog("OPTIONS/NOTIFY: After ENDPOINT_LOOKUP, lookup_success=$var(lookup_success), endpoint_ip=$var(endpoint_ip), endpoint_port=$var(endpoint_port)\n");
                    
                    # Check if endpoint was found
                    if ($var(lookup_success) == 1) {
                        # Get username from Request-URI or To header for destination URI
                        $var(target_user) = $tU;
                        if ($var(target_user) == "") {
                            $var(target_user) = $rU;
                        }
                        
                        # For OPTIONS/NOTIFY, use simple URI construction (no domain fallback needed)
                        # Set endpoint_user for BUILD_ENDPOINT_URI
                        $var(endpoint_user) = $var(target_user);
                        # Clear AoR to force simple IP-based Request-URI
                        $var(endpoint_aor) = "";
                        route(BUILD_ENDPOINT_URI);
                        
                        xlog("Routing $rm from Asterisk $si to endpoint $du, Request-URI=$ru, Call-ID=$hdr(Call-ID)\n");
                        route(RELAY);
                        exit;
                    }
                    
                    # Endpoint lookup failed - handle fallback
                    xlog("L_WARN", "$rm from Asterisk $si to $var(endpoint_aor) - endpoint location not found in database\n");
                    if (is_method("OPTIONS")) {
                        sl_send_reply(200, "OK");
                    } else {
                        # For NOTIFY, try to route based on Contact header if available
                        # Extract IP and port from Contact header using regex
                        $var(notify_ip) = "";
                        $var(notify_port) = "";
                        if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                            $var(notify_ip) = $re;
                            if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                                $var(notify_port) = $re;
                            }
                        }
                        
                        if ($var(notify_ip) != "" && $var(notify_ip) != $si) {
                            $du = "sip:" + $tU + "@" + $var(notify_ip);
                            if ($var(notify_port) != "") {
                                $du = $du + ":" + $var(notify_port);
                            } else {
                                $du = $du + ":5060";
                            }
                            xlog("Routing $rm to $du (fallback from Contact header)\n");
                            route(RELAY);
                        } else {
                            sl_send_reply(404, "Not Found");
                        }
                    }
                    exit;
        }
        
        # If we get here, Request-URI doesn't look like an endpoint, continue normal routing
        xlog("OPTIONS/NOTIFY from $si - Request-URI doesn't look like endpoint, continuing normal routing\n");
    }
    
    # ---- Handle REGISTER to track endpoint locations ----
    if (is_method("REGISTER")) {
        xlog("REGISTER received from $si, Contact: $hdr(Contact), To: $hdr(To)\n");
        
        # Extract endpoint location from Contact header and store in database
        # This allows us to route OPTIONS from Asterisk back to endpoints
        # Check if Contact header exists and extract values
        if ($hdr(Contact) != "") {
            # Extract AoR from To header (user@domain)
            # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
            $var(endpoint_aor) = $tU + "@" + $(tu{uri.domain});
            
            # Extract IP and port - always use source IP/port for REGISTER (endpoint sends directly)
            # Contact header extraction is for NAT scenarios, but source is more reliable for REGISTER
            # Initialize with source IP/port first
            $var(endpoint_ip) = $si;
            $var(endpoint_port) = $sp;
            
            # Ensure port is set (default to 5060 if source port is missing)
            if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                $var(endpoint_port) = "5060";
            }
            
            xlog("REGISTER: Initial endpoint values - IP=$var(endpoint_ip), Port=$var(endpoint_port) (from source $si:$sp)\n");
            
            # Try to extract from Contact header as fallback (for NAT scenarios)
            # Use regex to extract IP:port from Contact header string
            $var(contact_ip) = "";
            $var(contact_port) = "";
            
            # Extract IP address from Contact header (pattern: @IP:port or @IP)
            # Match IPv4 address after @ symbol
            # Contact format: <sip:user@IP:port> or sip:user@IP:port
            if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                $var(contact_ip) = $re;
                xlog("REGISTER: Extracted Contact IP from header: $var(contact_ip) (regex matched)\n");
                
                # Extract port if present (pattern: :PORT after the IP)
                if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                    $var(contact_port) = $re;
                    xlog("REGISTER: Extracted Contact port from header: $var(contact_port)\n");
                }
            } else {
                xlog("REGISTER: Contact header regex did not match IP pattern: $hdr(Contact)\n");
            }
            
            # For REGISTER, always use source IP/port (endpoint sends directly to OpenSIPS)
            # Contact header extraction is unreliable (regex $re not working correctly in OpenSIPS)
            # Source IP/port is the actual connection endpoint, which is what we need
            # Only use Contact header if we can successfully extract a valid IP that's different
            # For now, skip Contact header extraction and use source directly
            $var(endpoint_ip) = $si;
            $var(endpoint_port) = $sp;
            if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                $var(endpoint_port) = "5060";
            }
            xlog("REGISTER: Using source IP/port for endpoint: $var(endpoint_ip):$var(endpoint_port)\n");
            
            # Final validation - ensure we have valid values
            if ($var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
                $var(endpoint_ip) = $si;
            }
            if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                $var(endpoint_port) = $sp;
                if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                    $var(endpoint_port) = "5060";
                }
            }
            
            # Validate extracted IP and port before storing
            if ($var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
                xlog("L_ERR", "Failed to extract IP - source IP=$si, Contact: $hdr(Contact), endpoint_ip=$var(endpoint_ip)\n");
            } else if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
                xlog("L_ERR", "Failed to extract port - source port=$sp, endpoint_port=$var(endpoint_port)\n");
            } else {
                # Fix NAT in REGISTER Contact header before storing
                # This ensures we track the correct public IP for NAT traversal
                fix_nated_register();
                # Get expires from Expires header or Contact header
                $var(expires) = $hdr(Expires);
                if ($var(expires) == "") {
                    $var(expires) = "3600";  # Default 1 hour
                }
                
                # Ensure expires is a valid integer
                $var(expires_int) = $var(expires);
                if ($var(expires_int) == "" || $var(expires_int) == "0") {
                    $var(expires_int) = "3600";
                }
                
                # Use extracted endpoint IP/port (from Contact header if NAT, otherwise source)
                $var(final_ip) = $var(endpoint_ip);
                $var(final_port) = $var(endpoint_port);
                if ($var(final_port) == "" || $var(final_port) == "0") {
                    $var(final_port) = "5060";
                }
                
                xlog("Extracted endpoint info: AoR=$var(endpoint_aor), IP=$var(final_ip), Port=$var(final_port), Expires=$var(expires_int)\n");
                
                # Store/update endpoint location in database
                # Calculate expiration time: current time + expires seconds
                # Use MySQL syntax: DATE_ADD(NOW(), INTERVAL N SECOND)
                # Note: sql_query() returns false for INSERT statements (no rows returned),
                # but the INSERT still succeeds. We execute it and log the attempt.
                $var(query) = "INSERT INTO endpoint_locations (aor, contact_ip, contact_port, expires) VALUES ('" + $var(endpoint_aor) + "', '" + $var(final_ip) + "', '" + $var(final_port) + "', DATE_ADD(NOW(), INTERVAL " + $var(expires_int) + " SECOND)) ON DUPLICATE KEY UPDATE contact_ip='" + $var(final_ip) + "', contact_port='" + $var(final_port) + "', expires=DATE_ADD(NOW(), INTERVAL " + $var(expires_int) + " SECOND)";
                # Execute INSERT - return value is false for INSERT (no rows), but query succeeds
                sql_query($var(query), "$avp(reg_result)");
                xlog("Stored endpoint location: $var(endpoint_aor) -> $var(final_ip):$var(final_port) (expires in $var(expires_int) seconds)\n");
            }
        } else {
            xlog("L_WARN", "REGISTER without Contact header - cannot track endpoint location\n");
        }
        # Continue to DOMAIN_CHECK to forward REGISTER to Asterisk
    }

    route(DOMAIN_CHECK);
}

####### Domain validation / door-knocker protection ########

route[DOMAIN_CHECK] {

    # OpenSIPS: Request-URI domain is $rd (lowercase), not $rD
    $var(domain) = $rd;

    if ($var(domain) == "") {
        exit;
    }

    # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
    # This handles INVITE from Asterisk to endpoints (e.g., sip:402@192.168.1.232:5060)
    # Note: $rd might include port (e.g., 192.168.1.138:56931), so we check just the IP part
    # Extract just the IP address part (before any colon)
    $var(request_domain) = $rd;
    if ($var(request_domain) =~ "^([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
        $var(request_ip) = $re;
        xlog("INVITE Request-URI looks like endpoint: $rU@$var(request_domain), attempting endpoint lookup\n");
        
        # Extract username from Request-URI
        $var(endpoint_user) = $rU;
        
        # Use helper route to look up endpoint location (AoR, IP, and port)
        $var(lookup_user) = $var(endpoint_user);
        $var(lookup_aor) = "";  # Start with username-only lookup
        route(ENDPOINT_LOOKUP);
        
        # Check if endpoint was found
        if ($var(lookup_success) == 1) {
            xlog("Endpoint lookup result: AoR=$var(endpoint_aor), IP=$var(endpoint_ip), Port=$var(endpoint_port)\n");
            
            # Build destination URI and Request-URI using helper route
            route(BUILD_ENDPOINT_URI);
            
            xlog("Routing INVITE from $si to endpoint: dest=$du, Request-URI=$ru (endpoint lookup)\n");
            route(RELAY);
            exit;
        }
        
        # If endpoint lookup failed, log and send 404
        xlog("L_WARN", "Endpoint lookup failed for $var(endpoint_user)@$rd - no matching endpoint found in database\n");
        sl_send_reply(404, "Endpoint Not Found");
        exit;
    }

    # Optional extra hardening: domain consistency
    # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
    if ($rd != $(tu{uri.domain})) {
        xlog("L_WARN", "R-URI / To mismatch domain=$rd src=$si\n");
        exit;
    }

    # Lookup dispatcher set for this domain
    # Use domain.id as the dispatcher setid (standard OpenSIPS domain table)
    $var(query) = "SELECT id FROM domain WHERE domain='" + $var(domain) + "'";
    if (!sql_query($var(query), "$avp(domain_setid)")) {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (query failed)\n");
        exit;
    }
    
    # Check if domain was found
    if ($(avp(domain_setid)[0]) == "") {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (not found)\n");
        exit;
    }
    
    # Get the dispatcher_setid from query result (first row, first column)
    $var(setid) = $(avp(domain_setid)[0]);

    route(TO_DISPATCHER);
}

####### Health-aware routing ########

route[TO_DISPATCHER] {

    # Select a healthy Asterisk from the dispatcher set
    if (!ds_select_dst($var(setid), 4)) {
        xlog("L_ERR", "No healthy Asterisk nodes for domain=$rd setid=$var(setid)\n");
        sl_send_reply(503, "Service Unavailable");
        exit;
    }

    xlog("Routing to $du for domain=$rd setid=$var(setid) method=$rm Request-URI=$ru\n");

    record_route();

    # Arm failure route to handle transaction failures
    t_on_failure("1");

    # OpenSIPS transaction handling for reliable INVITE transaction management
    if (!t_relay()) {
        xlog("L_ERR", "t_relay() failed for $du method=$rm Request-URI=$ru\n");
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
        exit;
    }

    xlog("t_relay() succeeded for $du method=$rm, transaction created\n");
    # For INVITE, ensure transaction stays active
    # The transaction module should handle this automatically, but log it
    if (is_method("INVITE")) {
        xlog("INVITE transaction created, waiting for response from $du\n");
    }
    exit;
}

####### In-dialog handling ########

route[WITHINDLG] {
    xlog("In-dialog request: $rm from $si to $ru (Call-ID: $hdr(Call-ID), To-tag=$tt)\n");

    # Check for Record-Route header and follow it
    if (loose_route()) {
        xlog("loose_route() succeeded for $rm, following Record-Route\n");
        route(RELAY);
        exit;
    }

    # If loose_route() fails, try to route based on transaction state
    # ACK, PRACK, and BYE need special handling - they're part of existing transactions
    if (is_method("ACK|PRACK|BYE")) {
        xlog("$rm request - loose_route() failed, checking transaction state\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("$rm matches existing transaction, relaying\n");
            # For ACKs and PRACKs, try t_relay() first (uses transaction state), fallback to RELAY route
            if (is_method("ACK|PRACK")) {
                if (!t_relay()) {
                    xlog("L_ERR", "t_relay() failed for $rm, trying stateless forward\n");
                    route(RELAY);
                }
            } else {
                # For BYE, use RELAY route directly
                route(RELAY);
            }
            exit;
        } else {
            xlog("L_WARN", "$rm received but no matching transaction found, trying to relay anyway\n");
            # Must be forwarded even without transaction match (stateless forwarding)
            # This ensures message reaches the destination even if transaction expired
            route(RELAY);
            exit;
        }
    }

    xlog("L_WARN", "In-dialog request $rm - loose_route() failed and no transaction match\n");
    sl_send_reply(404, "Not Here");
    exit;
}

####### Helper Routes ########

# Endpoint lookup helper route
# Looks up endpoint location from database by username and/or AoR
# 
# Input variables:
#   $var(lookup_user) - Username to look up (required)
#   $var(lookup_aor)  - Optional AoR for exact match (e.g., "user@domain.com")
#
# Output variables:
#   $var(endpoint_ip)   - Endpoint IP address if found
#   $var(endpoint_port) - Endpoint port if found (defaults to 5060)
#   $var(endpoint_aor)  - Full AoR if found (e.g., "user@domain.com")
#   $var(lookup_success) - 1 if endpoint found, 0 if not found
#
# Usage:
#   $var(lookup_user) = "40004";
#   $var(lookup_aor) = "40004@pbx3sbc.vcloudpbx.com";  # Optional
#   route(ENDPOINT_LOOKUP);
#   if ($var(lookup_success) == 1) {
#       # Use $var(endpoint_ip), $var(endpoint_port), $var(endpoint_aor)
#   }
route[ENDPOINT_LOOKUP] {
    xlog("ENDPOINT_LOOKUP: Looking up user=$var(lookup_user), AoR=$var(lookup_aor)\n");
    
    # Initialize output variables
    $var(endpoint_ip) = "";
    $var(endpoint_port) = "";
    $var(endpoint_aor) = "";
    $var(lookup_success) = 0;
    
    # Validate input
    if ($var(lookup_user) == "") {
        xlog("L_ERR", "ENDPOINT_LOOKUP: lookup_user is empty\n");
        exit;
    }
    
    # First try exact AoR match (if AoR provided and not empty)
    if ($var(lookup_aor) != "") {
        xlog("ENDPOINT_LOOKUP: Trying exact AoR match for $var(lookup_aor)\n");
        $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor='" + $var(lookup_aor) + "' AND expires > NOW()";
        if (sql_query($var(query), "$avp(endpoint_ip)")) {
            if ($(avp(endpoint_ip)[0]) != "") {
                $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
                # Get the port
                $var(query) = "SELECT contact_port FROM endpoint_locations WHERE aor='" + $var(lookup_aor) + "' AND expires > NOW()";
                if (sql_query($var(query), "$avp(endpoint_port)")) {
                    $var(endpoint_port) = $(avp(endpoint_port)[0]);
                }
                $var(endpoint_aor) = $var(lookup_aor);
                xlog("ENDPOINT_LOOKUP: Exact match found - IP=$var(endpoint_ip), Port=$var(endpoint_port), AoR=$var(endpoint_aor)\n");
            }
        }
    }
    
    # Fallback: try username-only lookup (if exact match failed or wasn't attempted)
    if ($var(endpoint_ip) == "") {
        xlog("ENDPOINT_LOOKUP: Trying username-only match for $var(lookup_user)\n");
        $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(lookup_user) + "@%' AND expires > NOW() LIMIT 1";
        xlog("ENDPOINT_LOOKUP: Executing query: $var(query)\n");
        $var(query_result) = sql_query($var(query), "$avp(endpoint_ip)");
        xlog("ENDPOINT_LOOKUP: sql_query() returned: $var(query_result)\n");
        if ($var(query_result)) {
            xlog("ENDPOINT_LOOKUP: Query succeeded, checking result\n");
            $var(result_value) = $(avp(endpoint_ip)[0]);
            xlog("ENDPOINT_LOOKUP: AVP result[0] = '$var(result_value)'\n");
            if ($var(result_value) != "") {
                $var(endpoint_ip) = $var(result_value);
                xlog("ENDPOINT_LOOKUP: Found IP=$var(endpoint_ip), getting port\n");
                # Get the port
                $var(query) = "SELECT contact_port FROM endpoint_locations WHERE aor LIKE '" + $var(lookup_user) + "@%' AND expires > NOW() LIMIT 1";
                if (sql_query($var(query), "$avp(endpoint_port)")) {
                    $var(endpoint_port) = $(avp(endpoint_port)[0]);
                }
                # Get the full AoR
                $var(query) = "SELECT aor FROM endpoint_locations WHERE aor LIKE '" + $var(lookup_user) + "@%' AND expires > NOW() LIMIT 1";
                if (sql_query($var(query), "$avp(endpoint_aor)")) {
                    $var(endpoint_aor) = $(avp(endpoint_aor)[0]);
                }
                xlog("ENDPOINT_LOOKUP: Username match found - IP=$var(endpoint_ip), Port=$var(endpoint_port), AoR=$var(endpoint_aor)\n");
                xlog("ENDPOINT_LOOKUP: Continuing after username match...\n");
            } else {
                xlog("ENDPOINT_LOOKUP: Query returned empty result (result_value is empty)\n");
            }
        } else {
            xlog("L_ERR", "ENDPOINT_LOOKUP: SQL query returned false for username=$var(lookup_user)\n");
        }
    }
    
    # Validate and set defaults
    xlog("ENDPOINT_LOOKUP: After lookup, endpoint_ip='$var(endpoint_ip)', endpoint_port='$var(endpoint_port)', endpoint_aor='$var(endpoint_aor)'\n");
    if ($var(endpoint_ip) != "") {
        xlog("ENDPOINT_LOOKUP: IP found, calling VALIDATE_ENDPOINT\n");
        route(VALIDATE_ENDPOINT);
        xlog("ENDPOINT_LOOKUP: After VALIDATE_ENDPOINT, endpoint_ip='$var(endpoint_ip)', endpoint_port='$var(endpoint_port)'\n");
        $var(lookup_success) = 1;
        xlog("ENDPOINT_LOOKUP: Success - IP=$var(endpoint_ip), Port=$var(endpoint_port), AoR=$var(endpoint_aor)\n");
    } else {
        xlog("ENDPOINT_LOOKUP: Failed - no endpoint found for user=$var(lookup_user)\n");
        $var(lookup_success) = 0;
    }
    
    xlog("ENDPOINT_LOOKUP: Returning with lookup_success=$var(lookup_success)\n");
    # Helper route returns normally to allow caller to continue processing
    return;
}

# Endpoint validation helper route
# Validates endpoint IP and port, sets defaults
# 
# Input variables:
#   $var(endpoint_ip)   - Endpoint IP address (required)
#   $var(endpoint_port) - Endpoint port (optional, defaults to 5060)
#
# Output variables:
#   $var(endpoint_ip)   - Validated IP (unchanged if valid)
#   $var(endpoint_port) - Validated port (defaults to 5060 if empty/invalid)
#
# Usage:
#   $var(endpoint_ip) = "192.168.1.100";
#   $var(endpoint_port) = "";  # Will be set to 5060
#   route(VALIDATE_ENDPOINT);
route[VALIDATE_ENDPOINT] {
    # Validate IP is not empty
    if ($var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
        xlog("L_ERR", "VALIDATE_ENDPOINT: endpoint_ip is empty or invalid\n");
        return;
    }
    
    # Set default port if empty or invalid
    if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
        $var(endpoint_port) = "5060";
    }
    
    # Route returns normally to caller (no exit needed)
}

# Build endpoint URI helper route
# Constructs destination URI ($du) and Request-URI ($ru) for routing to endpoints
# Handles domain extraction and fallback logic for Request-URI construction
#
# Input variables:
#   $var(endpoint_user)   - Username for the endpoint (required)
#   $var(endpoint_ip)     - Endpoint IP address (required)
#   $var(endpoint_port)   - Endpoint port (required, should be validated)
#   $var(endpoint_aor)    - Full AoR (user@domain) if available (optional)
#
# Output variables:
#   $du - Destination URI (sip:user@ip:port) for routing
#   $ru - Request-URI (sip:user@domain or sip:user@ip:port) with domain fallbacks
#
# Usage:
#   $var(endpoint_user) = "40004";
#   $var(endpoint_ip) = "192.168.1.100";
#   $var(endpoint_port) = "5060";
#   $var(endpoint_aor) = "40004@pbx3sbc.vcloudpbx.com";  # Optional
#   route(BUILD_ENDPOINT_URI);
route[BUILD_ENDPOINT_URI] {
    # Build destination URI with IP:port for routing (NAT traversal)
    $du = "sip:" + $var(endpoint_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
    
    # Extract domain from AoR if available
    $var(endpoint_domain) = "";
    if ($var(endpoint_aor) != "" && $var(endpoint_aor) =~ "@(.+)") {
        $var(endpoint_domain) = $re;
    }
    
    # If domain extraction failed or domain is an IP, try To header as fallback
    if ($var(endpoint_domain) == "" || $var(endpoint_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
        $var(to_domain) = $(tu{uri.domain});
        if ($var(to_domain) != "" && $var(to_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
            $var(endpoint_domain) = $var(to_domain);
            xlog("BUILD_ENDPOINT_URI: Using domain from To header: $var(endpoint_domain)\n");
        }
    }
    
    # Construct Request-URI with fallback logic
    if ($var(endpoint_aor) != "" && $var(endpoint_aor) =~ "@" && $var(endpoint_aor) !~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
        # AoR has domain (not IP), use it directly
        $ru = "sip:" + $var(endpoint_aor);
        xlog("BUILD_ENDPOINT_URI: Using AoR directly in Request-URI: $ru\n");
    } else if ($var(endpoint_domain) != "" && $var(endpoint_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
        # Fallback: construct from extracted domain
        $ru = "sip:" + $var(endpoint_user) + "@" + $var(endpoint_domain);
        xlog("BUILD_ENDPOINT_URI: Using extracted domain in Request-URI: $ru\n");
    } else {
        # Last resort: use IP if domain not found
        xlog("L_WARN", "BUILD_ENDPOINT_URI: Cannot determine domain, using IP in Request-URI: $du\n");
        $ru = $du;
    }
    
    # Route returns normally to caller (no exit needed)
}

# Check if IP address is private (RFC 1918)
# Input: $var(check_ip) - IP address to check
# Output: $var(is_private) - 1 if private, 0 if public
route[CHECK_PRIVATE_IP] {
    $var(is_private) = 0;
    if ($var(check_ip) =~ "^192\\.168\\.") {
        $var(is_private) = 1;
    } else if ($var(check_ip) =~ "^10\\.") {
        $var(is_private) = 1;
    } else if ($var(check_ip) =~ "^172\\.1[6-9]\\.") {
        $var(is_private) = 1;
    } else if ($var(check_ip) =~ "^172\\.2[0-9]\\.") {
        $var(is_private) = 1;
    } else if ($var(check_ip) =~ "^172\\.3[01]\\.") {
        $var(is_private) = 1;
    }
    return;
}

route[RELAY] {
    # Add Record-Route for INVITE requests so ACKs can follow the same path
    # This is critical for ACK handling when routing from Asterisk to endpoints
    if (is_method("INVITE")) {
        record_route();
        xlog("RELAY: Added Record-Route for INVITE to $du, Call-ID=$hdr(Call-ID)\n");
    }
    
    # For ACKs, PRACKs, BYEs, and NOTIFYs, fix destination URI to use NAT IP from endpoint database (handles NAT correctly)
    # Only do this if the Request-URI contains a private IP address (endpoint behind NAT)
    # Public IPs or domains (Asterisk) should not be modified
    # NOTIFY needs this because Asterisk sends NOTIFY with private IP in Request-URI after SUBSCRIBE
    # PRACK needs this for 100rel support when endpoints are behind NAT
    if (is_method("ACK|PRACK|BYE|NOTIFY")) {
        # Check if Request-URI domain is a private IP address (endpoint behind NAT)
        $var(check_ip) = $rd;
        route(CHECK_PRIVATE_IP);
        
        if ($var(is_private) == 1) {
            # Request-URI contains private IP - this is an endpoint behind NAT, need to fix to public NAT IP
            $var(msg_user) = $rU;
            if ($var(msg_user) != "") {
                # Use existing ENDPOINT_LOOKUP helper route instead of duplicating database queries
                $var(lookup_user) = $var(msg_user);
                $var(lookup_aor) = "";  # Username-only lookup
                route(ENDPOINT_LOOKUP);
                
                if ($var(lookup_success) == 1) {
                    # Set destination URI to use NAT IP from database
                    $du = "sip:" + $var(msg_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
                    xlog("RELAY: $rm - Updated destination to NAT IP: $du (from database, user=$var(msg_user), was $ru)\n");
                } else {
                    xlog("L_WARN", "RELAY: $rm - Endpoint lookup failed for user=$var(msg_user), using original Request-URI\n");
                }
            }
        } else {
            # Request-URI contains public IP or domain (Asterisk) - don't modify, let t_relay() use transaction state
            xlog("RELAY: $rm - Request-URI has public IP/domain ($var(check_ip)), not modifying destination\n");
        }
    }
    
    # Arm failure route to handle transaction failures
    t_on_failure("1");
    
    # For non-INVITE requests (like NOTIFY), ensure transaction is created properly
    if (is_method("NOTIFY|OPTIONS")) {
        xlog("RELAY: Creating transaction for $rm to $du, Call-ID=$hdr(Call-ID)\n");
    }
    
    if (!t_relay()) {
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
    } else {
        if (is_method("NOTIFY|OPTIONS")) {
            xlog("RELAY: Transaction created successfully for $rm, Call-ID=$hdr(Call-ID)\n");
        }
    }
    exit;
}
    
####### Response handling (for debugging) ########

onreply_route {
    xlog("Response received: $rs $rr from $si (method=$rm, CSeq=$hdr(CSeq), To-tag=$tt, Contact=$hdr(Contact), Call-ID=$hdr(Call-ID))\n");
    
    # Fix NAT in Contact headers and SDP for responses from endpoints behind NAT
    # This is critical for RTP to work correctly - fixes private IPs to public NAT IPs
    # fix_nated_contact() fixes Contact headers in responses
    # fix_nated_sdp() with "rewrite-media-ip" flag rewrites the media IP address (c= line) in SDP
    # This ensures Asterisk receives the public NAT IP instead of private IP for RTP
    fix_nated_contact();
    if ($hdr(Content-Type) =~ "application/sdp") {
        fix_nated_sdp("rewrite-media-ip");
        xlog("Fixed NAT in SDP for response $rs from $si\n");
    }
    
    # Log OPTIONS/NOTIFY responses specifically
    if (is_method("OPTIONS|NOTIFY")) {
        xlog("OPTIONS/NOTIFY response: $rs $rr from $si, Call-ID=$hdr(Call-ID), Via=$hdr(Via), forwarding to Asterisk\n");
        # In onreply_route, transaction should already exist if we're here
        # If we get a 476 error, it means the response didn't match any transaction
        # This could be due to Via branch mismatch or transaction timeout
    }
    
    # Detailed SDP logging for 200 OK responses
    # This helps diagnose why one direction works and the other doesn't
    if ($rs == 200 && $hdr(Content-Type) =~ "application/sdp") {
        # Extract username from To header to identify the callee
        $var(to_user) = $(tu{uri.user});
        $var(from_user) = $(fu{uri.user});
        
        xlog("200 OK with SDP: From=$var(from_user), To=$var(to_user), Source=$si\n");
        
        # Diagnostic logging: Check endpoint IPs for SDP troubleshooting
        # This helps diagnose RTP issues regardless of whether call is from Asterisk or endpoint
        if ($var(to_user) != "") {
            # Look up endpoint IP from database for the callee (To header)
            $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(to_user) + "@%' AND expires > NOW() LIMIT 1";
            if (sql_query($var(query), "$avp(endpoint_ip)")) {
                if ($(avp(endpoint_ip)[0]) != "") {
                    $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
                    xlog("Callee endpoint IP from database: $var(endpoint_ip) (user=$var(to_user))\n");
                }
            }
        }
        
        # Also check the caller's endpoint IP
        if ($var(from_user) != "") {
            $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(from_user) + "@%' AND expires > NOW() LIMIT 1";
            if (sql_query($var(query), "$avp(caller_ip)")) {
                if ($(avp(caller_ip)[0]) != "") {
                    $var(caller_ip) = $(avp(caller_ip)[0]);
                    xlog("Caller endpoint IP from database: $var(caller_ip) (user=$var(from_user))\n");
                }
            }
        }
    }
    
    # Log transaction state for debugging
    if ($rs >= 100 && $rs < 200) {
        xlog("Provisional response $rs received, transaction should remain active\n");
        # For provisional responses, explicitly exit to let transaction module handle forwarding
        # The transaction module will automatically forward and keep transaction alive
        exit;
    } else if ($rs >= 200 && $rs < 300) {
        xlog("Final success response $rs received\n");
        exit;
    } else if ($rs >= 300) {
        xlog("Final error response $rs received\n");
        exit;
    }
    # If we get here, exit to let transaction module handle it
    exit;
}

failure_route[1] {
    xlog("L_ERR", "Transaction failure: method=$rm, Call-ID: $hdr(Call-ID), From=$fu, To=$tu, Response code=$rs, Reason=$rr\n");
    # Log more details about the failure
    if ($rs == 408) {
        xlog("L_ERR", "408 Request Timeout generated - transaction timed out waiting for response\n");
    }
    # t_relay will handle forwarding the failure response automatically
    exit;
}

####### Dispatcher events (visibility) ########

# Note: Event routes for dispatcher module are not currently configured
# Event route syntax varies by OpenSIPS version and may require specific module configuration
# If needed, check OpenSIPS documentation for event route syntax for your version

