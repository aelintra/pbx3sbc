#!opensips
#
# OpenSIPS SIP Edge Router Configuration Template
# This configuration provides SIP edge routing functionality for Asterisk PBX backends
#
# Based on requirements in REQUIREMENTS-FOR-OPENSIPS.md
# Troubleshooting notes in TROUBLESHOOTING-OPTIONS-ROUTING.md
#

####### Global Parameters #########

# The default log_level is usually enough for most things but you can increase
# it here for lower levels of visibility 
#log_level=4

# OpenSIPS parameter configuration
# Debug level can be set via command line: opensips -D 3
# Or via modparam for specific modules

# Module path (Ubuntu/Debian package location)
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules"

# Listen on all interfaces (socket replaces deprecated listen)
socket=udp:0.0.0.0:5060

# Set advertised address (replace with your OpenSIPS server's IP address)
# This fixes the Via header showing 0.0.0.0
# For cloud deployments, this MUST be your public IP address
# Use --advertised-ip parameter during installation, or manually edit after installation
# The install.sh script will replace CHANGE_ME with the provided IP address
advertised_address="CHANGE_ME"

####### Modules ########

# Core modules
# Note: is_method(), has_totag() are built into OpenSIPS core
# Note: siputils and sanity modules don't exist in OpenSIPS - functions are built-in
# Note: pv (pseudo-variables) and xlog are built into OpenSIPS core
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
# Transport protocol - required for socket binding
loadmodule "proto_udp.so"
loadmodule "db_mysql.so"
# SQL operations module for database queries
loadmodule "sqlops.so"
loadmodule "dispatcher.so"
loadmodule "sipmsgops.so"
# NAT traversal module for fixing Contact headers and SDP
loadmodule "nathelper.so"

####### Module Parameters ########

# --- MySQL routing database ---
# SQL operations module connection for sql_query() function
modparam("sqlops", "db_url", "mysql://opensips:your-password@localhost/opensips")

# --- Dispatcher (health checks via SIP OPTIONS) ---
modparam("dispatcher", "db_url", "mysql://opensips:your-password@localhost/opensips")

modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_threshold", 2)
# Note: ds_inactive_threshold doesn't exist in OpenSIPS dispatcher module
# Note: ds_ping_reply_codes is called options_reply_codes in OpenSIPS
modparam("dispatcher", "options_reply_codes", "200")

# --- Transaction timers ---
# Note: fr_timer is not a modparam in OpenSIPS - transaction timeouts are handled differently
# restart_fr_on_each_reply: reset final response timer on each provisional response
modparam("tm", "restart_fr_on_each_reply", 1)
# T1_timer: initial retransmission period (2 seconds = 2000ms)
# Note: OpenSIPS uses T1_timer instead of retr_timer1
modparam("tm", "T1_timer", 2000)
# T2_timer: maximum retransmission period (8 seconds = 8000ms)
# Note: OpenSIPS uses T2_timer instead of retr_timer2
modparam("tm", "T2_timer", 8000)

# --- Response handling ---
# OpenSIPS handles responses differently - ensure proper forwarding

####### Routing Logic ########

route {
    # ---- Log ALL requests at the very start for debugging ----
    xlog("REQUEST: $rm from $si:$sp to $ru (Call-ID: $hdr(Call-ID))\n");
    
    # Log SDP details for INVITE requests to diagnose audio issues
    if (is_method("INVITE") && $hdr(Content-Type) =~ "application/sdp") {
        $var(from_user) = $(fu{uri.user});
        $var(to_user) = $(tu{uri.user});
        xlog("INVITE with SDP: From=$var(from_user)@$si, To=$var(to_user)@$rd\n");
    }

    # ---- Basic hygiene ----
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    # Note: sanity_check() module not available in OpenSIPS
    # Basic validation is handled by core parsing

    # ---- Drop known scanners ----
    if ($ua =~ "sipvicious|friendly-scanner|sipcli|nmap") {
        exit;
    }

    # ---- In-dialog requests ----
    # Check if To tag exists (in-dialog request)
    # OpenSIPS uses $to_tag pseudo-variable for To header tag
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    # ---- Allowed methods only ----
    if (!is_method("REGISTER|INVITE|ACK|BYE|CANCEL|OPTIONS|NOTIFY|SUBSCRIBE|PRACK")) {
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }

    # ---- Handle CANCEL early (before domain check) ----
    # CANCEL needs to match existing INVITE transaction
    if (is_method("CANCEL")) {
        xlog("CANCEL received from $si:$sp for Call-ID: $hdr(Call-ID), CSeq=$hdr(CSeq), From=$fu, To=$tu\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("CANCEL matches existing transaction, forwarding to cancel INVITE\n");
        } else {
            xlog("L_WARN", "CANCEL received but no matching transaction found\n");
            sl_send_reply(481, "Call/Transaction Does Not Exist");
            exit;
        }
        # Forward CANCEL to cancel the INVITE transaction
        route(RELAY);
        exit;
    }

    # ---- Handle OPTIONS and NOTIFY from Asterisk backends (to endpoints) ----
    # Asterisk sends OPTIONS to registered endpoints for health checks and NAT keepalive
    # Asterisk sends NOTIFY for event notifications (e.g., message waiting indicators)
    # These need to be routed back to the actual endpoint IP
    if (is_method("OPTIONS|NOTIFY")) {
        # Check if this is coming from a known dispatcher destination (Asterisk backend)
        # Query database to see if source IP matches any dispatcher destination
        $var(source_ip) = $si;
        xlog("OPTIONS/NOTIFY received from $si, checking if from dispatcher\n");
        
        # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
        # If so, try endpoint lookup regardless of dispatcher check
        # Request-URI format: sip:401@192.168.1.138:56931 or sip:401@192.168.1.138
        $var(should_try_endpoint) = 0;
        
        # Check if Request-URI has a username
        if ($rU != "") {
            # Check if Request-URI domain is an IP address (contains digits and dots, not a domain name)
            # Simple heuristic: if domain contains only digits, dots, and colons, it's likely an IP
            if ($rd =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                $var(should_try_endpoint) = 1;
                xlog("OPTIONS/NOTIFY Request-URI looks like endpoint: $rU@$rd\n");
            }
        }
        
        # Also check if source IP is from a known dispatcher destination
        # For now, we'll try endpoint lookup if Request-URI looks like an endpoint
        # or if we want to check dispatcher destinations, we can add that logic here
        
        if ($var(should_try_endpoint) > 0) {
            
                    # Extract endpoint identifier
                    # Try To header first (may have domain), fallback to Request-URI username
                    $var(endpoint_user) = $tU;
                    if ($var(endpoint_user) == "") {
                        $var(endpoint_user) = $rU;
                    }
                    
                    # Try to get domain from To header, but if it's an IP, use username-only lookup
                    $var(to_domain) = $(tu{uri.domain});
                    if ($var(to_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # To header has IP, not domain - will use username-only lookup
                        $var(endpoint_aor) = "";
                    } else if ($var(to_domain) != "") {
                        # To header has domain - use for exact match
                        $var(endpoint_aor) = $var(endpoint_user) + "@" + $var(to_domain);
                    } else {
                        # No domain in To header - will use username-only lookup
                        $var(endpoint_aor) = "";
                    }
                    
                    xlog("OPTIONS/NOTIFY from Asterisk $si, looking up endpoint AoR: $var(endpoint_aor) (user: $var(endpoint_user))\n");
                    
                    # Use helper route to look up endpoint location
                    $var(lookup_user) = $var(endpoint_user);
                    $var(lookup_aor) = $var(endpoint_aor);
                    route(ENDPOINT_LOOKUP);
                    
                    xlog("OPTIONS/NOTIFY: After ENDPOINT_LOOKUP, lookup_success=$var(lookup_success), endpoint_ip=$var(endpoint_ip), endpoint_port=$var(endpoint_port)\n");
                    
                    # Check if endpoint was found
                    if ($var(lookup_success) == 1) {
                        # Get username from Request-URI or To header for destination URI
                        $var(target_user) = $tU;
                        if ($var(target_user) == "") {
                            $var(target_user) = $rU;
                        }
                        
                        # For OPTIONS/NOTIFY, use simple URI construction (no domain fallback needed)
                        # Set endpoint_user for BUILD_ENDPOINT_URI
                        $var(endpoint_user) = $var(target_user);
                        # Clear AoR to force simple IP-based Request-URI
                        $var(endpoint_aor) = "";
                        route(BUILD_ENDPOINT_URI);
                        
                        xlog("Routing $rm from Asterisk $si to endpoint $du, Request-URI=$ru, Call-ID=$hdr(Call-ID)\n");
                        route(RELAY);
                        exit;
                    }
                    
                    # Endpoint lookup failed - handle fallback
                    xlog("L_WARN", "$rm from Asterisk $si to $var(endpoint_aor) - endpoint location not found in database\n");
                    if (is_method("OPTIONS")) {
                        sl_send_reply(200, "OK");
                    } else {
                        # For NOTIFY, try to route based on Contact header if available
                        # Extract IP and port from Contact header using regex
                        $var(notify_ip) = "";
                        $var(notify_port) = "";
                        if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                            $var(notify_ip) = $re;
                            if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                                $var(notify_port) = $re;
                            }
                        }
                        
                        if ($var(notify_ip) != "" && $var(notify_ip) != $si) {
                            $du = "sip:" + $tU + "@" + $var(notify_ip);
                            if ($var(notify_port) != "") {
                                $du = $du + ":" + $var(notify_port);
                            } else {
                                $du = $du + ":5060";
                            }
                            xlog("Routing $rm to $du (fallback from Contact header)\n");
                            route(RELAY);
                        } else {
                            sl_send_reply(404, "Not Found");
                        }
                    }
                    exit;
        }
        
        # If we get here, Request-URI doesn't look like an endpoint, continue normal routing
        xlog("OPTIONS/NOTIFY from $si - Request-URI doesn't look like endpoint, continuing normal routing\n");
    }
    
    # ---- Handle REGISTER to track endpoint locations ----
    if (is_method("REGISTER")) {
        if ($hdr(Contact) != "") {
            $var(endpoint_aor) = $tU + "@" + $(tu{uri.domain});
            $var(endpoint_ip) = $si;
            if ($sp != "" && $sp != "0") {
                $var(endpoint_port) = $sp;
            } else {
                $var(endpoint_port) = "5060";
            }
            
            fix_nated_register();
            if ($hdr(Expires) != "" && $hdr(Expires) != "0") {
                $var(expires_int) = $hdr(Expires);
            } else {
                $var(expires_int) = "3600";
            }
            $var(contact_uri) = "sip:" + $tU + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
            
            $var(query) = "INSERT INTO endpoint_locations (aor, contact_ip, contact_port, contact_uri, expires) VALUES ('" + $var(endpoint_aor) + "', '" + $var(endpoint_ip) + "', '" + $var(endpoint_port) + "', '" + $var(contact_uri) + "', DATE_ADD(NOW(), INTERVAL " + $var(expires_int) + " SECOND)) ON DUPLICATE KEY UPDATE contact_ip='" + $var(endpoint_ip) + "', contact_port='" + $var(endpoint_port) + "', contact_uri='" + $var(contact_uri) + "', expires=DATE_ADD(NOW(), INTERVAL " + $var(expires_int) + " SECOND)";
            sql_query($var(query), "$avp(reg_result)");
            xlog("REGISTER: Stored endpoint $var(endpoint_aor) -> $var(endpoint_ip):$var(endpoint_port) (expires $var(expires_int)s)\n");
        }
    }

    route(DOMAIN_CHECK);
}

####### Domain validation / door-knocker protection ########

route[DOMAIN_CHECK] {

    # OpenSIPS: Request-URI domain is $rd (lowercase), not $rD
    $var(domain) = $rd;

    if ($var(domain) == "") {
        exit;
    }

    # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
    # This handles INVITE from Asterisk to endpoints (e.g., sip:402@192.168.1.232:5060)
    # Note: $rd might include port (e.g., 192.168.1.138:56931), so we check just the IP part
    # Extract just the IP address part (before any colon)
    $var(request_domain) = $rd;
    if ($var(request_domain) =~ "^([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
        $var(request_ip) = $re;
        xlog("INVITE Request-URI looks like endpoint: $rU@$var(request_domain), attempting endpoint lookup\n");
        
        # Extract username from Request-URI
        $var(endpoint_user) = $rU;
        
        # Use helper route to look up endpoint location (AoR, IP, and port)
        $var(lookup_user) = $var(endpoint_user);
        $var(lookup_aor) = "";  # Start with username-only lookup
        route(ENDPOINT_LOOKUP);
        
        # Check if endpoint was found
        if ($var(lookup_success) == 1) {
            xlog("Endpoint lookup result: AoR=$var(endpoint_aor), IP=$var(endpoint_ip), Port=$var(endpoint_port)\n");
            
            # Build destination URI and Request-URI using helper route
            route(BUILD_ENDPOINT_URI);
            
            xlog("Routing INVITE from $si to endpoint: dest=$du, Request-URI=$ru (endpoint lookup)\n");
            route(RELAY);
            exit;
        }
        
        # If endpoint lookup failed, log and send 404
        xlog("L_WARN", "Endpoint lookup failed for $var(endpoint_user)@$rd - no matching endpoint found in database\n");
        sl_send_reply(404, "Endpoint Not Found");
        exit;
    }

    # Optional extra hardening: domain consistency
    # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
    if ($rd != $(tu{uri.domain})) {
        xlog("L_WARN", "R-URI / To mismatch domain=$rd src=$si\n");
        exit;
    }

    # Lookup dispatcher set for this domain
    # Use domain.setid as the dispatcher setid (explicit mapping)
    $var(query) = "SELECT setid FROM domain WHERE domain='" + $var(domain) + "'";
    if (!sql_query($var(query), "$avp(domain_setid)")) {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (query failed)\n");
        exit;
    }
    
    # Check if domain was found
    if ($(avp(domain_setid)[0]) == "") {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (not found)\n");
        exit;
    }
    
    # Get the dispatcher_setid from query result (first row, first column)
    $var(setid) = $(avp(domain_setid)[0]);

    route(TO_DISPATCHER);
}

####### Health-aware routing ########

route[TO_DISPATCHER] {

    # Select a healthy Asterisk from the dispatcher set
    if (!ds_select_dst($var(setid), 4)) {
        xlog("L_ERR", "No healthy Asterisk nodes for domain=$rd setid=$var(setid)\n");
        sl_send_reply(503, "Service Unavailable");
        exit;
    }

    xlog("Routing to $du for domain=$rd setid=$var(setid) method=$rm Request-URI=$ru\n");

    record_route();

    # Arm failure route to handle transaction failures
    t_on_failure("1");

    # OpenSIPS transaction handling for reliable INVITE transaction management
    if (!t_relay()) {
        xlog("L_ERR", "t_relay() failed for $du method=$rm Request-URI=$ru\n");
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
        exit;
    }

    xlog("t_relay() succeeded for $du method=$rm, transaction created\n");
    # For INVITE, ensure transaction stays active
    # The transaction module should handle this automatically, but log it
    if (is_method("INVITE")) {
        xlog("INVITE transaction created, waiting for response from $du\n");
    }
    exit;
}

####### In-dialog handling ########

route[WITHINDLG] {
    xlog("In-dialog request: $rm from $si to $ru (Call-ID: $hdr(Call-ID), To-tag=$tt)\n");

    # Check for Record-Route header and follow it
    if (loose_route()) {
        xlog("loose_route() succeeded for $rm, following Record-Route, $du=$du, $ru=$ru\n");
        
        # For ACK and PRACK requests, validate destination URI after loose_route()
        # loose_route() may not set $du correctly, causing ACKs to not be forwarded
        if (is_method("ACK|PRACK")) {
            # If $du is empty or invalid, use Request-URI
            # ACK/PRACK should use Request-URI as fallback since they're in-dialog requests
            if ($du == "" || $du == "0") {
                $du = $ru;
                xlog("ACK/PRACK: loose_route() set empty destination, using Request-URI: $du\n");
            } else {
                # Validate $du is a valid SIP URI format
                if ($du !~ "^sip:") {
                    xlog("L_WARN", "ACK/PRACK: loose_route() set invalid destination format: $du, using Request-URI: $ru\n");
                    $du = $ru;
                } else {
                    xlog("ACK/PRACK: loose_route() set destination to: $du\n");
                }
            }
        }
        
        # For BYE requests, validate destination URI after loose_route()
        # loose_route() may set $du to a domain that can't be resolved, causing 476 errors
        if (is_method("BYE")) {
            # If $du is empty or appears invalid, try to extract from Request-URI
            if ($du == "" || $du == "0") {
                xlog("L_WARN", "BYE: loose_route() set empty destination, using Request-URI: $ru\n");
                $du = $ru;
            } else {
                # Log what loose_route() set as destination for debugging
                xlog("BYE: loose_route() set destination to: $du\n");
                
                # If $du contains a domain name (not IP), it might fail DNS resolution
                # Extract domain from $du to check if it's an IP address
                $var(dest_domain) = $(du{uri.domain});
                if ($var(dest_domain) != "" && $var(dest_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                    # Destination is a domain name, not an IP - might fail DNS
                    # For BYE, prefer using Request-URI if it has an IP address
                    $var(ru_domain) = $rd;
                    if ($var(ru_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        xlog("L_WARN", "BYE: loose_route() set domain destination ($du), but Request-URI has IP ($ru), using Request-URI\n");
                        $du = $ru;
                    } else {
                        # Both are domains - try to extract Contact header as fallback
                        if ($hdr(Contact) != "") {
                            # Extract Contact URI - might have IP address
                            $var(contact_uri) = $hdr(Contact);
                            # Remove angle brackets if present
                            if ($var(contact_uri) =~ "^<(.+)>$") {
                                $var(contact_uri) = $re;
                            }
                            # Extract domain from Contact
                            if ($var(contact_uri) =~ "@([^:;>]+)") {
                                $var(contact_domain) = $re;
                                if ($var(contact_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                                    # Contact has IP - construct destination from Contact
                                    $var(contact_user) = $rU;
                                    if ($var(contact_user) == "") {
                                        $var(contact_user) = $tU;
                                    }
                                    # Extract port from Contact if present
                                    $var(contact_port) = "";
                                    if ($var(contact_uri) =~ ":([0-9]+)[;>]") {
                                        $var(contact_port) = $re;
                                    }
                                    if ($var(contact_port) != "") {
                                        $du = "sip:" + $var(contact_user) + "@" + $var(contact_domain) + ":" + $var(contact_port);
                                    } else {
                                        $du = "sip:" + $var(contact_user) + "@" + $var(contact_domain) + ":5060";
                                    }
                                    xlog("BYE: Using Contact header IP for destination: $du\n");
                                }
                            }
                        }
                    }
                }
            }
        }
        
        route(RELAY);
        exit;
    }

    # If loose_route() fails, try to route based on transaction state
    # ACK, PRACK, and BYE need special handling - they're part of existing transactions
    if (is_method("ACK|PRACK|BYE")) {
        xlog("$rm request - loose_route() failed, checking transaction state\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("$rm matches existing transaction, relaying\n");
            # For ACKs and PRACKs, try t_relay() first (uses transaction state), fallback to RELAY route
            if (is_method("ACK|PRACK")) {
                if (!t_relay()) {
                    xlog("L_ERR", "t_relay() failed for $rm, trying stateless forward\n");
                    route(RELAY);
                }
            } else {
                # For BYE, use RELAY route directly
                route(RELAY);
            }
            exit;
        } else {
            xlog("L_WARN", "$rm received but no matching transaction found, trying to relay anyway\n");
            # Must be forwarded even without transaction match (stateless forwarding)
            # This ensures message reaches the destination even if transaction expired
            route(RELAY);
            exit;
        }
    }

    xlog("L_WARN", "In-dialog request $rm - loose_route() failed and no transaction match\n");
    sl_send_reply(404, "Not Here");
    exit;
}

####### Helper Routes ########

# Endpoint lookup helper route
# Looks up endpoint location from database by username and/or AoR
# 
# Input variables:
#   $var(lookup_user) - Username to look up (required)
#   $var(lookup_aor)  - Optional AoR for exact match (e.g., "user@domain.com")
#
# Output variables:
#   $var(endpoint_ip)   - Endpoint IP address if found
#   $var(endpoint_port) - Endpoint port if found (defaults to 5060)
#   $var(endpoint_aor)  - Full AoR if found (e.g., "user@domain.com")
#   $var(lookup_success) - 1 if endpoint found, 0 if not found
#
# Usage:
#   $var(lookup_user) = "40004";
#   $var(lookup_aor) = "40004@pbx3sbc.vcloudpbx.com";  # Optional
#   route(ENDPOINT_LOOKUP);
#   if ($var(lookup_success) == 1) {
#       # Use $var(endpoint_ip), $var(endpoint_port), $var(endpoint_aor)
#   }
route[ENDPOINT_LOOKUP] {
    $var(endpoint_ip) = "";
    $var(endpoint_port) = "";
    $var(endpoint_aor) = "";
    $var(contact_uri) = "";
    $var(lookup_success) = 0;
    
    if ($var(lookup_user) == "" || $var(lookup_user) == "0" || $var(lookup_user) == "<null>") {
        return;
    }
    
    # Try exact AoR match first (if provided)
    if ($var(lookup_aor) != "") {
        $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor='" + $var(lookup_aor) + "' AND expires > NOW()";
        if (sql_query($var(query), "$avp(endpoint_ip)") && $(avp(endpoint_ip)[0]) != "") {
            $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
            $var(query) = "SELECT contact_port FROM endpoint_locations WHERE aor='" + $var(lookup_aor) + "' AND expires > NOW()";
            if (sql_query($var(query), "$avp(endpoint_port)")) {
                $var(endpoint_port) = $(avp(endpoint_port)[0]);
            }
            $var(query) = "SELECT contact_uri FROM endpoint_locations WHERE aor='" + $var(lookup_aor) + "' AND expires > NOW()";
            if (sql_query($var(query), "$avp(contact_uri)")) {
                $var(contact_uri) = $(avp(contact_uri)[0]);
            }
            $var(endpoint_aor) = $var(lookup_aor);
        }
    }
    
    # Fallback: username-only lookup
    if ($var(endpoint_ip) == "") {
        $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(lookup_user) + "@%' AND expires > NOW() LIMIT 1";
        if (sql_query($var(query), "$avp(endpoint_ip)") && $(avp(endpoint_ip)[0]) != "") {
            $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
            $var(query) = "SELECT contact_port FROM endpoint_locations WHERE aor LIKE '" + $var(lookup_user) + "@%' AND expires > NOW() LIMIT 1";
            if (sql_query($var(query), "$avp(endpoint_port)")) {
                $var(endpoint_port) = $(avp(endpoint_port)[0]);
            }
            $var(query) = "SELECT contact_uri FROM endpoint_locations WHERE aor LIKE '" + $var(lookup_user) + "@%' AND expires > NOW() LIMIT 1";
            if (sql_query($var(query), "$avp(contact_uri)")) {
                $var(contact_uri) = $(avp(contact_uri)[0]);
            }
            $var(query) = "SELECT aor FROM endpoint_locations WHERE aor LIKE '" + $var(lookup_user) + "@%' AND expires > NOW() LIMIT 1";
            if (sql_query($var(query), "$avp(endpoint_aor)")) {
                $var(endpoint_aor) = $(avp(endpoint_aor)[0]);
            }
        }
    }
    
    if ($var(endpoint_ip) != "") {
        route(VALIDATE_ENDPOINT);
        if ($var(contact_uri) == "" && $var(endpoint_aor) != "") {
            $var(contact_uri) = "sip:" + $var(endpoint_aor);
        }
        $var(lookup_success) = 1;
    }
    return;
}

# Endpoint validation helper route
# Validates endpoint IP and port, sets defaults
# 
# Input variables:
#   $var(endpoint_ip)   - Endpoint IP address (required)
#   $var(endpoint_port) - Endpoint port (optional, defaults to 5060)
#
# Output variables:
#   $var(endpoint_ip)   - Validated IP (unchanged if valid)
#   $var(endpoint_port) - Validated port (defaults to 5060 if empty/invalid)
#
# Usage:
#   $var(endpoint_ip) = "192.168.1.100";
#   $var(endpoint_port) = "";  # Will be set to 5060
#   route(VALIDATE_ENDPOINT);
route[VALIDATE_ENDPOINT] {
    # Validate IP is not empty
    if ($var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
        xlog("L_ERR", "VALIDATE_ENDPOINT: endpoint_ip is empty or invalid\n");
        return;
    }
    
    # Set default port if empty or invalid
    if ($var(endpoint_port) == "" || $var(endpoint_port) == "0") {
        $var(endpoint_port) = "5060";
    }
    
    # Route returns normally to caller (no exit needed)
}

# Build endpoint URI helper route
# Constructs destination URI ($du) and Request-URI ($ru) for routing to endpoints
# Uses stored contact_uri for Request-URI to ensure it matches Contact URI from REGISTER
#
# Input variables:
#   $var(endpoint_user)   - Username for the endpoint (required)
#   $var(endpoint_ip)     - Endpoint IP address (required)
#   $var(endpoint_port)   - Endpoint port (required, should be validated)
#   $var(endpoint_aor)    - Full AoR (user@domain) if available (optional)
#   $var(contact_uri)     - Stored Contact URI format (from REGISTER) for Request-URI matching (optional)
#
# Output variables:
#   $du - Destination URI (sip:user@ip:port) for routing
#   $ru - Request-URI (uses stored contact_uri if available, otherwise fallback to AoR format)
#
# Usage:
#   $var(endpoint_user) = "40004";
#   $var(endpoint_ip) = "192.168.1.100";
#   $var(endpoint_port) = "5060";
#   $var(endpoint_aor) = "40004@pbx3sbc.vcloudpbx.com";  # Optional
#   $var(contact_uri) = "sip:40004@pbx3sbc.vcloudpbx.com";  # Optional, from ENDPOINT_LOOKUP
#   route(BUILD_ENDPOINT_URI);
route[BUILD_ENDPOINT_URI] {
    # Build destination URI with IP:port for routing (NAT traversal)
    $du = "sip:" + $var(endpoint_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
    
    # Use stored contact_uri if available (ensures Request-URI matches Contact URI from REGISTER)
    # This fixes the "broken registrar" issue for Snom and other endpoints
    if ($var(contact_uri) != "" && $var(contact_uri) != "0") {
        $ru = $var(contact_uri);
        xlog("BUILD_ENDPOINT_URI: Using stored Contact-URI for Request-URI: $ru\n");
    } else if ($var(endpoint_aor) != "" && $var(endpoint_aor) =~ "@" && $var(endpoint_aor) !~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
        # Fallback: AoR has domain (not IP), use it directly
        $ru = "sip:" + $var(endpoint_aor);
        xlog("BUILD_ENDPOINT_URI: Using AoR directly in Request-URI (fallback): $ru\n");
    } else {
        # Last resort: extract domain from To header or use IP
        $var(endpoint_domain) = "";
        if ($var(endpoint_aor) != "" && $var(endpoint_aor) =~ "@(.+)") {
            $var(endpoint_domain) = $re;
        }
        # Try To header as fallback
        if (($var(endpoint_domain) == "" || $var(endpoint_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") && $(tu{uri.domain}) != "" && $(tu{uri.domain}) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
            $var(endpoint_domain) = $(tu{uri.domain});
        }
        if ($var(endpoint_domain) != "" && $var(endpoint_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
            $ru = "sip:" + $var(endpoint_user) + "@" + $var(endpoint_domain);
            xlog("BUILD_ENDPOINT_URI: Using extracted domain in Request-URI (fallback): $ru\n");
        } else {
            # Last resort: use IP if domain not found (shouldn't happen with proper registration)
            xlog("L_WARN", "BUILD_ENDPOINT_URI: Cannot determine domain, using IP in Request-URI (last resort): $du\n");
            $ru = $du;
        }
    }
    
    # Route returns normally to caller (no exit needed)
}

# Check if IP address is private (RFC 1918)
# Input: $var(check_ip) - IP address to check
# Output: $var(is_private) - 1 if private, 0 if public
# Covers all RFC 1918 private IP ranges:
#   Class A: 10.0.0.0 - 10.255.255.255
#   Class B: 172.16.0.0 - 172.31.255.255
#   Class C: 192.168.0.0 - 192.168.255.255
route[CHECK_PRIVATE_IP] {
    $var(is_private) = 0;
    # Class C: 192.168.0.0 - 192.168.255.255
    if ($var(check_ip) =~ "^192\\.168\\.") {
        $var(is_private) = 1;
    # Class A: 10.0.0.0 - 10.255.255.255
    } else if ($var(check_ip) =~ "^10\\.") {
        $var(is_private) = 1;
    # Class B: 172.16.0.0 - 172.31.255.255
    # 172.16-19
    } else if ($var(check_ip) =~ "^172\\.1[6-9]\\.") {
        $var(is_private) = 1;
    # 172.20-29
    } else if ($var(check_ip) =~ "^172\\.2[0-9]\\.") {
        $var(is_private) = 1;
    # 172.30-31
    } else if ($var(check_ip) =~ "^172\\.3[01]\\.") {
        $var(is_private) = 1;
    }
    return;
}

route[RELAY] {
    # Add Record-Route for INVITE requests so ACKs can follow the same path
    # This is critical for ACK handling when routing from Asterisk to endpoints
    if (is_method("INVITE")) {
        record_route();
        xlog("RELAY: Added Record-Route for INVITE to $du, Call-ID=$hdr(Call-ID)\n");
    }
    
    # For ACKs, PRACKs, BYEs, and NOTIFYs, fix destination URI to use NAT IP from endpoint database
    # Only applies if Request-URI contains private IP (endpoint behind NAT)
    # ACK/PRACK: Only if Request-URI has username (ACKs to Asterisk have no username)
    # BYE/NOTIFY: Always check if private IP
    if (is_method("ACK|PRACK|BYE|NOTIFY")) {
        $var(needs_nat_fix) = 0;
        
        # For ACK/PRACK, require username in Request-URI (ACKs to Asterisk have no username)
        if (is_method("ACK|PRACK")) {
            if ($ru =~ "^sip:[^@]+@") {
                $var(needs_nat_fix) = 1;
            }
        } else {
            # BYE/NOTIFY: always check
            $var(needs_nat_fix) = 1;
        }
        
        if ($var(needs_nat_fix) == 1) {
            $var(check_ip) = $rd;
            route(CHECK_PRIVATE_IP);
            
            if ($var(is_private) == 1 && $rU != "") {
                $var(lookup_user) = $rU;
                $var(lookup_aor) = "";
                route(ENDPOINT_LOOKUP);
                
                if ($var(lookup_success) == 1 && $var(endpoint_ip) != "" && $var(endpoint_ip) != "0" && $var(endpoint_ip) != "<null>") {
                    $du = "sip:" + $rU + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
                    xlog("RELAY: $rm - Updated destination to NAT IP: $du (was $ru)\n");
                }
            }
        }
    }
    
    # Arm failure route to handle transaction failures
    t_on_failure("1");
    
    # For non-INVITE requests (like NOTIFY), ensure transaction is created properly
    if (is_method("NOTIFY|OPTIONS")) {
        xlog("RELAY: Creating transaction for $rm to $du, Call-ID=$hdr(Call-ID)\n");
    }
    
    # For ACK and PRACK requests, ensure proper transaction-based routing
    # ACK/PRACK should use transaction state when available, but need fallback if transaction expired
    # This prevents retransmission loops where ACKs aren't properly forwarded
    if (is_method("ACK|PRACK")) {
        # Validate destination URI
        if ($du == "" || $du == "0") {
            $du = $ru;
            xlog("RELAY: $rm - Set destination URI from Request-URI: $du (was empty)\n");
        }
        
        xlog("RELAY: $rm - Attempting to relay to $du (Request-URI=$ru, Route=$hdr(Route))\n");
        
        # Try t_relay() first - it will use transaction state if available
        # ACK/PRACK should work with transaction state since they're part of the INVITE transaction
        if (!t_relay()) {
            # t_relay() failed - transaction might not exist or expired
            # For ACK/PRACK, this is unusual but can happen if transaction expired
            xlog("L_WARN", "RELAY: $rm - t_relay() failed for destination $du (transaction not found?)\n");
            
            # Try stateless forward as fallback
            # This ensures ACK/PRACK reaches destination even if transaction expired
            if (!forward()) {
                xlog("L_ERR", "RELAY: $rm - forward() also failed for destination $du\n");
                # For ACK, we can't send an error response (ACK has no response)
                # For PRACK, we could send an error, but it's better to just log and exit
                exit;
            } else {
                xlog("RELAY: $rm - Stateless forward succeeded to $du\n");
            }
        } else {
            xlog("RELAY: $rm - t_relay() succeeded (transaction found)\n");
        }
    } else if (is_method("BYE")) {
        # Validate destination URI - prefer Request-URI if $du is invalid or domain (not IP)
        if ($du == "" || $du == "0" || $du !~ "^sip:") {
            $du = $ru;
        } else {
            $var(dest_domain) = $(du{uri.domain});
            if ($var(dest_domain) != "" && $var(dest_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" && $rd =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                $du = $ru;  # Prefer Request-URI IP over domain to avoid DNS issues
            }
        }
        
        # Try t_relay() first, fallback to stateless forward if transaction expired
        if (!t_relay() && !forward()) {
            sl_send_reply(500, "Internal Server Error");
            exit;
        }
    } else {
        # For other methods, use standard t_relay()
        if (!t_relay()) {
            # Use sl_send_reply() since we're in request route, not reply route
            sl_send_reply(500, "Internal Server Error");
        } else {
            if (is_method("NOTIFY|OPTIONS")) {
                xlog("RELAY: Transaction created successfully for $rm, Call-ID=$hdr(Call-ID)\n");
            }
        }
    }
    exit;
}
    
####### Response handling (for debugging) ########

onreply_route {
    xlog("Response received: $rs $rr from $si (method=$rm, CSeq=$hdr(CSeq), To-tag=$tt, Contact=$hdr(Contact), Call-ID=$hdr(Call-ID))\n");
    
    # Fix NAT in Contact headers and SDP for responses from endpoints behind NAT
    # This is critical for RTP to work correctly - fixes private IPs to public NAT IPs
    # fix_nated_contact() fixes Contact headers in responses
    # fix_nated_sdp() with "rewrite-media-ip" flag rewrites the media IP address (c= line) in SDP
    # This ensures Asterisk receives the public NAT IP instead of private IP for RTP
    fix_nated_contact();
    if ($hdr(Content-Type) =~ "application/sdp") {
        fix_nated_sdp("rewrite-media-ip");
        xlog("Fixed NAT in SDP for response $rs from $si\n");
    }
    
    # Log OPTIONS/NOTIFY responses specifically
    if (is_method("OPTIONS|NOTIFY")) {
        xlog("OPTIONS/NOTIFY response: $rs $rr from $si, Call-ID=$hdr(Call-ID), Via=$hdr(Via), forwarding to Asterisk\n");
        # In onreply_route, transaction should already exist if we're here
        # If we get a 476 error, it means the response didn't match any transaction
        # This could be due to Via branch mismatch or transaction timeout
    }
    
    # Detailed SDP logging for 200 OK responses
    # This helps diagnose why one direction works and the other doesn't
    if ($rs == 200 && $hdr(Content-Type) =~ "application/sdp") {
        # Extract username from To header to identify the callee
        $var(to_user) = $(tu{uri.user});
        $var(from_user) = $(fu{uri.user});
        
        xlog("200 OK with SDP: From=$var(from_user), To=$var(to_user), Source=$si\n");
        
        # Diagnostic logging: Check endpoint IPs for SDP troubleshooting
        # This helps diagnose RTP issues regardless of whether call is from Asterisk or endpoint
        if ($var(to_user) != "") {
            # Look up endpoint IP from database for the callee (To header)
            $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(to_user) + "@%' AND expires > NOW() LIMIT 1";
            if (sql_query($var(query), "$avp(endpoint_ip)")) {
                if ($(avp(endpoint_ip)[0]) != "") {
                    $var(endpoint_ip) = $(avp(endpoint_ip)[0]);
                    xlog("Callee endpoint IP from database: $var(endpoint_ip) (user=$var(to_user))\n");
                }
            }
        }
        
        # Also check the caller's endpoint IP
        if ($var(from_user) != "") {
            $var(query) = "SELECT contact_ip FROM endpoint_locations WHERE aor LIKE '" + $var(from_user) + "@%' AND expires > NOW() LIMIT 1";
            if (sql_query($var(query), "$avp(caller_ip)")) {
                if ($(avp(caller_ip)[0]) != "") {
                    $var(caller_ip) = $(avp(caller_ip)[0]);
                    xlog("Caller endpoint IP from database: $var(caller_ip) (user=$var(from_user))\n");
                }
            }
        }
    }
    
    # Log transaction state for debugging
    if ($rs >= 100 && $rs < 200) {
        xlog("Provisional response $rs received, transaction should remain active\n");
        # For provisional responses, explicitly exit to let transaction module handle forwarding
        # The transaction module will automatically forward and keep transaction alive
        exit;
    } else if ($rs >= 200 && $rs < 300) {
        xlog("Final success response $rs received\n");
        exit;
    } else if ($rs >= 300) {
        xlog("Final error response $rs received\n");
        exit;
    }
    # If we get here, exit to let transaction module handle it
    exit;
}

failure_route[1] {
    xlog("L_ERR", "Transaction failure: method=$rm, Call-ID: $hdr(Call-ID), From=$fu, To=$tu, Response code=$rs, Reason=$rr\n");
    # Log more details about the failure
    if ($rs == 408) {
        xlog("L_ERR", "408 Request Timeout generated - transaction timed out waiting for response\n");
    }
    # t_relay will handle forwarding the failure response automatically
    exit;
}

####### Dispatcher events (visibility) ########

# Note: Event routes for dispatcher module are not currently configured
# Event route syntax varies by OpenSIPS version and may require specific module configuration
# If needed, check OpenSIPS documentation for event route syntax for your version

