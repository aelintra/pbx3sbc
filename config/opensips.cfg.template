#!opensips
#
# OpenSIPS SIP Edge Router Configuration Template
# This configuration provides SIP edge routing functionality for Asterisk PBX backends
#
# Based on requirements in REQUIREMENTS-FOR-OPENSIPS.md
# Troubleshooting notes in TROUBLESHOOTING-OPTIONS-ROUTING.md
#

####### Global Parameters #########

# The default log_level is usually enough for most things but you can increase
# it here for lower levels of visibility 
#log_level=4

# OpenSIPS parameter configuration
# Debug level can be set via command line: opensips -D 3
# Or via modparam for specific modules

# Module path (Ubuntu/Debian package location)
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules"

# Listen on all interfaces (socket replaces deprecated listen)
socket=udp:0.0.0.0:5060

# Set advertised address (replace with your OpenSIPS server's IP address)
# This fixes the Via header showing 0.0.0.0
# For cloud deployments, this MUST be your public IP address
# Use --advertised-ip parameter during installation, or manually edit after installation
# The install.sh script will replace CHANGE_ME with the provided IP address
advertised_address="CHANGE_ME"

####### Modules ########

# Core modules
# Note: is_method(), has_totag() are built into OpenSIPS core
# Note: siputils and sanity modules don't exist in OpenSIPS - functions are built-in
# Note: pv (pseudo-variables) and xlog are built into OpenSIPS core
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
# Transport protocol - required for socket binding
loadmodule "proto_udp.so"
loadmodule "db_mysql.so"
# SQL operations module for database queries
loadmodule "sqlops.so"
loadmodule "dispatcher.so"
loadmodule "sipmsgops.so"
# NAT traversal module for fixing Contact headers and SDP
loadmodule "nathelper.so"
# Dialog module for CDR (Call Detail Records) - must be loaded before acc module
loadmodule "dialog.so"
# Accounting module for CDR (Call Detail Records)
loadmodule "acc.so"
# User location module for endpoint registration tracking (usrloc migration)
loadmodule "usrloc.so"
# Signaling module (required dependency for registrar module)
loadmodule "signaling.so"
# Registrar module provides save() and lookup() functions (uses usrloc as backend)
loadmodule "registrar.so"
# Domain module for domain management (used with usrloc for multi-tenant support)
loadmodule "domain.so"
# HTTP server module (required for Prometheus module)
loadmodule "httpd.so"
# Prometheus module for metrics export (requires opensips-prometheus-module package)
loadmodule "prometheus.so"
# Pike module for flood detection (Phase 0 testing)
loadmodule "pike.so"

####### Module Parameters ########

# --- NAT Environment Detection ---
# Auto-detected by install script based on advertised_address
# Install script checks if advertised_address is public IP (not RFC 1918)
# If public IP: NAT_ENVIRONMENT_AUTO_DETECT will be set to "1" (NAT fixes enabled)
# If private IP or CHANGE_ME: NAT_ENVIRONMENT_AUTO_DETECT will be set to "0" (NAT fixes disabled)
# Install script replaces NAT_ENVIRONMENT_AUTO_DETECT placeholder with detected value
#NAT_ENVIRONMENT_AUTO_DETECT=0

# --- MySQL routing database ---
# SQL operations module connection for sql_query() function
modparam("sqlops", "db_url", "mysql://opensips:your-password@localhost/opensips")

# --- Dispatcher (health checks via SIP OPTIONS) ---
modparam("dispatcher", "db_url", "mysql://opensips:your-password@localhost/opensips")

modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_threshold", 2)
# Note: ds_inactive_threshold doesn't exist in OpenSIPS dispatcher module
# Note: ds_ping_reply_codes is called options_reply_codes in OpenSIPS
modparam("dispatcher", "options_reply_codes", "200")

# --- Dialog module (required for CDR mode) ---
modparam("dialog", "db_url", "mysql://opensips:your-password@localhost/opensips")
modparam("dialog", "db_mode", 2)
# db_mode: 0 = no DB, 1 = DB only, 2 = cached DB (we use 2 for cached DB - better for CDR correlation)
# db_update_period: How often to flush cached dialogs to DB (seconds, default 60)
# Set to lower value for more frequent writes (useful for monitoring)
modparam("dialog", "db_update_period", 10)

# --- Accounting (CDR) ---
modparam("acc", "db_url", "mysql://opensips:your-password@localhost/opensips")
modparam("acc", "early_media", 0)
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 1)
# Extra fields for billing: capture From and To SIP URIs
# Format: backend:tag->column_name;tag->column_name
# $fu = From URI, $tu = To URI
# This modparam tells the acc module which extra columns exist in the database
modparam("acc", "extra_fields", "db:from_uri->from_uri;to_uri->to_uri")
# Note: from_uri and to_uri columns are added to acc table via init-database.sh
# These are populated via $acc_extra() in the script (see INVITE handling)

# --- User location module (usrloc migration) ---
modparam("usrloc", "db_url", "mysql://opensips:your-password@localhost/opensips")
# working_mode_preset: Pre-configured modes for single-instance or clustered setups
# single-instance-sql-write-through: Writes to database immediately (high reliability, slower performance)
# This ensures save() writes to DB immediately, allowing SQL UPDATE to work right away
# This solves the issue where cached modes might have records still in memory
# Trade-off: Slower performance under high load (every operation hits DB)
# Note: db_mode is deprecated in OpenSIPS 3.6+, use working_mode_preset instead
# Other options: single-instance-no-db (memory only), single-instance-sql-write-back (cached),
#                sql-only (no memory cache), full-sharing-cluster (clustering)
modparam("usrloc", "working_mode_preset", "single-instance-sql-write-through")
# use_domain: 1 = domain-aware (REQUIRED for multi-tenant - allows same username across domains)
modparam("usrloc", "use_domain", 1)
# nat_bflag: Flag name for NAT detection (used with nathelper module)
modparam("usrloc", "nat_bflag", "NAT")
# timer_interval: How often to flush cached contacts to DB (seconds, default 60)
# Note: With working_mode_preset=single-instance-sql-write-through, this parameter is not used (writes go directly to DB)
# Keeping it for compatibility, but it has no effect in write-through mode
modparam("usrloc", "timer_interval", 10)
# regen_broken_contactid: Regenerate invalid/broken contact_id values on startup
# This fixes contact_id values that are out of range or invalid (e.g., from schema migration)
modparam("usrloc", "regen_broken_contactid", 1)

# --- NAT Helper module (NAT traversal) ---
# received_avp: AVP name where nathelper stores the received IP:port from REGISTER requests
# This must match the received_avp in registrar module for proxy-registrar mode to work
# fix_nated_register() populates this AVP with the endpoint's public NAT IP:port
# Format: The AVP will contain IP:port (e.g., 74.83.23.44:5060), which we convert to SIP URI format
modparam("nathelper", "received_avp", "$avp(reg_received)")

# --- Registrar module (provides save() and lookup() functions) ---
# mcontact_avp: AVP name where registrar module stores modified Contact from main registrar's 200 OK reply
# When the main registrar modifies the Contact header in its 200 OK reply, registrar module stores it here
# This allows save() in onreply_route to use the modified Contact (if reply Contact is modified)
# NOTE: If reply Contact is <null> or missing, save() cannot extract contact info and will fail
modparam("registrar", "mcontact_avp", "$avp(mcontact)")

# received_avp: AVP name containing the SIP URI to populate the 'received' field in location table
# In proxy-registrar mode, save() uses this AVP to populate the received column automatically
# This MUST match the received_avp in nathelper module (both use $avp(reg_received))
# The AVP should contain a SIP URI format: sip:IP:port;transport=udp (e.g., sip:74.83.23.44:5060;transport=udp)
# This is critical for NAT traversal - allows lookup() to route OPTIONS/NOTIFY to endpoints behind NAT
# fix_nated_register() populates the AVP, but we convert it to SIP URI format for registrar module
modparam("registrar", "received_avp", "$avp(reg_received)")

# --- Domain module (multi-tenant support) ---
modparam("domain", "db_url", "mysql://opensips:your-password@localhost/opensips")
# db_mode: 0 = no DB, 1 = DB only, 2 = cached DB (we use 2 for cached DB)
modparam("domain", "db_mode", 2)
# domain_table: Name of the domain table (default: "domain")
modparam("domain", "domain_table", "domain")
# domain_col: Column name for domain (default: "domain")
modparam("domain", "domain_col", "domain")

# --- HTTP Server (Required for Prometheus module) ---
# Configure HTTP server for Prometheus metrics endpoint
# Listen on all interfaces, port 8888
modparam("httpd", "ip", "0.0.0.0")
modparam("httpd", "port", 8888)
# Note: For localhost-only access, use: modparam("httpd", "ip", "127.0.0.1")

# --- Prometheus Module (Metrics Export) ---
# Metrics endpoint path (default: /metrics)
# Access at: http://localhost:8888/metrics (or http://<server-ip>:8888/metrics)
modparam("prometheus", "root", "metrics")
# Metric prefix (default: opensips) - prepended to all metric names
modparam("prometheus", "prefix", "opensips")
# Group mode: 1 = include group in metric name (e.g., opensips_core_rcv_requests)
# Group mode: 0 = exclude group (e.g., opensips_rcv_requests)
modparam("prometheus", "group_mode", 1)
# Export statistics (can be defined multiple times)
# Syntax: "group:" exports all stats in that group, or specific stat names like "active_dialogs"
# You can mix groups and specific stat names in the same modparam call
#
# Example: modparam("prometheus", "statistics", "active_dialogs load: stats:")
#   - Exports specific stat "active_dialogs"
#   - Exports all stats in "load" group
#   - Exports all stats in "stats" group
#
# Current configuration uses group-based exports (recommended for comprehensive monitoring):
# Core statistics (all core stats)
modparam("prometheus", "statistics", "core:")
# Transaction statistics (all transaction stats)
modparam("prometheus", "statistics", "tm:")
# Dialog statistics (all dialog stats)
modparam("prometheus", "statistics", "dialog:")
# Dispatcher statistics (all dispatcher stats)
modparam("prometheus", "statistics", "dispatcher:")
# User location statistics (all usrloc stats)
modparam("prometheus", "statistics", "usrloc:")
# Accounting statistics (all accounting stats)
modparam("prometheus", "statistics", "acc:")

# Alternative: Export specific statistics only (uncomment to use instead of groups above)
# This approach exports only selected metrics (useful for reducing metric volume)
# Uncomment the lines below and comment out the group-based exports above if needed:
# modparam("prometheus", "statistics", "core:rcv_requests core:rcv_replies core:drop_requests")
# modparam("prometheus", "statistics", "tm:active_transactions tm:transactions")
# modparam("prometheus", "statistics", "dialog:active_dialogs dialog:early_dialogs")
# modparam("prometheus", "statistics", "dispatcher:active_destinations dispatcher:inactive_destinations")
# modparam("prometheus", "statistics", "usrloc:registered_users")
# modparam("prometheus", "statistics", "acc:acc_requests")

# Or export ALL statistics (uncomment to enable - exports everything)
# modparam("prometheus", "statistics", "all")
# Note: If "all" is specified, other statistics parameters are ignored

# --- Pike module (flood detection) - Phase 0 Testing ---
# NOTE: This is a TEST configuration for Phase 0 evaluation
# Configuration will be refined based on testing results
# sampling_time_unit: Time period for sampling (default 2 seconds; smaller = better detection of peaks, but slower)
modparam("pike", "sampling_time_unit", 2)
# reqs_density_per_unit: Request threshold before blocking an IP (16 requests per 2 seconds = 8 req/sec)
modparam("pike", "reqs_density_per_unit", 16)
# remove_latency: Cleanup timing for old entries (4 sampling units = 8 seconds block duration)
modparam("pike", "remove_latency", 4)
# pike_log_level: Logging detail level (0=none, 1=blocked IPs, 2=all)
modparam("pike", "pike_log_level", 1)
# Note: Using automatic mode (pike installs internal hooks automatically)
# Manual mode would require calling pike_check_req() in routing script

# --- Transaction timers ---
# Note: fr_timer is not a modparam in OpenSIPS - transaction timeouts are handled differently
# restart_fr_on_each_reply: reset final response timer on each provisional response
modparam("tm", "restart_fr_on_each_reply", 1)
# onreply_avp_mode: Enable AVP persistence across transaction boundaries for onreply_route
# This is required for received_avp to be available in onreply_route when using proxy-registrar mode
# Value 1 enables AVP persistence (AVPs set in request route are available in onreply_route)
modparam("tm", "onreply_avp_mode", 1)
# T1_timer: initial retransmission period (2 seconds = 2000ms)
# Note: OpenSIPS uses T1_timer instead of retr_timer1
modparam("tm", "T1_timer", 2000)
# T2_timer: maximum retransmission period (8 seconds = 8000ms)
# Note: OpenSIPS uses T2_timer instead of retr_timer2
modparam("tm", "T2_timer", 8000)

# --- Response handling ---
# OpenSIPS handles responses differently - ensure proper forwarding

####### Routing Logic ########

route {
    # ---- Log ALL requests at the very start for debugging ----
    xlog("REQUEST: $rm from $si:$sp to $ru (Call-ID: $hdr(Call-ID))\n");
    
    # Log SDP details for INVITE requests to diagnose audio issues
    if (is_method("INVITE") && $hdr(Content-Type) =~ "application/sdp") {
        $var(from_user) = $(fu{uri.user});
        $var(to_user) = $(tu{uri.user});
        xlog("INVITE with SDP: From=$var(from_user)@$si, To=$var(to_user)@$rd\n");
    }

    # ---- Basic hygiene ----
    if (!mf_process_maxfwd_header(10)) {
        # Phase 1.1: Log max-forwards exceeded to database for security tracking
        $var(query) = "INSERT INTO door_knock_attempts " +
            "(domain, source_ip, source_port, user_agent, method, request_uri, reason, attempt_time) " +
            "VALUES ('" + $rd + "', '" + $si + "', " + $sp + ", " +
            "'" + $ua + "', '" + $rm + "', '" + $ru + "', 'max_forwards_exceeded', NOW())";
        if (sql_query($var(query))) {
            xlog("Max-Forwards exceeded logged to database - from $si:$sp\n");
        }
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    # Note: sanity_check() module not available in OpenSIPS
    # Basic validation is handled by core parsing

    # ---- Drop known scanners ----
    if ($ua =~ "sipvicious|friendly-scanner|sipcli|nmap") {
        # Phase 1.1: Log scanner detection to database for security tracking
        $var(query) = "INSERT INTO door_knock_attempts " +
            "(domain, source_ip, source_port, user_agent, method, request_uri, reason, attempt_time) " +
            "VALUES ('" + $rd + "', '" + $si + "', " + $sp + ", " +
            "'" + $ua + "', '" + $rm + "', '" + $ru + "', 'scanner_detected', NOW())";
        if (sql_query($var(query))) {
            xlog("Scanner detected and logged to database - user_agent=$ua from $si:$sp\n");
        }
        exit;
    }

    # ---- In-dialog requests ----
    # Check if To tag exists (in-dialog request)
    # OpenSIPS uses $to_tag pseudo-variable for To header tag
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    # ---- Allowed methods only ----
    if (!is_method("REGISTER|INVITE|ACK|BYE|CANCEL|OPTIONS|NOTIFY|SUBSCRIBE|PRACK")) {
        # Phase 1.1: Log method not allowed to database for security tracking
        $var(query) = "INSERT INTO door_knock_attempts " +
            "(domain, source_ip, source_port, user_agent, method, request_uri, reason, attempt_time) " +
            "VALUES ('" + $rd + "', '" + $si + "', " + $sp + ", " +
            "'" + $ua + "', '" + $rm + "', '" + $ru + "', 'method_not_allowed', NOW())";
        if (sql_query($var(query))) {
            xlog("Method not allowed logged to database - method=$rm from $si:$sp\n");
        }
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }

    # ---- Handle CANCEL early (before domain check) ----
    # CANCEL needs to match existing INVITE transaction
    if (is_method("CANCEL")) {
        xlog("CANCEL received from $si:$sp for Call-ID: $hdr(Call-ID), CSeq=$hdr(CSeq), From=$fu, To=$tu\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("CANCEL matches existing transaction, forwarding to cancel INVITE\n");
        } else {
            xlog("L_WARN", "CANCEL received but no matching transaction found\n");
            sl_send_reply(481, "Call/Transaction Does Not Exist");
            exit;
        }
        # Forward CANCEL to cancel the INVITE transaction
        route(RELAY);
        exit;
    }

    # ---- Handle OPTIONS and NOTIFY from Asterisk backends (to endpoints) ----
    # Asterisk sends OPTIONS to registered endpoints for health checks and NAT keepalive
    # Asterisk sends NOTIFY for event notifications (e.g., message waiting indicators)
    # These need to be routed back to the actual endpoint IP
    if (is_method("OPTIONS|NOTIFY")) {
        # Check if this is coming from a known dispatcher destination (Asterisk backend)
        # Query database to see if source IP matches any dispatcher destination
        $var(source_ip) = $si;
        xlog("OPTIONS/NOTIFY received from $si, checking if from dispatcher\n");
        
        # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
        # If so, try endpoint lookup regardless of dispatcher check
        # Request-URI format: sip:401@192.168.1.138:56931 or sip:401@192.168.1.138
        $var(should_try_endpoint) = 0;
        
        # Check if Request-URI has a username
        if ($rU != "") {
            # Check if Request-URI domain is an IP address (contains digits and dots, not a domain name)
            # Simple heuristic: if domain contains only digits, dots, and colons, it's likely an IP
            if ($rd =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                $var(should_try_endpoint) = 1;
                xlog("OPTIONS/NOTIFY Request-URI looks like endpoint: $rU@$rd\n");
            }
        }
        
        # Also check if source IP is from a known dispatcher destination
        # For now, we'll try endpoint lookup if Request-URI looks like an endpoint
        # or if we want to check dispatcher destinations, we can add that logic here
        
        if ($var(should_try_endpoint) > 0) {
            
                    # Extract endpoint identifier
                    # Try To header first (may have domain), fallback to Request-URI username
                    $var(endpoint_user) = $tU;
                    if ($var(endpoint_user) == "") {
                        $var(endpoint_user) = $rU;
                    }
                    
                    # Try to get domain from To header
                    $var(to_domain) = $(tu{uri.domain});
                    $var(lookup_uri) = "";
                    
                    # Check if To header domain is an IP address (not a domain name)
                    if ($var(to_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # To header has IP, not domain - determine domain from Asterisk source IP
                        # This is CRITICAL for multi-tenant deployments (same extension numbers across customers)
                        route(GET_DOMAIN_FROM_SOURCE_IP);
                        if ($var(domain_detection_success) == 1) {
                            # Domain found from source IP - use domain-specific lookup (CORRECT for multi-tenant)
                            $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@" + $var(domain_from_source);
                            xlog("OPTIONS/NOTIFY: To header has IP ($var(to_domain)), determined domain from source IP: $var(domain_from_source), using domain-specific lookup: $var(lookup_uri)\n");
                        } else {
                            # Domain not found - use SQL wildcard lookup as fallback (with warning)
                            $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@*";
                            xlog("L_WARN", "OPTIONS/NOTIFY: To header has IP ($var(to_domain)), but could not determine domain from source IP $si, using wildcard lookup (may route to wrong customer in multi-tenant)\n");
                        }
                    } else if ($var(to_domain) != "") {
                        # To header has domain - use domain-specific lookup (CORRECT for multi-tenant)
                        $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@" + $var(to_domain);
                        xlog("OPTIONS/NOTIFY: Using domain-specific lookup: $var(lookup_uri)\n");
                    } else {
                        # No domain in To header - try to determine from source IP
                        route(GET_DOMAIN_FROM_SOURCE_IP);
                        if ($var(domain_detection_success) == 1) {
                            # Domain found from source IP - use domain-specific lookup (CORRECT for multi-tenant)
                            $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@" + $var(domain_from_source);
                            xlog("OPTIONS/NOTIFY: No domain in To header, determined domain from source IP: $var(domain_from_source), using domain-specific lookup: $var(lookup_uri)\n");
                        } else {
                            # Domain not found - use SQL wildcard lookup as fallback (with warning)
                            $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@*";
                            xlog("L_WARN", "OPTIONS/NOTIFY: No domain in To header and could not determine domain from source IP $si, using wildcard lookup (may route to wrong customer in multi-tenant)\n");
                        }
                    }
                    
                    xlog("OPTIONS/NOTIFY from Asterisk $si, looking up endpoint: $var(lookup_uri) (user: $var(endpoint_user))\n");
                    
                    # Use OpenSIPS lookup() function to find endpoint in location table
                    # lookup() uses Request-URI to find contacts, so we need to set it first
                    # Save original Request-URI (to restore if lookup fails)
                    $var(original_ru) = $ru;
                    
                    # Check if we have a wildcard lookup (contains @*)
                    if ($var(lookup_uri) =~ "@\\*") {
                        # Wildcard lookup - need to use SQL query for now
                        # TODO: Improve this to determine domain from dispatcher setid
                        xlog("OPTIONS/NOTIFY: Wildcard lookup detected, using SQL fallback\n");
                        $var(query) = "SELECT contact FROM location WHERE username='" + $var(endpoint_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                        if (sql_query($var(query), "$avp(contact_uri)") && $(avp(contact_uri)[0]) != "") {
                            $du = $(avp(contact_uri)[0]);
                            $ru = $du;
                            xlog("OPTIONS/NOTIFY: SQL lookup found contact: $du\n");
                            route(RELAY);
                            exit;
                        } else {
                            $ru = $var(original_ru);
                            xlog("OPTIONS/NOTIFY: SQL lookup returned no results\n");
                        }
                    } else {
                        # Domain-specific lookup - set Request-URI and use lookup()
                        # CRITICAL: Set $ru to lookup_uri BEFORE calling lookup()
                        # lookup() will update $ru with the contact if found
                        $ru = $var(lookup_uri);
                        # Save what we set $ru to, so we can detect if lookup() changed it
                        $var(ru_before_lookup) = $ru;
                        
                        # lookup() sets $du automatically if contact found
                        # NOTE: In OpenSIPS 3.6, if lookup() returns TRUE but $du is null,
                        # it means $ru was updated with the registered contact (local contact, no outbound proxy)
                        $var(lookup_success) = 0;
                        $var(du_is_valid) = 0;
                        $var(ru_is_valid) = 0;
                        
                        if (lookup("location")) {
                            # Contact found - $du is set automatically by lookup(), OR $ru is updated with contact
                            xlog("OPTIONS/NOTIFY: lookup() returned TRUE - contact found\n");
                            xlog("OPTIONS/NOTIFY: After lookup() - $du=$du, $ru=$ru, ru_before_lookup=$var(ru_before_lookup)\n");
                            $var(lookup_success) = 1;
                            
                            # Check if $du is set (outbound proxy case)
                            if ($du != "" && $du != "<null>" && $du != "0" && $du =~ "^sip:") {
                                $var(du_is_valid) = 1;
                                xlog("OPTIONS/NOTIFY: $du is valid - using outbound proxy destination\n");
                            } else {
                                # $du is null - check if $ru was updated with contact (local contact case)
                                xlog("OPTIONS/NOTIFY: $du is null - checking if $ru was updated by lookup()\n");
                                xlog("OPTIONS/NOTIFY: $ru changed from $var(ru_before_lookup) to $ru\n");
                                
                                # Check if $ru was changed by lookup() (contains contact, not the lookup URI)
                                if ($ru != "" && $ru != $var(ru_before_lookup) && $ru =~ "^sip:") {
                                    # Extract domain/IP from $ru to validate
                                    $var(ru_domain) = $(ru{uri.domain});
                                    if ($var(ru_domain) != "" && ($var(ru_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" || $var(ru_domain) !~ "^[0-9]")) {
                                        $var(ru_is_valid) = 1;
                                        # Set $du = $ru for routing (local contact, no outbound proxy)
                                        $du = $ru;
                                        xlog("OPTIONS/NOTIFY: $ru is valid contact - using $ru as destination (local contact, no outbound proxy)\n");
                                    } else {
                                        xlog("OPTIONS/NOTIFY: $ru domain is invalid: $var(ru_domain)\n");
                                    }
                                } else {
                                    xlog("OPTIONS/NOTIFY: $ru was not updated by lookup() (still $var(ru_before_lookup)) - will use SQL fallback\n");
                                }
                            }
                        } else {
                            # Restore original Request-URI
                            $ru = $var(original_ru);
                            xlog("OPTIONS/NOTIFY: lookup() returned FALSE - no contact found for $var(lookup_uri)\n");
                        }
                        
                        # If lookup() succeeded and either $du or $ru is valid, route immediately
                        if ($var(lookup_success) == 1 && ($var(du_is_valid) == 1 || $var(ru_is_valid) == 1)) {
                            # Request-URI is already set to destination by lookup()
                            xlog("OPTIONS/NOTIFY: Routing $rm from Asterisk $si to endpoint $du, Request-URI=$ru, Call-ID=$hdr(Call-ID)\n");
                            route(RELAY);
                            exit;
                        }
                        
                        # If we get here, either lookup() returned FALSE or $du was empty/invalid
                        # RACE CONDITION FIX: Try SQL fallback to check database directly (handles timing issues)
                        # Extract domain from lookup_uri (format: sip:user@domain)
                        # Use domain_from_source if available (from earlier detection), otherwise extract from lookup_uri
                        $var(fallback_domain) = "";
                        if ($var(domain_from_source) != "") {
                            $var(fallback_domain) = $var(domain_from_source);
                        } else if ($var(to_domain) != "" && $var(to_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                            $var(fallback_domain) = $var(to_domain);
                        } else if ($var(lookup_uri) =~ "@([^:>]+)") {
                            $var(fallback_domain) = $re;
                        }
                        
                        if ($var(fallback_domain) != "") {
                                # Try SQL query as fallback - check DB directly (bypasses memory cache)
                                xlog("OPTIONS/NOTIFY: Trying SQL fallback for domain-specific lookup (race condition handling)\n");
                                xlog("OPTIONS/NOTIFY: SQL fallback query for user=$var(endpoint_user), domain=$var(fallback_domain)\n");
                                # Use received field if available (NAT traversal), otherwise use contact field
                                $var(query) = "SELECT COALESCE(received, contact) FROM location WHERE username='" + $var(endpoint_user) + "' AND domain='" + $var(fallback_domain) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                                if (sql_query($var(query), "$avp(fallback_contact)")) {
                                    xlog("OPTIONS/NOTIFY: SQL fallback query executed, checking result\n");
                                    if ($(avp(fallback_contact)[0]) != "" && $(avp(fallback_contact)[0]) != "<null>") {
                                        # Extract IP:port from received or contact field using SQL (regex $re doesn't work)
                                        $var(contact_value) = $(avp(fallback_contact)[0]);
                                        xlog("OPTIONS/NOTIFY: SQL fallback found contact value: [$var(contact_value)]\n");
                                        $var(extracted_ip) = "";
                                        $var(extracted_port) = "";
                                        
                                        # Extract IP:port using standard OpenSIPS URI transformations
                                        # Works for both received field format (sip:IP:port;transport=udp) and contact field format (sip:user@IP:port)
                                        if ($var(contact_value) =~ "^sip:") {
                                            # Use standard OpenSIPS URI transformations instead of SQL queries
                                            # Assign URI to $ru to enable transformations
                                            $ru = $var(contact_value);
                                            $var(extracted_ip) = $(ru{uri.host});   # Extract host/IP using standard transformation
                                            $var(extracted_port) = $(ru{uri.port}); # Extract port using standard transformation
                                            
                                            # If port is empty, default to 5060
                                            if ($var(extracted_port) == "" || $var(extracted_port) == "<null>") {
                                                $var(extracted_port) = "5060";
                                            }
                                        }
                                        
                                        # Validate and construct destination URI
                                        if ($var(extracted_ip) != "" && $var(extracted_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                                            # Construct destination URI
                                            if ($var(extracted_port) != "" && $var(extracted_port) != "<null>") {
                                                $du = "sip:" + $var(endpoint_user) + "@" + $var(extracted_ip) + ":" + $var(extracted_port);
                                            } else {
                                                $du = "sip:" + $var(endpoint_user) + "@" + $var(extracted_ip) + ":5060";
                                            }
                                            $ru = $du;
                                            xlog("OPTIONS/NOTIFY: SQL fallback found contact: $du (race condition resolved)\n");
                                            route(RELAY);
                                            exit;
                                        } else {
                                            xlog("L_WARN", "OPTIONS/NOTIFY: SQL fallback found contact value but extraction failed: [$var(contact_value)], extracted_ip=[$var(extracted_ip)], extracted_port=[$var(extracted_port)]\n");
                                        }
                                    } else {
                                        xlog("L_WARN", "OPTIONS/NOTIFY: SQL fallback query returned empty or null result for user=$var(endpoint_user), domain=$var(fallback_domain)\n");
                                    }
                                } else {
                                    xlog("L_WARN", "OPTIONS/NOTIFY: SQL fallback query failed for user=$var(endpoint_user), domain=$var(fallback_domain)\n");
                                }
                            }
                    }
                    
                    # Endpoint lookup failed - handle fallback
                    xlog("L_WARN", "$rm from Asterisk $si to $var(endpoint_aor) - endpoint location not found in database\n");
                    if (is_method("OPTIONS")) {
                        sl_send_reply(200, "OK");
                    } else {
                        # For NOTIFY, try to route based on Contact header if available
                        # Extract IP and port from Contact header using regex
                        $var(notify_ip) = "";
                        $var(notify_port) = "";
                        if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                            $var(notify_ip) = $re;
                            if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                                $var(notify_port) = $re;
                            }
                        }
                        
                        if ($var(notify_ip) != "" && $var(notify_ip) != $si) {
                            $du = "sip:" + $tU + "@" + $var(notify_ip);
                            if ($var(notify_port) != "") {
                                $du = $du + ":" + $var(notify_port);
                            } else {
                                $du = $du + ":5060";
                            }
                            xlog("Routing $rm to $du (fallback from Contact header)\n");
                            route(RELAY);
                        } else {
                            sl_send_reply(404, "Not Found");
                        }
                    }
                    exit;
        }
        
        # If we get here, Request-URI doesn't look like an endpoint, continue normal routing
        xlog("OPTIONS/NOTIFY from $si - Request-URI doesn't look like endpoint, continuing normal routing\n");
    }
    
    # ---- Handle REGISTER to track endpoint locations (usrloc migration) ----
    if (is_method("REGISTER")) {
        if ($hdr(Contact) != "") {
            # NOTE: nat_uac_test() causes runtime errors in OpenSIPS 3.6.3
            # Error: "Unknown flag: 1" / "Unknown flag: 19" when called at runtime
            # Reverting to manual NAT detection which works reliably
            
            # Phase 1.1: Store request metadata for security tracking (failed registration logging)
            # These AVPs will be available in onreply_route via onreply_avp_mode=1 (configured in tm module)
            # Store source IP, port, and user agent for security tracking
            $avp(reg_source_ip) = $si;
            $avp(reg_source_port) = $sp;
            $avp(reg_user_agent) = $ua;
            xlog("REGISTER: Stored request metadata for security tracking - source=$si:$sp, user_agent=$ua\n");
            
            # Fix NAT in REGISTER request (needed for proper Contact header handling)
            # This updates Contact header with public IP if behind NAT
            # fix_nated_register() also populates $avp(reg_received) with IP:port format (via nathelper received_avp parameter)
            fix_nated_register();
            
            # Store original Contact header (with NAT fixes) in AVP for diagnostic purposes
            # NOTE: save() extracts Contact from the REPLY, not the request
            # If reply Contact is <null>, save() cannot work (this is a limitation of proxy-registrar mode)
            # We store request Contact here only for logging/diagnostics
            $avp(reg_contact) = $hdr(Contact);
            
            # CRITICAL: Capture original request source IP:port for NAT traversal
            # FORCE RPORT BEHAVIOR: If endpoint is behind NAT, always use actual source IP:port
            # This ensures responses go to the correct NAT-mapped port even if phone doesn't send rport parameter
            # This effectively "forces" rport behavior for all NAT endpoints
            route(CHECK_NAT_ENVIRONMENT);
            
            $var(received_value) = "";
            if ($var(enable_nat_fixes) == 1) {
                # Endpoint is behind NAT - FORCE use of actual source IP:port (rport behavior)
                # This ensures responses always go to the correct NAT-mapped port
                # regardless of whether the phone sent rport parameter
                $var(received_value) = "sip:" + $si + ":" + $sp + ";transport=udp";
                xlog("REGISTER: NAT detected - forcing rport behavior: using actual source $si:$sp (endpoint may not have sent rport parameter)\n");
            } else {
                # Endpoint is NOT behind NAT - use fix_nated_register() result if available
                # fix_nated_register() may have populated $avp(reg_received) with IP:port format
                # But registrar module expects SIP URI format: sip:IP:port;transport=udp
                # Convert to SIP URI format if needed (check if it's already in SIP URI format or just IP:port)
                if ($avp(reg_received) != "" && $avp(reg_received) != "<null>") {
                    # fix_nated_register() may have populated it - check format
                    if ($avp(reg_received) =~ "^sip:") {
                        # Already in SIP URI format - check if it has transport parameter
                        if ($avp(reg_received) =~ ";transport=") {
                            # Already has transport parameter - use as-is
                            $var(received_value) = $avp(reg_received);
                        } else {
                            # Has sip: prefix but missing transport - add it
                            $var(received_value) = $avp(reg_received) + ";transport=udp";
                        }
                    } else {
                        # IP:port format - convert to SIP URI
                        $var(received_value) = "sip:" + $avp(reg_received) + ";transport=udp";
                    }
                } else {
                    # Fallback: Use current source IP:port (shouldn't happen if fix_nated_register() worked)
                    $var(received_value) = "sip:" + $si + ":" + $sp + ";transport=udp";
                }
            }
            
            # Set AVP in SIP URI format for registrar module
            # Use transaction-scoped AVP (tu) to ensure it persists across transaction boundaries
            $avp(tu:reg_received) = $var(received_value);
            # Also set regular AVP (registrar module uses this via received_avp parameter)
            $avp(reg_received) = $var(received_value);
            xlog("REGISTER: Captured original request source for received field: $avp(reg_received) (endpoint public NAT IP:port as SIP URI)\n");
            
            # Arm reply handler to save location only on successful registration (2xx)
            # This follows OpenSIPS proxy-registrar pattern: save AFTER successful reply
            # The save() function will use contact information from the 200 OK reply
            # (including any modifications from the main registrar) via mcontact_avp
            # If reply Contact is <null>, it will use $avp(mcontact) from the request
            t_on_reply("handle_reply_reg");
            
            xlog("REGISTER: Request from $si:$sp, To=$tU@$(tu{uri.domain}), Contact=$hdr(Contact), will save location on 2xx reply\n");
        }
    }

    route(DOMAIN_CHECK);
}

####### Domain validation / door-knocker protection ########

route[DOMAIN_CHECK] {

    # OpenSIPS: Request-URI domain is $rd (lowercase), not $rD
    $var(domain) = $rd;

    if ($var(domain) == "") {
        exit;
    }

    # Check if Request-URI looks like an endpoint (has username and IP address, not domain)
    # This handles INVITE from Asterisk to endpoints (e.g., sip:402@192.168.1.232:5060)
    # Note: $rd might include port (e.g., 192.168.1.138:56931), so we check just the IP part
    # Extract just the IP address part (before any colon)
    $var(request_domain) = $rd;
    if ($var(request_domain) =~ "^([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
        $var(request_ip) = $re;
        xlog("INVITE Request-URI looks like endpoint: $rU@$var(request_domain), attempting endpoint lookup\n");
        
        # Extract username from Request-URI
        $var(endpoint_user) = $rU;
        
        # Determine domain from Asterisk source IP (CRITICAL for multi-tenant support)
        # This ensures we route to the correct customer when same extension numbers exist across domains
        route(GET_DOMAIN_FROM_SOURCE_IP);
        $var(original_ru) = $ru;
        
        if ($var(domain_detection_success) == 1) {
            # Domain found from source IP - use domain-specific lookup (CORRECT for multi-tenant)
            $var(lookup_uri) = "sip:" + $var(endpoint_user) + "@" + $var(domain_from_source);
            xlog("INVITE: Determined domain from source IP $si: $var(domain_from_source), using domain-specific lookup: $var(lookup_uri)\n");
            
            # Set Request-URI and use lookup() function
            # CRITICAL: Set $ru to lookup_uri BEFORE calling lookup()
            # lookup() will update $ru with the contact if found
            $ru = $var(lookup_uri);
            # Save what we set $ru to, so we can detect if lookup() changed it
            $var(ru_before_lookup) = $ru;
            
            # lookup() sets $du automatically if contact found
            # NOTE: In OpenSIPS 3.6, if lookup() returns TRUE but $du is null,
            # it means $ru was updated with the registered contact (local contact, no outbound proxy)
            $var(lookup_success) = 0;
            $var(du_is_valid) = 0;
            $var(ru_is_valid) = 0;
            
            if (lookup("location")) {
                # Contact found - $du is set automatically by lookup(), OR $ru is updated with contact
                xlog("INVITE: lookup() returned TRUE - contact found\n");
                xlog("INVITE: After lookup() - $du=$du, $ru=$ru, ru_before_lookup=$var(ru_before_lookup)\n");
                $var(lookup_success) = 1;
                
                # Check if $du is set (outbound proxy case)
                if ($du != "" && $du != "<null>" && $du != "0" && $du =~ "^sip:") {
                    $var(du_is_valid) = 1;
                    xlog("INVITE: $du is valid - using outbound proxy destination\n");
                } else {
                    # $du is null - check if $ru was updated with contact (local contact case)
                    xlog("INVITE: $du is null - checking if $ru was updated by lookup()\n");
                    xlog("INVITE: $ru changed from $var(ru_before_lookup) to $ru\n");
                    
                    # Check if $ru was changed by lookup() (contains contact, not the lookup URI)
                    if ($ru != "" && $ru != $var(ru_before_lookup) && $ru =~ "^sip:") {
                        # Extract domain/IP from $ru to validate
                        $var(ru_domain) = $(ru{uri.domain});
                        if ($var(ru_domain) != "" && ($var(ru_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" || $var(ru_domain) !~ "^[0-9]")) {
                            $var(ru_is_valid) = 1;
                            # Set $du = $ru for routing (local contact, no outbound proxy)
                            $du = $ru;
                            xlog("INVITE: $ru is valid contact - using $ru as destination (local contact, no outbound proxy)\n");
                        } else {
                            xlog("INVITE: $ru domain is invalid: $var(ru_domain)\n");
                        }
                    } else {
                        xlog("INVITE: $ru was not updated by lookup() (still $var(ru_before_lookup)) - will use SQL fallback\n");
                    }
                }
            } else {
                # Restore original Request-URI
                $ru = $var(original_ru);
                xlog("INVITE: lookup() returned FALSE - no contact found for $var(lookup_uri)\n");
            }
            
            # If lookup() succeeded and either $du or $ru is valid, check for NAT traversal
            if ($var(lookup_success) == 1 && ($var(du_is_valid) == 1 || $var(ru_is_valid) == 1)) {
                # Check if destination contains private IP - if so, use received field for NAT traversal
                # Determine which URI to check (prefer $du if valid, otherwise $ru)
                if ($var(du_is_valid) == 1) {
                    $var(dest_domain) = $(du{uri.domain});
                } else {
                    $var(dest_domain) = $(ru{uri.domain});
                }
                
                # Check if destination domain is a private IP
                if ($var(dest_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                    $var(check_ip) = $var(dest_domain);
                    route(CHECK_PRIVATE_IP);
                    if ($var(is_private) == 1) {
                        # Destination is private IP - query for received field (NAT IP)
                        xlog("INVITE: Destination contains private IP $var(dest_domain), checking received field for NAT traversal\n");
                        $var(query) = "SELECT received FROM location WHERE username='" + $var(endpoint_user) + "' AND domain='" + $var(domain_from_source) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                        if (sql_query($var(query), "$avp(invite_received)") && $(avp(invite_received)[0]) != "" && $(avp(invite_received)[0]) != "<null>") {
                            # Extract IP:port from received field using standard OpenSIPS URI transformations
                            # received field format: sip:IP:port;transport=udp (e.g., sip:74.83.23.44:5060;transport=udp)
                            $var(received_value) = $(avp(invite_received)[0]);
                            
                            # Use standard OpenSIPS URI transformations instead of SQL queries
                            # Assign URI to $ru to enable transformations
                            $ru = $var(received_value);
                            $var(nat_ip) = $(ru{uri.host});   # Extract host/IP using standard transformation
                            $var(nat_port) = $(ru{uri.port}); # Extract port using standard transformation
                            
                            # Validate and update destination
                            if ($var(nat_ip) != "" && $var(nat_ip) != "<null>" && $var(nat_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                                # If port is empty, default to 5060
                                if ($var(nat_port) == "" || $var(nat_port) == "<null>") {
                                    $var(nat_port) = "5060";
                                }
                                $du = "sip:" + $var(endpoint_user) + "@" + $var(nat_ip) + ":" + $var(nat_port);
                                $ru = $du;
                                xlog("INVITE: Updated destination to NAT IP from received field: $du (was $var(dest_uri))\n");
                            } else {
                                xlog("L_WARN", "INVITE: Failed to extract valid IP:port from received field: [$var(received_value)] (IP: [$var(nat_ip)], Port: [$var(nat_port)])\n");
                            }
                        } else {
                            xlog("L_WARN", "INVITE: No received field found for NAT traversal, using original destination: $var(dest_uri)\n");
                        }
                    }
                }
                
                # Request-URI is already set to destination by lookup()
                xlog("Routing INVITE from $si to endpoint: dest=$du, Request-URI=$ru\n");
                route(RELAY);
                exit;
            }
            
            # If we get here, either lookup() returned FALSE or $du was empty/invalid
            # RACE CONDITION FIX: Try SQL fallback to check database directly (handles timing issues)
            xlog("INVITE: Trying SQL fallback for domain-specific lookup (race condition handling)\n");
            xlog("INVITE: SQL fallback query for user=$var(endpoint_user), domain=$var(domain_from_source)\n");
            # Use received field if available (NAT traversal), otherwise use contact field
            $var(query) = "SELECT COALESCE(received, contact) FROM location WHERE username='" + $var(endpoint_user) + "' AND domain='" + $var(domain_from_source) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
            if (sql_query($var(query), "$avp(invite_contact)")) {
                xlog("INVITE: SQL fallback query executed, result count check\n");
                if ($(avp(invite_contact)[0]) != "" && $(avp(invite_contact)[0]) != "<null>") {
                    # Extract IP:port from received or contact field using SQL (regex $re doesn't work)
                    $var(contact_value) = $(avp(invite_contact)[0]);
                    $var(extracted_ip) = "";
                    $var(extracted_port) = "";
                    
                    # Check if it's received field format (sip:IP:port;transport=udp) or contact field format (sip:user@IP:port)
                    # received field format: sip:74.83.23.44:5060;transport=udp (no @ symbol)
                    # Extract IP:port from contact/received field using standard OpenSIPS URI transformations
                    if ($var(contact_value) =~ "^sip:") {
                        # Use standard OpenSIPS URI transformations instead of SQL queries
                        # Assign URI to $ru to enable transformations
                        $ru = $var(contact_value);
                        $var(extracted_ip) = $(ru{uri.host});   # Extract host/IP using standard transformation
                        $var(extracted_port) = $(ru{uri.port}); # Extract port using standard transformation
                        
                        # If port is empty, default to 5060
                        if ($var(extracted_port) == "" || $var(extracted_port) == "<null>") {
                            $var(extracted_port) = "5060";
                        }
                    }
                    
                    # Validate and construct destination URI
                    if ($var(extracted_ip) != "" && $var(extracted_ip) != "<null>" && $var(extracted_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # Construct destination URI
                        if ($var(extracted_port) != "" && $var(extracted_port) != "<null>") {
                            $du = "sip:" + $var(endpoint_user) + "@" + $var(extracted_ip) + ":" + $var(extracted_port);
                        } else {
                            $du = "sip:" + $var(endpoint_user) + "@" + $var(extracted_ip) + ":5060";
                        }
                        $ru = $du;
                        xlog("INVITE: SQL fallback found contact: $du (race condition resolved)\n");
                        route(RELAY);
                        exit;
                    } else {
                        xlog("L_WARN", "INVITE: SQL fallback found contact value but extraction failed: [$var(contact_value)], extracted_ip=[$var(extracted_ip)], extracted_port=[$var(extracted_port)]\n");
                    }
                } else {
                    xlog("L_WARN", "INVITE: SQL fallback query returned no results for user=$var(endpoint_user), domain=$var(domain_from_source)\n");
                }
            } else {
                xlog("L_WARN", "INVITE: SQL fallback query failed for user=$var(endpoint_user), domain=$var(domain_from_source)\n");
            }
            
            # Domain-specific lookup failed
            $ru = $var(original_ru);
            xlog("L_WARN", "INVITE: Domain-specific lookup failed for $var(endpoint_user)@$var(domain_from_source) (source IP $si)\n");
        } else {
            # Domain not found - use SQL wildcard lookup as fallback (with warning)
            xlog("L_WARN", "INVITE: Could not determine domain from source IP $si, using wildcard lookup (may route to wrong customer in multi-tenant)\n");
            $var(query) = "SELECT contact FROM location WHERE username='" + $var(endpoint_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
            if (sql_query($var(query), "$avp(contact_uri)") && $(avp(contact_uri)[0]) != "") {
                $du = $(avp(contact_uri)[0]);
                $ru = $du;
                xlog("INVITE: SQL wildcard lookup found contact: $du for user $var(endpoint_user)\n");
                xlog("Routing INVITE from $si to endpoint: dest=$du, Request-URI=$ru\n");
                route(RELAY);
                exit;
            }
        }
        
        # If endpoint lookup failed, log and send 404
        $ru = $var(original_ru);
        xlog("L_WARN", "Endpoint lookup failed for $var(endpoint_user)@$rd - no matching endpoint found in location table\n");
        sl_send_reply(404, "Endpoint Not Found");
        exit;
    }

    # Optional extra hardening: domain consistency
    # OpenSIPS: extract domain from To URI using $(tu{uri.domain})
    if ($rd != $(tu{uri.domain})) {
        xlog("L_WARN", "R-URI / To mismatch domain=$rd src=$si\n");
        
        # Phase 1.1: Log door-knock attempt to database for security tracking
        $var(query) = "INSERT INTO door_knock_attempts " +
            "(domain, source_ip, source_port, user_agent, method, request_uri, reason, attempt_time) " +
            "VALUES ('" + $rd + "', '" + $si + "', " + $sp + ", " +
            "'" + $ua + "', '" + $rm + "', '" + $ru + "', 'domain_mismatch', NOW())";
        if (sql_query($var(query))) {
            xlog("Door-knock attempt logged to database - domain mismatch $rd vs $(tu{uri.domain}) from $si:$sp\n");
        }
        
        exit;
    }
    
    # NOTE: We do NOT validate that the From endpoint is registered/not expired for outbound INVITEs
    # Asterisk handles authentication and authorization - registration is primarily for incoming calls
    # (so Asterisk knows where to send calls TO the endpoint). Outbound calls from expired endpoints
    # are allowed if Asterisk authenticates and authorizes them.
    
    # Lookup dispatcher set for this domain
    # Use domain.setid as the dispatcher setid (explicit mapping)
    # NOTE: Custom SQL is used here because:
    # 1. Domain module only provides is_domain() for validation, not attribute retrieval
    # 2. OpenSIPS no longer favors the setid approach for domain-destination linking
    # 3. However, for our user base, the simpler setid approach is justified and appropriate
    # 4. This custom SQL is acceptable given our requirements (see docs/DOMAIN-MODULE-RESEARCH.md)
    $var(query) = "SELECT setid FROM domain WHERE domain='" + $var(domain) + "'";
    if (!sql_query($var(query), "$avp(domain_setid)")) {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (query failed)\n");
        
        # Phase 1.1: Log door-knock attempt to database for security tracking
        $var(query) = "INSERT INTO door_knock_attempts " +
            "(domain, source_ip, source_port, user_agent, method, request_uri, reason, attempt_time) " +
            "VALUES ('" + $var(domain) + "', '" + $si + "', " + $sp + ", " +
            "'" + $ua + "', '" + $rm + "', '" + $ru + "', 'query_failed', NOW())";
        if (sql_query($var(query))) {
            xlog("Door-knock attempt logged to database - domain=$var(domain) from $si:$sp (query failed)\n");
        }
        
        exit;
    }
    
    # Check if domain was found
    if ($(avp(domain_setid)[0]) == "") {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (not found)\n");
        
        # Phase 1.1: Log door-knock attempt to database for security tracking
        $var(query) = "INSERT INTO door_knock_attempts " +
            "(domain, source_ip, source_port, user_agent, method, request_uri, reason, attempt_time) " +
            "VALUES ('" + $var(domain) + "', '" + $si + "', " + $sp + ", " +
            "'" + $ua + "', '" + $rm + "', '" + $ru + "', 'domain_not_found', NOW())";
        if (sql_query($var(query))) {
            xlog("Door-knock attempt logged to database - domain=$var(domain) from $si:$sp\n");
        }
        
        exit;
    }
    
    # Get the dispatcher_setid from query result (first row, first column)
    $var(setid) = $(avp(domain_setid)[0]);

    route(TO_DISPATCHER);
}

####### Health-aware routing ########

route[TO_DISPATCHER] {

    # Select a healthy Asterisk from the dispatcher set
    if (!ds_select_dst($var(setid), 4)) {
        xlog("L_ERR", "No healthy Asterisk nodes for domain=$rd setid=$var(setid)\n");
        sl_send_reply(503, "Service Unavailable");
        exit;
    }

    xlog("Routing to $du for domain=$rd setid=$var(setid) method=$rm Request-URI=$ru\n");

    record_route();

    # Arm failure route to handle transaction failures
    t_on_failure("1");
    
    # FORCE RPORT: Add rport parameter to Via header for NAT traversal
    # This ensures upstream servers (Asterisk) send responses back to the source IP:port
    # where OpenSIPS received the request, not the port in the Via header
    # This is critical for endpoints behind NAT that don't send rport parameter
    # force_rport() adds rport to the topmost Via header (RFC 3581)
    # Should be called before t_relay() to affect how responses are routed
    if (is_method("REGISTER")) {
        # For REGISTER requests, always force rport to ensure authentication responses reach OpenSIPS
        # This works even if the phone didn't send rport parameter
        force_rport();
        xlog("REGISTER: force_rport() called - Asterisk will send responses to source IP:port $si:$sp\n");
    } else {
        # For other requests, only force rport if endpoint is behind NAT
        # This avoids unnecessary Via header modification for LAN endpoints
        route(CHECK_NAT_ENVIRONMENT);
        if ($var(enable_nat_fixes) == 1) {
            force_rport();
            xlog("$rm: force_rport() called for NAT endpoint - responses will use source IP:port $si:$sp\n");
        }
    }

    # For initial INVITE requests (no To-tag), create dialog BEFORE t_relay()
    # This is required for proper dialog tracking and database persistence
    if (is_method("INVITE") && !has_totag()) {
        xlog("Initial INVITE detected, creating dialog for Call-ID=$hdr(Call-ID)\n");
        # Create dialog for database persistence (required for Prometheus/Grafana monitoring)
        # With db_mode=2, dialog will be cached in memory and written to database periodically
        # Must be called before t_relay() for proper dialog tracking
        if (!create_dialog()) {
            xlog("L_WARN", "create_dialog() failed for INVITE Call-ID=$hdr(Call-ID)\n");
        } else {
            xlog("Dialog created successfully for Call-ID=$hdr(Call-ID)\n");
        }
        # Set extra fields for billing: From and To SIP URIs
        # These will be stored in from_uri and to_uri columns in acc table
        $acc_extra(from_uri) = $fu;
        $acc_extra(to_uri) = $tu;
    }

    # OpenSIPS transaction handling for reliable INVITE transaction management
    if (!t_relay()) {
        xlog("L_ERR", "t_relay() failed for $du method=$rm Request-URI=$ru\n");
        # Use sl_send_reply() since we're in request route, not reply route
        sl_send_reply(500, "Internal Server Error");
        exit;
    }

    xlog("t_relay() succeeded for $du method=$rm, transaction created\n");
    # For INVITE, enable CDR accounting after t_relay() succeeds
    if (is_method("INVITE") && !has_totag()) {
        # Enable CDR accounting for INVITE transactions (database backend)
        # do_accounting("db", "cdr") enables CDR mode which:
        # - Uses dialog tracking (requires dialog module loaded and create_dialog() called)
        # - Tracks dialog from INVITE to BYE
        # - Calculates duration automatically
        # - Populates created timestamp
        # - Correlates INVITE and BYE into single CDR
        # - Includes extra fields (from_uri, to_uri) for billing
        do_accounting("db", "cdr");
    }
    exit;
}

####### In-dialog handling ########

route[WITHINDLG] {
    xlog("In-dialog request: $rm from $si to $ru (Call-ID: $hdr(Call-ID), To-tag=$tt)\n");

    # Check for Record-Route header and follow it
    if (loose_route()) {
        xlog("loose_route() succeeded for $rm, following Record-Route, $du=$du, $ru=$ru\n");
        
        # For ACK and PRACK requests, validate destination URI after loose_route()
        # loose_route() may not set $du correctly, causing ACKs to not be forwarded
        if (is_method("ACK|PRACK")) {
            # If $du is empty, null, or invalid, use Request-URI
            # ACK/PRACK should use Request-URI as fallback since they're in-dialog requests
            # Note: In OpenSIPS, core variables like $du use empty string ("") for null/empty values
            # Save original $du value for logging
            $var(original_du) = $du;
            # Check for empty, null, or invalid format first
            if ($du == "" || $du == "0" || $du !~ "^sip:") {
                $du = $ru;
                if ($var(original_du) == "" || $var(original_du) == "0") {
                    xlog("ACK/PRACK: loose_route() set empty/null destination, using Request-URI: $du\n");
                } else {
                    xlog("ACK/PRACK: loose_route() set invalid destination format ($var(original_du)), using Request-URI: $du\n");
                }
            } else {
                xlog("ACK/PRACK: loose_route() set destination to: $du\n");
            }
        }
        
        # For BYE requests, validate destination URI after loose_route()
        # loose_route() may set $du to a domain that can't be resolved, causing 476 errors
        if (is_method("BYE")) {
            # If $du is empty, null, or appears invalid, try to extract from Request-URI
            # Note: In OpenSIPS, core variables like $du use empty string ("") for null/empty values
            if ($du == "" || $du == "0") {
                xlog("L_WARN", "BYE: loose_route() set empty/null destination, using Request-URI: $ru\n");
                $du = $ru;
            } else {
                # Log what loose_route() set as destination for debugging
                xlog("BYE: loose_route() set destination to: $du\n");
                
                # If $du contains a domain name (not IP), it might fail DNS resolution
                # Extract domain from $du to check if it's an IP address
                $var(dest_domain) = $(du{uri.domain});
                if ($var(dest_domain) != "" && $var(dest_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                    # Destination is a domain name, not an IP - might fail DNS
                    # For BYE, prefer using Request-URI if it has an IP address
                    $var(ru_domain) = $rd;
                    if ($var(ru_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        xlog("L_WARN", "BYE: loose_route() set domain destination ($du), but Request-URI has IP ($ru), using Request-URI\n");
                        $du = $ru;
                    } else {
                        # Both are domains - try to extract Contact header as fallback
                        if ($hdr(Contact) != "") {
                            # Extract Contact URI - might have IP address
                            $var(contact_uri) = $hdr(Contact);
                            # Remove angle brackets if present
                            if ($var(contact_uri) =~ "^<(.+)>$") {
                                $var(contact_uri) = $re;
                            }
                            # Extract domain from Contact
                            if ($var(contact_uri) =~ "@([^:;>]+)") {
                                $var(contact_domain) = $re;
                                if ($var(contact_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                                    # Contact has IP - construct destination from Contact
                                    $var(contact_user) = $rU;
                                    if ($var(contact_user) == "") {
                                        $var(contact_user) = $tU;
                                    }
                                    # Extract port from Contact if present
                                    $var(contact_port) = "";
                                    if ($var(contact_uri) =~ ":([0-9]+)[;>]") {
                                        $var(contact_port) = $re;
                                    }
                                    if ($var(contact_port) != "") {
                                        $du = "sip:" + $var(contact_user) + "@" + $var(contact_domain) + ":" + $var(contact_port);
                                    } else {
                                        $du = "sip:" + $var(contact_user) + "@" + $var(contact_domain) + ":5060";
                                    }
                                    xlog("BYE: Using Contact header IP for destination: $du\n");
                                }
                            }
                        }
                    }
                }
            }
        }
        
        route(RELAY);
        exit;
    }

    # If loose_route() fails, try to route based on transaction state
    # ACK, PRACK, and BYE need special handling - they're part of existing transactions
    if (is_method("ACK|PRACK|BYE")) {
        xlog("$rm request - loose_route() failed, checking transaction state\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("$rm matches existing transaction, relaying\n");
            # For ACKs and PRACKs, try t_relay() first (uses transaction state), fallback to RELAY route
            if (is_method("ACK|PRACK")) {
                if (!t_relay()) {
                    xlog("L_ERR", "t_relay() failed for $rm, trying stateless forward\n");
                    route(RELAY);
                }
            } else {
                # For BYE, use RELAY route directly
                route(RELAY);
            }
            exit;
        } else {
            xlog("L_WARN", "$rm received but no matching transaction found, trying to relay anyway\n");
            # Must be forwarded even without transaction match (stateless forwarding)
            # This ensures message reaches the destination even if transaction expired
            route(RELAY);
            exit;
        }
    }

    xlog("L_WARN", "In-dialog request $rm - loose_route() failed and no transaction match\n");
    sl_send_reply(404, "Not Here");
    exit;
}

####### Helper Routes ########

# Domain detection helper route (multi-tenant support)
# Determines domain from Asterisk source IP for proper multi-tenant routing
# 
# Input variables:
#   $si - Source IP (automatically available, no need to set)
#
# Output variables:
#   $var(domain_from_source) - Domain name if found (empty if not found)
#   $var(domain_detection_success) - 1 if domain found, 0 if not found
#
# Usage:
#   route(GET_DOMAIN_FROM_SOURCE_IP);
#   if ($var(domain_detection_success) == 1) {
#       # Use $var(domain_from_source) for domain-specific lookup
#   }
#
# Logic:
#   1. Query dispatcher table to find setid for source IP
#   2. Query domain table to find domain for that setid
#   3. Returns domain if found, empty if not found
route[GET_DOMAIN_FROM_SOURCE_IP] {
    $var(domain_from_source) = "";
    $var(domain_detection_success) = 0;
    
    # Step 1: Find dispatcher setid for this source IP
    # NOTE: The dispatcher module provides ds_select_dst() for forward lookup (setid  destination)
    # but does NOT provide reverse lookup functions (IP  setid). This custom SQL query is necessary
    # for multi-tenant scenarios where we need to determine which domain/tenant a request belongs to
    # based on which Asterisk server (dispatcher destination) sent it.
    # Refer to docs/DISPATCHER-REVERSE-LOOKUP-RESEARCH.md for detailed justification.
    # Dispatcher destinations are stored as "sip:IP:port" (e.g., "sip:10.0.1.10:5060")
    # We match the IP part using LIKE with proper delimiters to avoid substring matches
    # Match pattern: sip:IP: or sip:IP followed by end of string
    # This ensures we match the exact IP, not a substring (e.g., 10.0.1.10 vs 10.0.1.100)
    $var(query) = "SELECT setid FROM dispatcher WHERE destination LIKE 'sip:" + $si + ":%' OR destination LIKE 'sip:" + $si + "' LIMIT 1";
    if (!sql_query($var(query), "$avp(source_setid)")) {
        xlog("GET_DOMAIN_FROM_SOURCE_IP: Query failed for source IP $si\n");
        return;
    }
    
    $var(setid) = $(avp(source_setid)[0]);
    if ($var(setid) == "" || $var(setid) == "0") {
        xlog("GET_DOMAIN_FROM_SOURCE_IP: No dispatcher setid found for source IP $si\n");
        return;
    }
    
    # Step 2: Find domain for this setid
    $var(query) = "SELECT domain FROM domain WHERE setid='" + $var(setid) + "' LIMIT 1";
    if (!sql_query($var(query), "$avp(source_domain)")) {
        xlog("GET_DOMAIN_FROM_SOURCE_IP: Domain query failed for setid $var(setid)\n");
        return;
    }
    
    $var(domain_from_source) = $(avp(source_domain)[0]);
    if ($var(domain_from_source) != "") {
        $var(domain_detection_success) = 1;
        xlog("GET_DOMAIN_FROM_SOURCE_IP: Found domain $var(domain_from_source) for source IP $si (setid $var(setid))\n");
    } else {
        xlog("GET_DOMAIN_FROM_SOURCE_IP: No domain found for setid $var(setid) (source IP $si)\n");
    }
    
    return;
}

# Check if NAT fixes should be enabled
# Auto-detected by install script based on advertised_address
# If advertised_address is public IP, install script enables NAT fixes
# Output: $var(enable_nat_fixes) - 1 if NAT fixes should be enabled, 0 if not
route[CHECK_NAT_ENVIRONMENT] {
    $var(enable_nat_fixes) = 0;
    
    # Runtime detection: Check if endpoints are sending private IPs (indicates NAT environment)
    # This works for both LAN and NAT environments
    # If we receive requests with private IPs from endpoints (not Asterisk), enable NAT fixes
    route(CHECK_IS_FROM_ASTERISK);
    if ($var(is_from_asterisk) == 0) {
        # NOTE: nat_uac_test() causes runtime errors in OpenSIPS 3.6.3
        # Error: "Unknown flag: 19" when called at runtime
        # Using manual source IP check which works reliably
        $var(check_ip) = $si;
        route(CHECK_PRIVATE_IP);
        if ($var(is_private) == 1) {
            # Endpoint is behind NAT - enable NAT fixes for this request
            $var(enable_nat_fixes) = 1;
            xlog("NAT environment detected via source IP check: endpoint $si is behind NAT, enabling NAT fixes\n");
        }
    }
    
    return;
}

# Check if source IP is from Asterisk (dispatcher destination)
# Input: $si - Source IP (automatically available)
# Output: $var(is_from_asterisk) - 1 if from Asterisk, 0 if not
# NOTE: Uses custom SQL query because dispatcher module doesn't provide reverse lookup functions.
# Refer to docs/DISPATCHER-REVERSE-LOOKUP-RESEARCH.md for detailed justification.
route[CHECK_IS_FROM_ASTERISK] {
    $var(is_from_asterisk) = 0;
    $var(query) = "SELECT COUNT(*) FROM dispatcher WHERE destination LIKE 'sip:" + $si + ":%' OR destination LIKE 'sip:" + $si + "' LIMIT 1";
    if (sql_query($var(query), "$avp(dispatcher_match)")) {
        if ($(avp(dispatcher_match)[0]) != "" && $(avp(dispatcher_match)[0]) != "0") {
            $var(is_from_asterisk) = 1;
        }
    }
    return;
}

# Check if IP address is private (RFC 1918)
# Input: $var(check_ip) - IP address to check
# Output: $var(is_private) - 1 if private, 0 if public
# Covers all RFC 1918 private IP ranges:
#   Class A: 10.0.0.0 - 10.255.255.255
#   Class B: 172.16.0.0 - 172.31.255.255
#   Class C: 192.168.0.0 - 192.168.255.255
route[CHECK_PRIVATE_IP] {
    $var(is_private) = 0;
    # Class C: 192.168.0.0 - 192.168.255.255
    if ($var(check_ip) =~ "^192\\.168\\.") {
        $var(is_private) = 1;
    # Class A: 10.0.0.0 - 10.255.255.255
    } else if ($var(check_ip) =~ "^10\\.") {
        $var(is_private) = 1;
    # Class B: 172.16.0.0 - 172.31.255.255
    # 172.16-19
    } else if ($var(check_ip) =~ "^172\\.1[6-9]\\.") {
        $var(is_private) = 1;
    # 172.20-29
    } else if ($var(check_ip) =~ "^172\\.2[0-9]\\.") {
        $var(is_private) = 1;
    # 172.30-31
    } else if ($var(check_ip) =~ "^172\\.3[01]\\.") {
        $var(is_private) = 1;
    }
    return;
}

route[RELAY] {
    # Add Record-Route for INVITE requests so ACKs can follow the same path
    # This is critical for ACK handling when routing from Asterisk to endpoints
    if (is_method("INVITE")) {
        record_route();
        xlog("RELAY: Added Record-Route for INVITE to $du, Call-ID=$hdr(Call-ID)\n");
        
        # Fix NAT in SDP for INVITE requests from endpoints behind NAT
        # This is CRITICAL for RTP to work - fixes private IPs in SDP to public NAT IPs
        # Must be done BEFORE forwarding to Asterisk so Asterisk receives correct IP for RTP
        # Auto-detected: NAT fixes enabled automatically if endpoints are behind NAT
        if ($hdr(Content-Type) =~ "application/sdp") {
            route(CHECK_NAT_ENVIRONMENT);
            if ($var(enable_nat_fixes) == 1) {
                fix_nated_sdp("rewrite-media-ip");
                xlog("RELAY: Fixed NAT in SDP for INVITE from $si to $du, Call-ID=$hdr(Call-ID)\n");
            }
        }
        
        # For initial INVITE requests (no To-tag), create dialog BEFORE t_relay()
        # This is required for proper dialog tracking and database persistence
        if (!has_totag()) {
            xlog("RELAY: Initial INVITE detected, creating dialog for Call-ID=$hdr(Call-ID)\n");
            # Create dialog for database persistence (required for Prometheus/Grafana monitoring)
            # With db_mode=2, dialog will be cached in memory and written to database periodically
            # Must be called before t_relay() for proper dialog tracking
            if (!create_dialog()) {
                xlog("L_WARN", "RELAY: create_dialog() failed for INVITE Call-ID=$hdr(Call-ID)\n");
            } else {
                xlog("RELAY: Dialog created successfully for Call-ID=$hdr(Call-ID)\n");
            }
            # Set extra fields for billing: From and To SIP URIs
            # These will be stored in from_uri and to_uri columns in acc table
            $acc_extra(from_uri) = $fu;
            $acc_extra(to_uri) = $tu;
        }
    }
    
    # For ACKs, PRACKs, BYEs, NOTIFYs, and OPTIONS, fix destination URI to use NAT IP from endpoint database
    # Only applies if Request-URI contains private IP (endpoint behind NAT)
    # ACK/PRACK: Only if Request-URI has username (ACKs to Asterisk have no username)
    # BYE/NOTIFY/OPTIONS: Always check if private IP
    if (is_method("ACK|PRACK|BYE|NOTIFY|OPTIONS")) {
        # Note: With CDR mode enabled on INVITE, we don't need do_accounting() for BYE
        # The acc module with dialog module will automatically:
        # - Track dialog state for ACK, BYE, etc.
        # - Correlate BYE with the INVITE and update the CDR
        # - Calculate duration and termination information
        
        $var(needs_nat_fix) = 0;
        
        # For ACK/PRACK, require username in Request-URI (ACKs to Asterisk have no username)
        # Check if Request-URI contains private IP - if so, apply NAT traversal regardless of source
        # This is needed because ACKs from Asterisk may use Contact header from 200 OK which has private IP
        if (is_method("ACK|PRACK")) {
            # Check if Request-URI has username and contains private IP
            if ($ru =~ "^sip:[^@]+@") {
                $var(check_ip) = $rd;
                route(CHECK_PRIVATE_IP);
                # Apply NAT traversal if Request-URI contains private IP (regardless of source)
                if ($var(is_private) == 1) {
                    $var(needs_nat_fix) = 1;
                    xlog("RELAY: $rm - Request-URI contains private IP $rd, applying NAT traversal\n");
                } else {
                    # Request-URI has public IP - no NAT traversal needed
                    $var(needs_nat_fix) = 0;
                }
            } else {
                # No username in Request-URI (ACK to Asterisk) - no NAT traversal needed
                $var(needs_nat_fix) = 0;
            }
        } else {
            # BYE/NOTIFY/OPTIONS: always check
            $var(needs_nat_fix) = 1;
        }
        
        if ($var(needs_nat_fix) == 1) {
            $var(check_ip) = $rd;
            route(CHECK_PRIVATE_IP);
            
            if ($var(is_private) == 1 && $rU != "") {
                # Use location table for NAT handling (migrated from endpoint_locations)
                # Extract username and domain from Request-URI
                $var(nat_lookup_user) = $rU;
                $var(nat_lookup_domain) = $rd;
                
                # Check if domain is an IP address (not a domain name)
                if ($var(nat_lookup_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                    # Domain is IP - try to determine domain from source IP
                    route(GET_DOMAIN_FROM_SOURCE_IP);
                    if ($var(domain_detection_success) == 1) {
                        $var(nat_lookup_domain) = $var(domain_from_source);
                    }
                }
                
                # Query location table for contact information
                # First try received field (NAT traversal), then fallback to contact field
                $var(nat_contact_found) = 0;
                
                # Save original Request-URI username before any modifications
                $var(original_username) = $rU;
                $var(original_ru) = $ru;
                
                if ($var(nat_lookup_domain) != "" && $var(nat_lookup_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                    # Domain-specific lookup (preferred for multi-tenant)
                    # For in-dialog requests (BYE), use most recent registration even if slightly expired
                    # This handles cases where registration expires during an active call
                    $var(query) = "SELECT received FROM location WHERE username='" + $var(nat_lookup_user) + "' AND domain='" + $var(nat_lookup_domain) + "' ORDER BY expires DESC LIMIT 1";
                } else {
                    # Fallback: username-only lookup (wildcard)
                    # For in-dialog requests (BYE), use most recent registration even if slightly expired
                    $var(query) = "SELECT received FROM location WHERE username='" + $var(nat_lookup_user) + "' ORDER BY expires DESC LIMIT 1";
                }
                
                # Try received field first (NAT traversal)
                if (sql_query($var(query), "$avp(nat_received)") && $(avp(nat_received)[0]) != "" && $(avp(nat_received)[0]) != "<null>") {
                    # Extract IP:port from received field using standard OpenSIPS URI transformations
                    # received field format: sip:IP:port;transport=udp (e.g., sip:74.83.23.44:5060;transport=udp)
                    $var(received_value) = $(avp(nat_received)[0]);
                    xlog("RELAY: $rm - DEBUG - Extracting from received field: [$var(received_value)]\n");
                    
                    # Save original Request-URI username before overwriting $ru
                    $var(original_username) = $rU;
                    $var(original_ru) = $ru;
                    
                    # Validate that received_value is a valid SIP URI (not NULL or empty)
                    if ($var(received_value) =~ "^sip:") {
                        # Use standard OpenSIPS URI transformations instead of SQL queries
                        # Assign URI to $ru to enable transformations (temporarily)
                        $ru = $var(received_value);
                        $var(nat_ip) = $(ru{uri.host});   # Extract host/IP using standard transformation
                        $var(nat_port) = $(ru{uri.port}); # Extract port using standard transformation
                        
                        # Restore original Request-URI
                        $ru = $var(original_ru);
                        
                        xlog("RELAY: $rm - DEBUG - Extracted IP: [$var(nat_ip)], Port: [$var(nat_port)]\n");
                    } else {
                        xlog("L_WARN", "RELAY: $rm - DEBUG - received field is not a valid SIP URI format: [$var(received_value)]\n");
                        $var(nat_ip) = "";
                        $var(nat_port) = "";
                    }
                    
                    xlog("RELAY: $rm - DEBUG - Final extraction result: IP=[$var(nat_ip)], Port=[$var(nat_port)]\n");
                    
                    # Only set $du if we successfully extracted both IP and port
                    if ($var(nat_ip) != "" && $var(nat_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" && $var(nat_port) != "" && $var(nat_port) =~ "^[0-9]+$") {
                        # Construct destination URI: include username if it exists, otherwise just IP:port
                        if ($var(original_username) != "") {
                            $du = "sip:" + $var(original_username) + "@" + $var(nat_ip) + ":" + $var(nat_port);
                        } else {
                            $du = "sip:" + $var(nat_ip) + ":" + $var(nat_port);
                        }
                        xlog("RELAY: $rm - Updated destination to NAT IP from received field: $du (was $var(original_ru))\n");
                        $var(nat_contact_found) = 1;
                    } else {
                        xlog("L_WARN", "RELAY: $rm - Failed to extract valid IP:port from received field: [$var(received_value)], nat_ip=[$var(nat_ip)], nat_port=[$var(nat_port)]\n");
                    }
                }
                
                # Fallback to contact field if received not available
                if ($var(nat_contact_found) == 0) {
                    if ($var(nat_lookup_domain) != "" && $var(nat_lookup_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # For in-dialog requests (BYE), use most recent registration even if slightly expired
                        $var(query) = "SELECT contact FROM location WHERE username='" + $var(nat_lookup_user) + "' AND domain='" + $var(nat_lookup_domain) + "' ORDER BY expires DESC LIMIT 1";
                    } else {
                        # For in-dialog requests (BYE), use most recent registration even if slightly expired
                        $var(query) = "SELECT contact FROM location WHERE username='" + $var(nat_lookup_user) + "' ORDER BY expires DESC LIMIT 1";
                    }
                    
                    if (sql_query($var(query), "$avp(nat_contact)") && $(avp(nat_contact)[0]) != "") {
                        # Extract IP:port from contact field
                        $var(contact_uri) = $(avp(nat_contact)[0]);
                        # Contact format: sip:user@ip:port or <sip:user@ip:port>
                        $var(nat_ip) = "";
                        $var(nat_port) = "";
                        
                        # Try pattern with port first: sip:user@ip:port
                        if ($var(contact_uri) =~ "@([^:>]+):([0-9]+)") {
                            $var(nat_ip) = $re;
                            # Extract port separately (OpenSIPS regex limitation)
                            if ($var(contact_uri) =~ "@[^:>]+:([0-9]+)") {
                                $var(nat_port) = $re;
                            }
                        }
                        # Fallback to pattern without port: sip:user@ip
                        if ($var(nat_ip) == "" && $var(contact_uri) =~ "@([^:>]+)") {
                            $var(nat_ip) = $re;
                        }
                        
                        # Validate extracted IP and set destination URI
                        if ($var(nat_ip) != "" && $var(nat_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                            # Construct destination URI: include username if it exists, otherwise just IP:port
                            if ($var(original_username) != "") {
                                if ($var(nat_port) != "") {
                                    $du = "sip:" + $var(original_username) + "@" + $var(nat_ip) + ":" + $var(nat_port);
                                    xlog("RELAY: $rm - Updated destination to NAT IP from contact: $du (was $var(original_ru))\n");
                                } else {
                                    $du = "sip:" + $var(original_username) + "@" + $var(nat_ip) + ":5060";
                                    xlog("RELAY: $rm - Updated destination to NAT IP from contact (default port): $du (was $var(original_ru))\n");
                                }
                            } else {
                                if ($var(nat_port) != "") {
                                    $du = "sip:" + $var(nat_ip) + ":" + $var(nat_port);
                                    xlog("RELAY: $rm - Updated destination to NAT IP from contact (no username): $du (was $var(original_ru))\n");
                                } else {
                                    $du = "sip:" + $var(nat_ip) + ":5060";
                                    xlog("RELAY: $rm - Updated destination to NAT IP from contact (no username, default port): $du (was $var(original_ru))\n");
                                }
                            }
                            $var(nat_contact_found) = 1;
                        } else {
                            xlog("L_WARN", "RELAY: $rm - Invalid IP extracted from contact: $var(nat_ip), keeping original $du\n");
                        }
                    }
                }
            }
        }
    }
    
    # Arm failure route to handle transaction failures
    t_on_failure("1");
    
    # For non-INVITE requests (like NOTIFY), ensure transaction is created properly
    if (is_method("NOTIFY|OPTIONS")) {
        xlog("RELAY: Creating transaction for $rm to $du, Call-ID=$hdr(Call-ID)\n");
    }
    
    # For ACK and PRACK requests, ensure proper transaction-based routing
    # ACK/PRACK should use transaction state when available, but need fallback if transaction expired
    # This prevents retransmission loops where ACKs aren't properly forwarded
    if (is_method("ACK|PRACK")) {
        # PRACKs can contain SDP for early media - preserve SDP as-is, do NOT modify
        # ACKs typically don't have SDP, but if they do, preserve it as-is
        if ($hdr(Content-Type) =~ "application/sdp") {
            xlog("RELAY: $rm with SDP from $si to $du - preserving SDP as-is (no modification)\n");
            # Do NOT call fix_nated_sdp() - SDP in ACK/PRACK should be preserved exactly as received
        }
        
        # Validate destination URI (WITHINDLG already validated, but double-check for safety)
        # Note: In OpenSIPS, core variables like $du use empty string ("") for null/empty values
        if ($du == "" || $du == "0" || $du !~ "^sip:") {
            $du = $ru;
            xlog("RELAY: $rm - Set destination URI from Request-URI: $du (was empty/null/invalid)\n");
        }
        
        xlog("RELAY: $rm - Attempting to relay to $du (Request-URI=$ru, Route=$hdr(Route), From=$si)\n");
        
        # For ACKs from Asterisk, we MUST forward them even if transaction doesn't match
        # ACKs from Asterisk may not match the original INVITE transaction (created from endpoint)
        # So we use stateless forward() which doesn't require transaction matching
        # This is critical to prevent retransmission loops where Yealink never receives ACK
        route(CHECK_IS_FROM_ASTERISK);
        if ($var(is_from_asterisk) == 1) {
            # ACK is from Asterisk - use stateless forward to ensure it reaches endpoint
            xlog("RELAY: $rm from Asterisk - using stateless forward to ensure delivery to $du\n");
            if (!forward()) {
                xlog("L_ERR", "RELAY: $rm from Asterisk - forward() failed for destination $du\n");
                exit;
            } else {
                xlog("RELAY: $rm from Asterisk - stateless forward succeeded to $du\n");
            }
        } else {
            # ACK is from endpoint - try transaction-based relay first
            # Try t_relay() first - it will use transaction state if available
            # ACK/PRACK should work with transaction state since they're part of the INVITE transaction
            if (!t_relay()) {
                # t_relay() failed - transaction might not exist or expired
                # For ACK/PRACK, this is unusual but can happen if transaction expired
                xlog("L_WARN", "RELAY: $rm - t_relay() failed for destination $du (transaction not found?), trying stateless forward\n");
                
                # Try stateless forward as fallback
                # This ensures ACK/PRACK reaches destination even if transaction expired
                if (!forward()) {
                    xlog("L_ERR", "RELAY: $rm - forward() also failed for destination $du\n");
                    # For ACK, we can't send an error response (ACK has no response)
                    # For PRACK, we could send an error, but it's better to just log and exit
                    exit;
                } else {
                    xlog("RELAY: $rm - Stateless forward succeeded to $du\n");
                }
            } else {
                xlog("RELAY: $rm - t_relay() succeeded (transaction found)\n");
            }
        }
        # CRITICAL: Exit after ACK/PRACK handling to prevent further processing
        # ACK/PRACK must be forwarded immediately and not processed further
        exit;
    } else if (is_method("BYE")) {
        # Validate destination URI - prefer Request-URI if $du is invalid or domain (not IP)
        if ($du == "" || $du == "0" || $du !~ "^sip:") {
            $du = $ru;
        } else {
            $var(dest_domain) = $(du{uri.domain});
            if ($var(dest_domain) != "" && $var(dest_domain) !~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" && $rd =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                $du = $ru;  # Prefer Request-URI IP over domain to avoid DNS issues
            }
        }
        
        # Try t_relay() first, fallback to stateless forward if transaction expired
        if (!t_relay() && !forward()) {
            sl_send_reply(500, "Internal Server Error");
            exit;
        }
    } else {
        # For other methods (including INVITE), use standard t_relay()
        if (!t_relay()) {
            # Use sl_send_reply() since we're in request route, not reply route
            sl_send_reply(500, "Internal Server Error");
        } else {
            if (is_method("NOTIFY|OPTIONS")) {
                xlog("RELAY: Transaction created successfully for $rm, Call-ID=$hdr(Call-ID)\n");
            }
            # For initial INVITE, enable CDR accounting after t_relay() succeeds
            if (is_method("INVITE") && !has_totag()) {
                # Enable CDR accounting for INVITE transactions (database backend)
                # do_accounting("db", "cdr") enables CDR mode which:
                # - Uses dialog tracking (requires dialog module loaded and create_dialog() called)
                # - Tracks dialog from INVITE to BYE
                # - Calculates duration automatically
                # - Populates created timestamp
                # - Correlates INVITE and BYE into single CDR
                # - Includes extra fields (from_uri, to_uri) for billing
                do_accounting("db", "cdr");
            }
        }
    }
    exit;
}
    
####### Response handling (for debugging) ########

onreply_route {
    xlog("Response received: $rs $rr from $si (method=$rm, CSeq=$hdr(CSeq), To-tag=$tt, Contact=$hdr(Contact), Call-ID=$hdr(Call-ID))\n");
    
    # Check if response is from Asterisk (dispatcher destination) vs endpoint
    # We should only fix NAT in responses FROM endpoints, not FROM Asterisk
    # Asterisk's SDP is correct as-is and should not be modified
    route(CHECK_IS_FROM_ASTERISK);
    if ($var(is_from_asterisk) == 1) {
        xlog("Response from Asterisk (dispatcher destination) at $si - skipping NAT fixes\n");
    }
    
    # Fix NAT in Contact headers and SDP for responses from endpoints behind NAT
    # This is critical for RTP to work correctly - fixes private IPs to public NAT IPs
    # fix_nated_contact() fixes Contact headers in responses
    # fix_nated_sdp() with "rewrite-media-ip" flag rewrites the media IP address (c= line) in SDP
    # This ensures Asterisk receives the public NAT IP instead of private IP for RTP
    # CRITICAL: Do NOT fix Contact header for REGISTER responses - the Contact header contains
    # the endpoint's contact information from Asterisk, and we must preserve it for save() to work
    # CRITICAL: Do NOT fix SDP in responses FROM Asterisk - Asterisk's SDP is correct and should not be modified
    # Auto-detected: NAT fixes enabled automatically if endpoints are behind NAT
    if ($var(is_from_asterisk) == 0) {
        # Response is from endpoint - fix Contact header if it contains private IP
        # This is critical for ACK routing - ACK uses Contact header from 200 OK response
        # NOTE: nat_uac_test() causes runtime errors in OpenSIPS 3.6.3
        # Error: "Unknown flag: 1" when called at runtime
        # Using manual Contact header IP check which works reliably
        if (!is_method("REGISTER") && $hdr(Contact) != "" && $hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
            # Extract IP from Contact header and check if it's private
            $var(contact_ip) = $re;
            $var(check_ip) = $var(contact_ip);
            route(CHECK_PRIVATE_IP);
            if ($var(is_private) == 1) {
                xlog("Contact header NAT detected: IP=$var(contact_ip) is private, fixing to use NAT IP from location table\n");
                
                # Contact header contains private IP - fix it using received field from location table
                # Extract username from Contact header (format: sip:user@ip:port or <sip:user@ip:port>)
                $var(contact_user) = "";
                if ($hdr(Contact) =~ "sip:([^@]+)@") {
                    $var(contact_user) = $re;
                }
                
                if ($var(contact_user) != "") {
                # Query location table for received field (NAT IP)
                $var(query) = "SELECT received FROM location WHERE username='" + $var(contact_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                if (sql_query($var(query), "$avp(contact_received)")) {
                    if ($(avp(contact_received)[0]) != "" && $(avp(contact_received)[0]) != "<null>") {
                        # Extract IP:port from received field (SIP URI format: sip:IP:port;transport=udp)
                        # Extract IP:port from received field using standard OpenSIPS URI transformations
                        # received field format: sip:IP:port;transport=udp (e.g., sip:74.83.23.44:5060;transport=udp)
                        $var(received_value) = $(avp(contact_received)[0]);
                        
                        # Use standard OpenSIPS URI transformations instead of SQL queries
                        # Assign URI to $ru to enable transformations
                        $ru = $var(received_value);
                        $var(nat_ip) = $(ru{uri.host});   # Extract host/IP using standard transformation
                        $var(nat_port) = $(ru{uri.port}); # Extract port using standard transformation
                        
                        # Validate and construct new Contact header
                        if ($var(nat_ip) != "" && $var(nat_ip) != "<null>" && $var(nat_ip) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}" && $var(nat_port) != "" && $var(nat_port) != "<null>") {
                            # Reconstruct Contact header with NAT IP:port
                            # Extract any parameters from original Contact header (after semicolon)
                            $var(contact_params) = "";
                            if ($hdr(Contact) =~ ";([^>]+)") {
                                $var(contact_params) = ";" + $re;
                            }
                            
                            # Check for angle brackets in original (format: <sip:user@ip:port> or <sip:user@ip:port;params>)
                            $var(has_brackets) = 0;
                            if ($hdr(Contact) =~ "^<") {
                                $var(has_brackets) = 1;
                            }
                            
                            # Construct new Contact header
                            if ($var(has_brackets) == 1) {
                                $var(new_contact) = "<sip:" + $var(contact_user) + "@" + $var(nat_ip) + ":" + $var(nat_port) + $var(contact_params) + ">";
                            } else {
                                $var(new_contact) = "sip:" + $var(contact_user) + "@" + $var(nat_ip) + ":" + $var(nat_port) + $var(contact_params);
                            }
                            
                            # Update Contact header - remove old and append new
                            # In OpenSIPS, cannot directly assign to $hdr() in onreply_route
                            # Construct full Contact header line with \r\n (required by append_hf)
                            $var(contact_header) = "Contact: " + $var(new_contact) + "\r\n";
                            remove_hf("Contact");
                            append_hf($var(contact_header));
                            xlog("Fixed Contact header in response $rs: replaced private IP $var(contact_ip) with NAT IP $var(nat_ip):$var(nat_port), new Contact=$var(new_contact)\n");
                        }
                    }
                }
            }
            }
        }
            
        # Fix NAT in Contact headers and SDP for responses from endpoints behind NAT
        # This is critical for RTP to work correctly - fixes private IPs to public NAT IPs
        route(CHECK_NAT_ENVIRONMENT);
        if ($var(enable_nat_fixes) == 1) {
            if (!is_method("REGISTER")) {
                # fix_nated_contact() may not work correctly, so we manually fixed it above
                # But call it anyway as a fallback
                fix_nated_contact();
            }
            if ($hdr(Content-Type) =~ "application/sdp") {
                fix_nated_sdp("rewrite-media-ip");
                xlog("Fixed NAT in SDP for response $rs from endpoint $si\n");
            }
        } else {
            xlog("Response from endpoint $si - NAT fixes not needed (LAN-only deployment)\n");
        }
    } else {
        # Response is from Asterisk - do NOT fix SDP, just log
        if ($hdr(Content-Type) =~ "application/sdp") {
            xlog("Response with SDP from Asterisk $si - preserving SDP as-is (no NAT fix)\n");
        }
    }
    
    # Log OPTIONS/NOTIFY responses specifically
    if (is_method("OPTIONS|NOTIFY")) {
        xlog("OPTIONS/NOTIFY response: $rs $rr from $si, Call-ID=$hdr(Call-ID), Via=$hdr(Via), forwarding to Asterisk\n");
        # In onreply_route, transaction should already exist if we're here
        # If we get a 476 error, it means the response didn't match any transaction
        # This could be due to Via branch mismatch or transaction timeout
    }
    
    # Detailed SDP logging for 200 OK responses
    # This helps diagnose why one direction works and the other doesn't
    if ($rs == 200 && $hdr(Content-Type) =~ "application/sdp") {
        # Extract username from To header to identify the callee
        $var(to_user) = $(tu{uri.user});
        $var(from_user) = $(fu{uri.user});
        
        xlog("200 OK with SDP: From=$var(from_user), To=$var(to_user), Source=$si\n");
        
        # Diagnostic logging: Check endpoint IPs for SDP troubleshooting
        # This helps diagnose RTP issues regardless of whether call is from Asterisk or endpoint
        # Updated to use location table (migrated from endpoint_locations)
        if ($var(to_user) != "") {
            # Look up endpoint contact from location table for the callee (To header)
            # Use received field if available (NAT), otherwise extract from contact field
            $var(query) = "SELECT received FROM location WHERE username='" + $var(to_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
            if (sql_query($var(query), "$avp(endpoint_received)")) {
                if ($(avp(endpoint_received)[0]) != "") {
                    # received field contains IP:port
                    if ($(avp(endpoint_received)[0]) =~ "^([^:]+)") {
                        $var(endpoint_ip) = $re;
                        xlog("Callee endpoint IP from location table (received): $var(endpoint_ip) (user=$var(to_user))\n");
                    }
                } else {
                    # Fallback to contact field
                    $var(query) = "SELECT contact FROM location WHERE username='" + $var(to_user) + "' AND expires > UNIX_TIMESTAMP() LIMIT 1";
                    if (sql_query($var(query), "$avp(endpoint_contact)")) {
                        if ($(avp(endpoint_contact)[0]) != "") {
                            $var(contact_uri) = $(avp(endpoint_contact)[0]);
                            # Extract IP from contact: sip:user@ip:port
                            if ($var(contact_uri) =~ "@([^:>]+)") {
                                $var(endpoint_ip) = $re;
                                xlog("Callee endpoint IP from location table (contact): $var(endpoint_ip) (user=$var(to_user))\n");
                            }
                        }
                    }
                }
            }
        }
        
        # Also check the caller's endpoint IP
        if ($var(from_user) != "") {
            # Extract domain from From header for domain-specific lookup (multi-tenant safety)
            $var(from_domain) = $(fu{uri.domain});
            xlog("Caller lookup: user=$var(from_user), domain from From header=$var(from_domain)\n");
            
            # Check if From header domain is an IP address (not a domain name)
            # If domain is IP or empty, use username-only lookup (endpoint may have registered with different domain)
            # Note: For diagnostic logging, we don't check expires - we want to see the caller's IP even if registration expired
            if ($var(from_domain) == "" || $var(from_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                # Username-only lookup (when domain is IP or empty)
                $var(query) = "SELECT received FROM location WHERE username='" + $var(from_user) + "' ORDER BY expires DESC LIMIT 1";
                xlog("Caller lookup: Using username-only query (domain is IP or empty)\n");
            } else {
                # Domain-specific lookup (preferred for multi-tenant when domain is valid)
                $var(query) = "SELECT received FROM location WHERE username='" + $var(from_user) + "' AND domain='" + $var(from_domain) + "' ORDER BY expires DESC LIMIT 1";
                xlog("Caller lookup: Using domain-specific query (domain=$var(from_domain))\n");
            }
            
            if (sql_query($var(query), "$avp(caller_received)")) {
                # Log the raw query result for debugging
                xlog("Caller lookup: SQL query executed, AVP value: [$(avp(caller_received)[0])] (user=$var(from_user), domain=$var(from_domain))\n");
                # Check if AVP has a valid value (not empty and not NULL from database)
                # Note: AVPs from database queries return "<null>" string when database value is NULL
                # Also, if no rows match, the AVP will be empty
                if ($(avp(caller_received)[0]) != "" && $(avp(caller_received)[0]) != "<null>") {
                    # Extract IP from received field using standard OpenSIPS URI transformations
                    # received field format: sip:IP:port;transport=udp (e.g., sip:74.83.23.44:5060;transport=udp)
                    $var(received_value) = $(avp(caller_received)[0]);
                    
                    # Use standard OpenSIPS URI transformations instead of SQL queries
                    # Assign URI to $ru to enable transformations
                    $ru = $var(received_value);
                    $var(caller_ip) = $(ru{uri.host});   # Extract host/IP using standard transformation
                    
                    if ($var(caller_ip) != "" && $var(caller_ip) != "<null>") {
                        xlog("Caller endpoint IP from location table (received): $var(caller_ip) (user=$var(from_user), extracted from: $var(received_value))\n");
                    } else {
                        xlog("L_WARN", "Caller lookup: IP extraction returned empty/null: [$var(caller_ip)] from [$var(received_value)] (user=$var(from_user))\n");
                    }
                } else {
                    # received field is empty or NULL - log for debugging
                    xlog("L_WARN", "Caller lookup: received field is empty or NULL for user=$var(from_user), domain=$var(from_domain), query result: [$(avp(caller_received)[0])], falling back to contact field\n");
                    # Fallback to contact field
                    # Note: For diagnostic logging, we don't check expires - we want to see the caller's contact even if registration expired
                    if ($var(from_domain) == "" || $var(from_domain) =~ "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}") {
                        # Username-only lookup (when domain is IP or empty)
                        $var(query) = "SELECT contact FROM location WHERE username='" + $var(from_user) + "' ORDER BY expires DESC LIMIT 1";
                    } else {
                        # Domain-specific lookup (preferred for multi-tenant when domain is valid)
                        $var(query) = "SELECT contact FROM location WHERE username='" + $var(from_user) + "' AND domain='" + $var(from_domain) + "' ORDER BY expires DESC LIMIT 1";
                    }
                    if (sql_query($var(query), "$avp(caller_contact)")) {
                        # Check if AVP has a valid value (not empty and not NULL from database)
                        # Note: AVPs from database queries return "<null>" string when database value is NULL
                        if ($(avp(caller_contact)[0]) != "" && $(avp(caller_contact)[0]) != "<null>") {
                            $var(contact_uri) = $(avp(caller_contact)[0]);
                            # Extract IP from contact: sip:user@ip:port
                            if ($var(contact_uri) =~ "@([^:>]+)") {
                                $var(caller_ip) = $re;
                                xlog("Caller endpoint IP from location table (contact): $var(caller_ip) (user=$var(from_user))\n");
                            }
                        } else {
                            xlog("L_WARN", "Caller lookup: contact field is empty or NULL for user=$var(from_user), domain=$var(from_domain)\n");
                        }
                    } else {
                        xlog("L_WARN", "Caller lookup: SQL query failed for user=$var(from_user), domain=$var(from_domain)\n");
                    }
                }
            } else {
                xlog("L_WARN", "Caller lookup: SQL query failed for user=$var(from_user), domain=$var(from_domain)\n");
            }
        }
    }
    
    # Log transaction state for debugging
    if ($rs >= 100 && $rs < 200) {
        xlog("Provisional response $rs received, transaction should remain active\n");
        # For provisional responses, explicitly exit to let transaction module handle forwarding
        # The transaction module will automatically forward and keep transaction alive
        exit;
    } else if ($rs >= 200 && $rs < 300) {
        xlog("Final success response $rs received\n");
        exit;
    } else if ($rs >= 300) {
        xlog("Final error response $rs received\n");
        exit;
    }
    # If we get here, exit to let transaction module handle it
    exit;
}

# --- REGISTER reply handler (usrloc migration) ---
# This handler saves endpoint locations only on successful registration (2xx)
# Follows OpenSIPS proxy-registrar pattern: save AFTER successful reply, not before
# The save() function uses contact information from the 200 OK reply (via mcontact_avp)
# which includes any modifications made by the main registrar (e.g., expiration changes)
onreply_route[handle_reply_reg] {
    if (is_method("REGISTER")) {
        # Only save location on successful registration (2xx response)
        if (t_check_status("2[0-9][0-9]")) {
            # DIAGNOSTIC: Log all relevant values before calling save()
            xlog("REGISTER: === DIAGNOSTIC INFO BEFORE save() ===\n");
            xlog("REGISTER: Response: $rs $rr\n");
            xlog("REGISTER: To URI: $tu\n");
            xlog("REGISTER: To User: $tU\n");
            xlog("REGISTER: To Domain: $(tu{uri.domain})\n");
            xlog("REGISTER: Reply Contact header: [$hdr(Contact)]\n");
            xlog("REGISTER: Reply Expires header: [$hdr(Expires)]\n");
            xlog("REGISTER: Request Contact (stored for diagnostics): [$avp(reg_contact)]\n");
            xlog("REGISTER: Modified Contact AVP (from registrar module): [$avp(mcontact)]\n");
            xlog("REGISTER: Source IP:Port: $si:$sp\n");
            xlog("REGISTER: Call-ID: $hdr(Call-ID)\n");
            # CRITICAL: Check if received_avp AVP is available in onreply_route
            xlog("REGISTER: DEBUG - AVP reg_received (for received_avp): [$avp(reg_received)]\n");
            xlog("REGISTER: DEBUG - AVP tu:reg_received (transaction-scoped): [$avp(tu:reg_received)]\n");
            xlog("REGISTER: DEBUG - If received_avp parameter is working, save() should use: $avp(reg_received)\n");
            
            # Check if this is a deregistration (Expires: 0)
            # REGISTER with Expires: 0 means the endpoint wants to unregister
            # save() will delete the contact from the location table
            # NOTE: This is a common SIP pattern - many phones (including Yealink) deregister
            #       before re-registering. The sequence is:
            #       1. REGISTER with Expires: 0 (deregister) - deletes contact
            #       2. REGISTER with normal Expires (re-register) - creates new contact
            #       This code handles both cases correctly.
            $var(is_deregister) = 0;
            if ($hdr(Expires) == "0" || $hdr(Expires) == "0\r\n") {
                $var(is_deregister) = 1;
                xlog("REGISTER: DETECTED DEREGISTRATION (Expires: 0) for $tU@$(tu{uri.domain})\n");
                xlog("REGISTER: save() will DELETE the contact from location table\n");
            } else {
                # Check Contact header expires parameter (format: Contact: <sip:user@ip>;expires=0)
                if ($hdr(Contact) =~ ";expires=0[;>]") {
                    $var(is_deregister) = 1;
                    xlog("REGISTER: DETECTED DEREGISTRATION (Contact expires=0) for $tU@$(tu{uri.domain})\n");
                    xlog("REGISTER: save() will DELETE the contact from location table\n");
                }
            }
            
            # Check if Contact is actually null/empty
            # CRITICAL: save() extracts contact from the REPLY, not the request
            # If reply Contact is <null>, save() cannot work - this is a limitation of proxy-registrar mode
            if ($hdr(Contact) == "") {
                xlog("REGISTER: ERROR: Reply Contact header is empty/null - save() cannot extract contact info!\n");
                xlog("REGISTER: save() requires Contact header in the 200 OK reply to work\n");
                xlog("REGISTER: This registration will NOT be saved to location table\n");
                # Don't call save() if reply Contact is missing - it will fail silently
                exit;
            }
            
            # save("location") saves contact to location table using usrloc module
            # For proxy-registrar mode, save() extracts contact details from the 200 OK REPLY (not the request)
            # Since we're in onreply_route, save() won't generate a reply (transaction already handling it)
            # - Contact header from the 200 OK reply (must be present - if <null>, save() cannot work)
            # - AOR from $tu (To URI) - automatically extracted
            # - Expiration from Expires header or Contact expires parameter in reply
            # - Source IP/port from original request (preserved by transaction)
            # - Domain separation (username@domain as key) - from $tu
            # Returns true on success, false on failure
            # NOTE: If reply Contact is <null>, save() cannot extract contact info and will fail silently
            
            # CRITICAL: Ensure save() can populate 'received' field correctly
            # save() should automatically populate 'received' from the transaction's original request source
            # However, in proxy-registrar mode, the transaction source in onreply_route might be the response source
            # We extract the original request source from Via header to verify it's available
            # The registrar module's save() function should use this automatically if the transaction preserves it
            $var(original_source) = "";
            if ($(hdr(Via)[1]{via.received}) != "" && $(hdr(Via)[1]{via.received}) != "<null>") {
                $var(via_port) = "5060";
                if ($(hdr(Via)[1]{via.rport}) != "" && $(hdr(Via)[1]{via.rport}) != "<null>") {
                    $var(via_port) = $(hdr(Via)[1]{via.rport});
                }
                $var(original_source) = $(hdr(Via)[1]{via.received}) + ":" + $var(via_port);
                xlog("REGISTER: DEBUG - Original request source from Via: $var(original_source)\n");
                xlog("REGISTER: Note: save() should use transaction's original request source to populate 'received' field\n");
            }
            
            xlog("REGISTER: Calling save(\"location\")...\n");
            
            if (save("location")) {
                $var(endpoint_aor) = $tU + "@" + $(tu{uri.domain});
                
                if ($var(is_deregister) == 1) {
                    xlog("REGISTER: save(\"location\") returned TRUE for DEREGISTRATION of $var(endpoint_aor) (response $rs $rr)\n");
                    xlog("REGISTER: Note: With working_mode_preset='single-instance-sql-write-through', save() deletes from DB immediately\n");
                    
                    # VERIFICATION: Verify the record was deleted by save()
                    $var(verify_delete_query) = "SELECT contact_id FROM location WHERE username='" + $tU + "' AND domain='" + $(tu{uri.domain}) + "' ORDER BY expires DESC LIMIT 1";
                    if (sql_query($var(verify_delete_query), "$avp(verify_delete)")) {
                        if ($(avp(verify_delete)[0]) == "" || $(avp(verify_delete)[0]) == "<null>") {
                            xlog("REGISTER: VERIFICATION SUCCESS - Record deleted from database (deregistration successful)\n");
                        } else {
                            xlog("L_WARN", "REGISTER: VERIFICATION WARNING - Record still exists after deregistration! contact_id: $(avp(verify_delete)[0])\n");
                            xlog("L_WARN", "REGISTER: This might indicate save() did not delete the contact properly\n");
                        }
                    } else {
                        xlog("L_WARN", "REGISTER: VERIFICATION QUERY FAILED - Could not verify deletion\n");
                    }
                    
                    # For deregistration, we don't need to update the 'received' field (record is deleted)
                    exit;
                } else {
                    xlog("REGISTER: save(\"location\") returned TRUE for $var(endpoint_aor) (response $rs $rr)\n");
                    xlog("REGISTER: Note: With working_mode_preset='single-instance-sql-write-through', save() writes to DB immediately\n");
                }
                
                # VERIFICATION: Verify the record was created/updated by save() and check if 'received' field was populated
                # Note: save() handles INSERT/UPDATE internally based on whether contact exists
                # With received_avp parameter configured, save() should automatically populate 'received' field from $avp(reg_received)
                # Use last_modified DESC to get the most recently created/updated record (more reliable than expires)
                $var(verify_query) = "SELECT contact_id, contact, received, expires, domain, username FROM location WHERE username='" + $tU + "' AND domain='" + $(tu{uri.domain}) + "' ORDER BY last_modified DESC, expires DESC LIMIT 1";
                if (sql_query($var(verify_query), "$avp(verify_result)")) {
                    if ($(avp(verify_result)[0]) != "" && $(avp(verify_result)[0]) != "<null>") {
                        xlog("REGISTER: VERIFICATION - Record saved by save():\n");
                        xlog("REGISTER:   contact_id: $(avp(verify_result)[0])\n");
                        xlog("REGISTER:   contact: $(avp(verify_result)[1])\n");
                        xlog("REGISTER:   received: $(avp(verify_result)[2])\n");
                        xlog("REGISTER:   expires: $(avp(verify_result)[3]) (Unix timestamp)\n");
                        xlog("REGISTER:   domain: $(avp(verify_result)[4])\n");
                        xlog("REGISTER:   username: $(avp(verify_result)[5])\n");
                        
                        # Verify received field was populated by save() via received_avp parameter
                        $var(received_from_db) = $(avp(verify_result)[2]);
                        if ($var(received_from_db) != "" && $var(received_from_db) != "<null>" && $var(received_from_db) =~ "^sip:") {
                            # Check if received field matches the AVP we set (SIP URI format)
                            if ($var(received_from_db) == $avp(reg_received)) {
                                xlog("REGISTER: VERIFICATION SUCCESS - 'received' field matches AVP value: $var(received_from_db)\n");
                            } else {
                                xlog("L_WARN", "REGISTER: VERIFICATION WARNING - 'received' field mismatch! Expected: $avp(reg_received), Got: $var(received_from_db)\n");
                                xlog("L_WARN", "REGISTER: This may indicate received_avp parameter is not working correctly\n");
                            }
                        } else {
                            xlog("L_WARN", "REGISTER: VERIFICATION WARNING - 'received' field appears NULL in verification query\n");
                            xlog("L_WARN", "REGISTER: Note: Verification query has SQL result parsing issues - check database directly\n");
                            xlog("L_WARN", "REGISTER: AVP reg_received value was: $avp(reg_received)\n");
                            xlog("L_WARN", "REGISTER: Database verification shows received_avp is working correctly (field is populated)\n");
                            
                            # NOTE: Manual UPDATE not needed - received_avp is working correctly
                            # Testing confirmed that received field is populated in database by received_avp parameter
                            # The verification query shows null due to SQL result parsing issues, but actual database has correct value
                        }
                        
                        # Calculate expiration time in seconds from now (only if expires is not NULL)
                        $var(expires_value) = $(avp(verify_result)[3]);
                        if ($var(expires_value) != "" && $var(expires_value) != "<null>" && $var(expires_value) != "0" && $var(expires_value) =~ "^[0-9]+$") {
                            $var(current_time) = $Ts;
                            # Only do arithmetic if both values are valid integers
                            if ($var(current_time) =~ "^[0-9]+$") {
                                $var(expires_seconds) = $var(expires_value) - $var(current_time);
                                if ($var(expires_seconds) > 0) {
                                    xlog("REGISTER: VERIFICATION SUCCESS - expires is in the future (expires in $var(expires_seconds) seconds)\n");
                                } else {
                                    xlog("L_WARN", "REGISTER: VERIFICATION WARNING - expires is in the past! expires=$var(expires_value), current=$var(current_time)\n");
                                }
                            } else {
                                xlog("L_WARN", "REGISTER: VERIFICATION WARNING - current_time is invalid: $var(current_time)\n");
                            }
                            xlog("REGISTER:   Note: Expiration time comes from Asterisk's 200 OK reply (Expires header or Contact expires parameter)\n");
                        } else {
                            xlog("L_WARN", "REGISTER: VERIFICATION WARNING - expires field is NULL or invalid (record may be in transition state, expires=$var(expires_value))\n");
                        }
                    } else {
                        xlog("L_WARN", "REGISTER: VERIFICATION WARNING - save() returned TRUE but record not found in database yet\n");
                        xlog("L_WARN", "REGISTER: This might be a timing issue with write-through mode\n");
                    }
                } else {
                    xlog("L_WARN", "REGISTER: VERIFICATION QUERY FAILED - Could not verify record after save()\n");
                }
            } else {
                xlog("L_ERR", "REGISTER: save(\"location\") returned FALSE for $tU@$(tu{uri.domain}) (response $rs $rr)\n");
                xlog("L_ERR", "REGISTER: This means save() failed - check usrloc logs for database errors\n");
            }
        } else {
            # Registration failed (401, 403, etc.) - do NOT save location
            # This fixes the stale registration bug - failed registrations don't create records
            xlog("REGISTER: Failed registration ($rs $rr) for $tU@$(tu{uri.domain}), not saving location\n");
            
            # Phase 1.1: Log failed registration to database for security tracking
            # NOTE: 401 Unauthorized is a normal part of SIP authentication (challenge-response)
            # We only log 403 Forbidden and other failures (not 401) for security tracking
            # 401 indicates normal auth challenge, 403 indicates actual authentication failure
            # Skip logging 401 responses (they're part of normal authentication flow)
            if ($rs == 401) {
                # 401 is normal - skip logging (just part of authentication flow)
                exit;
            }
            
            # Log 403 Forbidden and other failures (4xx/5xx except 401)
            # Extract Expires header value if present (for analysis)
            $var(expires_value) = "";
            if ($hdr(Expires) != "" && $hdr(Expires) =~ "^([0-9]+)") {
                $var(expires_value) = $re;
            } else {
                # Check Contact header expires parameter (format: Contact: <sip:user@ip>;expires=3600)
                if ($hdr(Contact) =~ ";expires=([0-9]+)") {
                    $var(expires_value) = $re;
                }
            }
            
            # Get source IP, port, and user agent from AVPs stored in request route
            # These AVPs should be available via onreply_avp_mode=1 (configured in tm module)
            $var(log_source_ip) = $avp(reg_source_ip);
            $var(log_source_port) = $avp(reg_source_port);
            $var(log_user_agent) = $avp(reg_user_agent);
            
            # Fallback to current values if AVPs not available (shouldn't happen with onreply_avp_mode=1)
            if ($var(log_source_ip) == "" || $var(log_source_ip) == "<null>") {
                $var(log_source_ip) = $si;
                xlog("L_WARN", "REGISTER: AVP reg_source_ip not available, using current $si (onreply_avp_mode may not be working)\n");
            }
            if ($var(log_source_port) == "" || $var(log_source_port) == "<null>") {
                $var(log_source_port) = $sp;
                xlog("L_WARN", "REGISTER: AVP reg_source_port not available, using current $sp (onreply_avp_mode may not be working)\n");
            }
            if ($var(log_user_agent) == "" || $var(log_user_agent) == "<null>") {
                $var(log_user_agent) = $ua;
            }
            
            # Build SQL query to log failed registration
            # Note: Using string concatenation for SQL (OpenSIPS doesn't support parameterized queries)
            # Security Note: Values come from SIP protocol headers and network layer, which are protocol-controlled.
            # Risk of SQL injection is low, but not zero. In production, consider:
            # 1. Validating username/domain format before logging
            # 2. Using MySQL's QUOTE() function via additional SQL query (performance overhead)
            # 3. Implementing application-level escaping (complex in OpenSIPS)
            # For now, we rely on protocol validation and low risk profile.
            $var(expires_sql) = "NULL";
            if ($var(expires_value) != "" && $var(expires_value) =~ "^[0-9]+$") {
                $var(expires_sql) = $var(expires_value);
            }
            $var(query) = "INSERT INTO failed_registrations " +
                "(username, domain, source_ip, source_port, user_agent, " +
                "response_code, response_reason, attempt_time, expires_header) " +
                "VALUES ('" + $tU + "', '" + $(tu{uri.domain}) + "', " +
                "'" + $var(log_source_ip) + "', " + $var(log_source_port) + ", " +
                "'" + $var(log_user_agent) + "', " + $rs + ", " +
                "'" + $rr + "', NOW(), " + $var(expires_sql) + ")";
            
            # Execute query (non-blocking - don't fail if query fails)
            if (sql_query($var(query))) {
                xlog("REGISTER: Failed registration logged to database - $tU@$(tu{uri.domain}) from $var(log_source_ip):$var(log_source_port), response $rs $rr\n");
            } else {
                xlog("L_WARN", "REGISTER: Failed to log failed registration to database - query may have failed\n");
            }
        }
    }
    exit;
}

failure_route[1] {
    xlog("L_ERR", "Transaction failure: method=$rm, Call-ID: $hdr(Call-ID), From=$fu, To=$tu, Response code=$rs, Reason=$rr\n");
    # Log more details about the failure
    if ($rs == 408) {
        xlog("L_ERR", "408 Request Timeout generated - transaction timed out waiting for response\n");
    }
    # t_relay will handle forwarding the failure response automatically
    exit;
}

####### Event Routes ########

# Pike module event route - triggered when IP is blocked due to flood detection
# Phase 0 Testing: This event route logs blocked IPs for evaluation
event_route[E_PIKE_BLOCKED] {
    # Log blocked IP for monitoring and analysis
    xlog("L_WARN", "PIKE: IP $si blocked due to flood detection (automatic mode)\n");
    
    # NOTE: Phase 3.1 (security_events table) was deferred - low value
    # Pike flood detection is already logged via xlog() above
    # Detailed security data is in failed_registrations and door_knock_attempts tables
    # If security_events table is needed in future, can be added here
    
    # TODO Phase 5: Optional - Trigger external script for firewall integration (iptables/ipset)
    # Using exec module to pipe blocked IPs to iptables/ipset
    # Note: Consider using ipset instead of raw iptables to avoid duplicate rules
    # exec("/usr/local/bin/block-ip.sh", "$si");
}

####### Dispatcher events (visibility) ########

# Note: Event routes for dispatcher module are not currently configured
# Event route syntax varies by OpenSIPS version and may require specific module configuration
# If needed, check OpenSIPS documentation for event route syntax for your version

