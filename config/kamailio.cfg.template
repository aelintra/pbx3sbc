#!KAMAILIO
#
# Kamailio SIP Edge Router Configuration Template
# This file is used by install.sh if present, otherwise a default config is created
#

####### Global Parameters #########

debug=2
log_stderror=no
fork=yes
children=4

listen=udp:0.0.0.0:5060
# Set advertised address (replace with your Kamailio server's IP address)
# This fixes the Via header showing 0.0.0.0
advertised_address="192.168.1.95"

####### Modules ########

loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "xlog.so"
loadmodule "siputils.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "sanity.so"
loadmodule "dispatcher.so"
loadmodule "sqlops.so"
loadmodule "db_sqlite.so"

####### Module Parameters ########

# --- SQLite routing database ---
modparam("sqlops", "sqlcon",
    "cb=>sqlite:///var/lib/kamailio/routing.db")

# --- Dispatcher (health checks via SIP OPTIONS) ---
modparam("dispatcher", "db_url",
    "sqlite:///var/lib/kamailio/routing.db")

modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_threshold", 2)
modparam("dispatcher", "ds_inactive_threshold", 2)
modparam("dispatcher", "ds_ping_reply_codes", "200")

# --- Transaction timers ---
# fr_timer: timeout for non-INVITE transactions (increased from 5 to 30 seconds)
modparam("tm", "fr_timer", 30)
# fr_inv_timer: timeout for INVITE transactions (30 seconds should be sufficient)
modparam("tm", "fr_inv_timer", 30)
# restart_fr_on_each_reply: reset fr_inv_timer on each provisional response
# This prevents premature timeouts when provisional responses are received
modparam("tm", "restart_fr_on_each_reply", 1)
# retr_timer1: initial retransmission period (default 500ms, increased to 2 seconds)
# This controls how quickly Kamailio expects a response before retransmitting
modparam("tm", "retr_timer1", 2000)
# retr_timer2: maximum retransmission period (default 4 seconds, increased to 8 seconds)
modparam("tm", "retr_timer2", 8000)

####### Routing Logic ########

request_route {
    # ---- Log ALL requests at the very start for debugging ----
    xlog("L_INFO", "REQUEST: $rm from $si:$sp to $ru (Call-ID: $hdr(Call-ID))\n");

    # ---- Basic hygiene ----
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if (!sanity_check("1511", "7")) {
        xlog("L_WARN", "Malformed SIP from $si\n");
        exit;
    }

    # ---- Drop known scanners ----
    if ($ua =~ "sipvicious|friendly-scanner|sipcli|nmap") {
        exit;
    }

    # ---- In-dialog requests ----
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    # ---- Allowed methods only ----
    if (!is_method("REGISTER|INVITE|ACK|BYE|CANCEL|OPTIONS|NOTIFY|SUBSCRIBE")) {
        sl_send_reply("405", "Method Not Allowed");
        exit;
    }

    # ---- Handle CANCEL early (before domain check) ----
    # CANCEL needs to match existing INVITE transaction
    if (is_method("CANCEL")) {
        xlog("L_INFO", "CANCEL received from $si:$sp for Call-ID: $hdr(Call-ID), CSeq=$hdr(CSeq), From=$fu, To=$tu\n");
        # Check if there's a matching transaction
        if (t_check_trans()) {
            xlog("L_INFO", "CANCEL matches existing transaction, forwarding to cancel INVITE\n");
        } else {
            xlog("L_WARN", "CANCEL received but no matching transaction found\n");
            sl_send_reply("481", "Call/Transaction Does Not Exist");
            exit;
        }
        # Forward CANCEL to cancel the INVITE transaction
        route(RELAY);
        exit;
    }

    # ---- Log INVITE requests for debugging ----
    if (is_method("INVITE")) {
        xlog("L_INFO", "INVITE received from $si:$sp to $ru (From: $fu, To: $tu)\n");
    }

    # ---- Handle OPTIONS and NOTIFY from Asterisk backends (to endpoints) ----
    # Asterisk sends OPTIONS to registered endpoints for health checks and NAT keepalive
    # Asterisk sends NOTIFY for event notifications (e.g., message waiting indicators)
    # These need to be routed back to the actual endpoint IP
    if (is_method("OPTIONS|NOTIFY")) {
        # Check if this is coming from a known dispatcher destination (Asterisk backend)
        # Query database to see if source IP matches any dispatcher destination
        # Destination format is "sip:IP:PORT" or "sip:IP"
        $var(source_ip) = $si;
        xlog("L_INFO", "OPTIONS/NOTIFY received from $si, checking if from dispatcher\n");
        # Extract IP from destination field and compare with source IP
        # Destination format can be: just IP (192.168.1.91), sip:IP:PORT, or sip:IP
        # Handle all formats by checking if destination starts with "sip:" or is just an IP
        # First, let's see what destinations exist (debug only - remove after testing)
        if (sql_query("cb", "SELECT destination FROM dispatcher LIMIT 5", "debug_dest")) {
            if ($dbr(debug_dest=>rows) > 0) {
                xlog("L_INFO", "Sample dispatcher destinations in DB: $dbr(debug_dest=>[0,0])\n");
            }
            sql_result_free("debug_dest");
        }
        # Now check if source IP matches any dispatcher destination
        # Handle formats: IP (192.168.1.91), IP:PORT (192.168.1.91:5060), sip:IP, sip:IP:PORT
        # Extract IP from destination and compare with source IP
        if (sql_query("cb", "SELECT COUNT(*) FROM dispatcher WHERE CASE WHEN destination LIKE 'sip:%' THEN CASE WHEN instr(substr(destination, 5), ':') > 0 THEN substr(destination, 5, instr(substr(destination, 5), ':') - 1) ELSE substr(destination, 5) END WHEN instr(destination, ':') > 0 AND destination NOT LIKE 'sip:%' THEN substr(destination, 1, instr(destination, ':') - 1) ELSE destination END = '$var(source_ip)'", "dispatcher_check")) {
            if ($dbr(dispatcher_check=>rows) > 0) {
                $var(match_count) = $dbr(dispatcher_check=>[0,0]);
                xlog("L_INFO", "Dispatcher check result: found $var(match_count) matching destinations for IP $var(source_ip)\n");
                sql_result_free("dispatcher_check");
                if ($var(match_count) > 0) {
            
            # Extract endpoint identifier from To header (AoR)
            # Use $td (To header domain) to match how we store it during REGISTER
            $var(endpoint_aor) = $(tu{uri.user}) + "@" + $td;
            $var(endpoint_user) = $(tu{uri.user});
            
            xlog("L_INFO", "OPTIONS/NOTIFY from Asterisk $si, looking up endpoint AoR: $var(endpoint_aor) (user: $var(endpoint_user))\n");
            
            # Look up endpoint location from database
            # First try exact match with domain
            if (sql_query("cb", "SELECT contact_ip, contact_port FROM endpoint_locations WHERE aor='$var(endpoint_aor)' AND expires > datetime('now')", "endpoint_result")) {
                if ($dbr(endpoint_result=>rows) > 0) {
                    $var(endpoint_ip) = $dbr(endpoint_result=>[0,0]);
                    $var(endpoint_port) = $dbr(endpoint_result=>[0,1]);
                    sql_result_free("endpoint_result");
                    
                    xlog("L_INFO", "Database lookup result: IP=$var(endpoint_ip), Port=$var(endpoint_port)\n");
                    
                        # Validate IP and port
                        if ($var(endpoint_ip) == $null || $var(endpoint_ip) == "") {
                            xlog("L_ERR", "Invalid endpoint IP from database lookup\n");
                        } else {
                            if ($var(endpoint_port) == $null || $var(endpoint_port) == "") {
                                $var(endpoint_port) = "5060";
                            }
                            
                            # Construct destination URI directly using username and endpoint IP:port
                            # Get username from Request-URI or To header
                            $var(target_user) = $(tu{uri.user});
                            if ($var(target_user) == $null || $var(target_user) == "") {
                                $var(target_user) = $(ru{uri.user});
                            }
                            
                            # Build destination URI: sip:user@ip:port
                            $du = "sip:" + $var(target_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
                            # Construct proper Request-URI for routing
                            $ru = $du;
                            xlog("L_INFO", "Routing $rm from Asterisk $si to endpoint $du (exact match), Request-URI=$ru\n");
                            route(RELAY);
                            exit;
                        }
                }
                sql_result_free("endpoint_result");
                
                # Fallback: try lookup by username only (in case To header has IP instead of domain)
                xlog("L_INFO", "Exact match failed, trying username-only lookup for $var(endpoint_user)\n");
                if (sql_query("cb", "SELECT contact_ip, contact_port FROM endpoint_locations WHERE aor LIKE '$var(endpoint_user)@%' AND expires > datetime('now') LIMIT 1", "endpoint_result")) {
                    if ($dbr(endpoint_result=>rows) > 0) {
                        $var(endpoint_ip) = $dbr(endpoint_result=>[0,0]);
                        $var(endpoint_port) = $dbr(endpoint_result=>[0,1]);
                        sql_result_free("endpoint_result");
                        
                        xlog("L_INFO", "Database lookup result (username match): IP=$var(endpoint_ip), Port=$var(endpoint_port)\n");
                        
                        # Validate IP and port
                        if ($var(endpoint_ip) == $null || $var(endpoint_ip) == "") {
                            xlog("L_ERR", "Invalid endpoint IP from database lookup (username match)\n");
                        } else {
                            if ($var(endpoint_port) == $null || $var(endpoint_port) == "") {
                                $var(endpoint_port) = "5060";
                            }
                            
                            # Construct destination URI directly using username and endpoint IP:port
                            # Get username from To header (more reliable than Request-URI which might be invalid)
                            $var(target_user) = $(tu{uri.user});
                            if ($var(target_user) == $null || $var(target_user) == "") {
                                $var(target_user) = $(ru{uri.user});
                            }
                            
                            # Build destination URI: sip:user@ip:port
                            $du = "sip:" + $var(target_user) + "@" + $var(endpoint_ip) + ":" + $var(endpoint_port);
                            # Construct proper Request-URI for routing
                            $ru = $du;
                            xlog("L_INFO", "Routing $rm from Asterisk $si to endpoint $du (username match), Request-URI=$ru\n");
                            route(RELAY);
                            exit;
                        }
                    }
                    sql_result_free("endpoint_result");
                }
            }
            
            # Fallback: reply statelessly (health check works, but NAT pinhole won't stay open)
            # For NOTIFY, we should try to route anyway or it will fail
            xlog("L_WARN", "$rm from Asterisk $si to $var(endpoint_aor) - endpoint location not found in database (tried exact match and username match)\n");
            if (is_method("OPTIONS")) {
                sl_send_reply("200", "OK");
            } else {
                # For NOTIFY, try to route based on Contact header if available
                # Extract IP and port from Contact header using regex
                $var(notify_ip) = "";
                $var(notify_port) = "";
                if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                    $var(notify_ip) = $re;
                    if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                        $var(notify_port) = $re;
                    }
                }
                
                if ($var(notify_ip) != $null && $var(notify_ip) != "" && $var(notify_ip) != $si) {
                    $du = "sip:" + $(tu{uri.user}) + "@" + $var(notify_ip);
                    if ($var(notify_port) != $null && $var(notify_port) != "") {
                        $du = $du + ":" + $var(notify_port);
                    } else {
                        $du = $du + ":5060";
                    }
                    xlog("L_INFO", "Routing $rm to $du (fallback from Contact header)\n");
                    route(RELAY);
                } else {
                    sl_send_reply("404", "Not Found");
                }
            }
            exit;
                } else {
                    xlog("L_INFO", "OPTIONS/NOTIFY from $si is not from a known dispatcher destination (match_count=0), continuing normal routing\n");
                }
            } else {
                xlog("L_WARN", "Dispatcher check query returned no rows for IP $si\n");
                sql_result_free("dispatcher_check");
            }
        } else {
            xlog("L_WARN", "Failed to query dispatcher table for source IP $si\n");
        }
    }
    
    # ---- Handle REGISTER to track endpoint locations ----
    if (is_method("REGISTER")) {
        xlog("L_INFO", "REGISTER received from $si, Contact: $hdr(Contact), To: $hdr(To)\n");
        
        # Extract endpoint location from Contact header and store in database
        # This allows us to route OPTIONS from Asterisk back to endpoints
        # Check if Contact header exists and extract values
        if ($hdr(Contact) != $null && $hdr(Contact) != "") {
            # Extract AoR from To header (user@domain)
            # Use To header domain ($td) instead of Request-URI domain
            $var(endpoint_aor) = $(tu{uri.user}) + "@" + $td;
            
            # Extract IP and port from Contact header
            # Contact format: <sip:user@ip:port;params> or sip:user@ip:port
            # Primary: Use source IP/port since REGISTER comes directly from endpoint
            $var(endpoint_ip) = $si;
            $var(endpoint_port) = $sp;
            
            # Try to extract from Contact header as fallback (for NAT scenarios)
            # Use regex to extract IP:port from Contact header string
            # Handle cases where Contact header has angle brackets or complex parameters
            $var(contact_ip) = "";
            $var(contact_port) = "";
            
            # Extract IP address from Contact header (pattern: @IP:port or @IP)
            # Match IPv4 address after @ symbol
            if ($hdr(Contact) =~ "@([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})") {
                $var(contact_ip) = $re;
                
                # Extract port if present (pattern: :PORT after the IP)
                if ($hdr(Contact) =~ "@[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:([0-9]+)") {
                    $var(contact_port) = $re;
                }
            }
            
            # Use Contact header values if they're valid and different from source (NAT scenario)
            if ($var(contact_ip) != $null && $var(contact_ip) != "" && $var(contact_ip) != "0" && $var(contact_ip) != $si) {
                $var(endpoint_ip) = $var(contact_ip);
                xlog("L_INFO", "Using Contact header IP ($var(contact_ip)) instead of source IP ($si) - possible NAT scenario\n");
            }
            if ($var(contact_port) != $null && $var(contact_port) != "" && $var(contact_port) != "0" && $var(contact_port) != $sp) {
                $var(endpoint_port) = $var(contact_port);
                xlog("L_INFO", "Using Contact header port ($var(contact_port)) instead of source port ($sp)\n");
            }
            
            xlog("L_INFO", "Contact extraction: source IP=$si, source port=$sp, extracted IP=$var(contact_ip), extracted port=$var(contact_port), final IP=$var(endpoint_ip), Port=$var(endpoint_port), full Contact=$hdr(Contact)\n");
            
            # Validate extracted IP
            if ($var(endpoint_ip) == $null || $var(endpoint_ip) == "" || $var(endpoint_ip) == "0") {
                xlog("L_ERR", "Failed to extract IP - source IP=$si, Contact: $hdr(Contact)\n");
            } else {
                if ($var(endpoint_port) == $null || $var(endpoint_port) == "") {
                    $var(endpoint_port) = "5060";
                }
                
                # Get expires from Expires header or Contact header
                $var(expires) = $hdr(Expires);
                if ($var(expires) == $null || $var(expires) == "") {
                    $var(expires) = "3600";  # Default 1 hour
                }
                
                xlog("L_INFO", "Extracted endpoint info: AoR=$var(endpoint_aor), IP=$var(endpoint_ip), Port=$var(endpoint_port), Expires=$var(expires)\n");
                
                # Store/update endpoint location in database
                # Use SQLite's datetime functions to calculate expiration (current time + expires seconds)
                if (sql_query("cb", "INSERT OR REPLACE INTO endpoint_locations (aor, contact_ip, contact_port, expires) VALUES ('$var(endpoint_aor)', '$var(endpoint_ip)', '$var(endpoint_port)', datetime(strftime('%s', 'now') + $var(expires), 'unixepoch'))", "reg_result")) {
                    sql_result_free("reg_result");
                    xlog("L_INFO", "Successfully tracked endpoint location: $var(endpoint_aor) -> $var(endpoint_ip):$var(endpoint_port) (expires in $var(expires) seconds)\n");
                } else {
                    xlog("L_ERR", "Failed to store endpoint location: $var(endpoint_aor) -> $var(endpoint_ip):$var(endpoint_port) (SQL query failed)\n");
                }
            }
        } else {
            xlog("L_WARN", "REGISTER without Contact header - cannot track endpoint location\n");
        }
        # Continue to DOMAIN_CHECK to forward REGISTER to Asterisk
    }

    route(DOMAIN_CHECK);
}

####### Domain validation / door-knocker protection ########

route[DOMAIN_CHECK] {

    $var(domain) = $rd;

    if ($var(domain) == "") {
        exit;
    }

    # Optional extra hardening: domain consistency
    if ($rd != $td) {
        xlog("L_WARN",
             "R-URI / To mismatch domain=$rd src=$si\n");
        exit;
    }

    # Lookup dispatcher set for this domain
    if (!sql_query("cb", "SELECT dispatcher_setid FROM sip_domains WHERE domain='$var(domain)' AND enabled=1", "domain_result")) {
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (query failed)\n");
        exit;
    }
    
    # Check if domain was found
    if ($dbr(domain_result=>rows) == 0) {
        sql_result_free("domain_result");
        xlog("L_NOTICE",
             "Door-knock blocked: domain=$var(domain) src=$si (not found)\n");
        exit;
    }

    # Get the dispatcher_setid from query result (first row, first column)
    $var(setid) = $dbr(domain_result=>[0,0]);
    sql_result_free("domain_result");

    route(TO_DISPATCHER);
}

####### Health-aware routing ########

route[TO_DISPATCHER] {

    # Select a healthy Asterisk from the dispatcher set
    if (!ds_select_dst($var(setid), "4")) {
        xlog("L_ERR",
             "No healthy Asterisk nodes for domain=$rd setid=$var(setid)\n");
        sl_send_reply("503", "Service Unavailable");
        exit;
    }

    xlog("L_INFO", "Routing to $du for domain=$rd setid=$var(setid) method=$rm Request-URI=$ru\n");

    record_route();

    if (!t_relay()) {
        xlog("L_ERR", "t_relay() failed for $du method=$rm Request-URI=$ru\n");
        sl_reply_error();
        exit;
    }

    xlog("L_INFO", "t_relay() succeeded for $du method=$rm, transaction created\n");
    # For INVITE, ensure transaction stays active
    # The transaction module should handle this automatically, but log it
    if (is_method("INVITE")) {
        xlog("L_INFO", "INVITE transaction created, waiting for response from $du\n");
    }
    exit;
}

####### In-dialog handling ########

route[WITHINDLG] {
    xlog("L_INFO", "In-dialog request: $rm from $si to $ru (Call-ID: $hdr(Call-ID))\n");

    if (loose_route()) {
        route(RELAY);
        exit;
    }

    sl_send_reply("404", "Not Here");
    exit;
}

route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

####### Response handling (for debugging) ########

onreply_route {
    xlog("L_INFO", "Response received: $rs $rr from $si (method=$rm, CSeq=$hdr(CSeq), To-tag=$tt, Contact=$hdr(Contact))\n");
    # Log transaction state for debugging
    if ($rs >= 100 && $rs < 200) {
        xlog("L_INFO", "Provisional response $rs received, transaction should remain active\n");
        # For provisional responses, explicitly exit to let transaction module handle forwarding
        # The transaction module will automatically forward and keep transaction alive
        exit;
    } else if ($rs >= 200 && $rs < 300) {
        xlog("L_INFO", "Final success response $rs received\n");
        exit;
    } else if ($rs >= 300) {
        xlog("L_INFO", "Final error response $rs received\n");
        exit;
    }
    # If we get here, exit to let transaction module handle it
    exit;
}

failure_route {
    xlog("L_ERR", "Transaction failure: method=$rm, Call-ID=$hdr(Call-ID), From=$fu, To=$tu, Response code=$rs, Reason=$rr\n");
    # Log more details about the failure
    if ($rs == 408) {
        xlog("L_ERR", "408 Request Timeout generated - transaction timed out waiting for response\n");
    }
    # t_relay will handle forwarding the failure response automatically
    exit;
}

####### Dispatcher events (visibility) ########

event_route[dispatcher:dst-up] {
    xlog("L_INFO", "Asterisk UP: $du\n");
}

event_route[dispatcher:dst-down] {
    xlog("L_WARN", "Asterisk DOWN: $du\n");
}
